<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>聊天室项目</title>
      <link href="/2019/01/04/%E8%81%8A%E5%A4%A9%E5%AE%A4%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/01/04/%E8%81%8A%E5%A4%A9%E5%AE%A4%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>socket需要有服务器端和客户端</p><p>客户端在连接服务器时，需要指定服务器的IP（标识电脑）和端口号（标识电脑上的具体某个应用）</p><p>通信的前提是：要创建基站，并与基站建立连接。</p><a id="more"></a><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p><strong>Scoket类</strong></p><ul><li>绑定指定域名、端口号的服务器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Socket</span><span class="params">(String host, <span class="keyword">int</span> port, InetAddress localAddr,<span class="keyword">int</span> localPort)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>获取客户端输入流，读取服务器发来的消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>获取客户端输出流，向服务器发送消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> OutputStream <span class="title">getOutputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><h4 id="基站类—ServerSocket"><a href="#基站类—ServerSocket" class="headerlink" title="基站类—ServerSocket"></a>基站类—ServerSocket</h4><ul><li>默认绑定本地IP：127.0.0.1，以及指定端口号。在本机根据指定端口号创建服务器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>等待客户端连接，线程阻塞，当有客户连接时，返回客户端socket。侦听并接受连接到本服务的客户端连接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Socket <span class="title">accept</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>当服务器与客户端建立起连接后，通过输入输出流（客户端的Scoket）来通信</p><ul><li>获取服务器端输入流，读取客户端发来的消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>获取服务器端输出流，向客户端发送消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> OutputStream <span class="title">getOutputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="简单版的单线程聊天"><a href="#简单版的单线程聊天" class="headerlink" title="简单版的单线程聊天"></a>简单版的单线程聊天</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM</title>
      <link href="/2019/01/03/JVM/"/>
      <url>/2019/01/03/JVM/</url>
      
        <content type="html"><![CDATA[<p>虚拟机是通过软件模拟的具有完整硬件功能，运行在完全隔离环境中的计算机系统。</p><p>使用最多的是VMWare和Virtual Box。</p><p>JVM是通过软件<strong>模拟Java字节码指令集</strong>，JVM只保留了PC寄存器，而普遍的虚拟机有很多寄存器。</p><p>做JVM的公司有很多家，从<strong>JDK1.3</strong>开始，HotSpot为默认JVM。</p><p>JVM上<strong>不止可以运行Java的代码</strong></p><a id="more"></a><h3 id="JVM内存区域划分"><a href="#JVM内存区域划分" class="headerlink" title="JVM内存区域划分"></a>JVM内存区域划分</h3><p>Java内存区共分为6块内存</p><h4 id="线程私有内存"><a href="#线程私有内存" class="headerlink" title="线程私有内存"></a>线程私有内存</h4><p>每个线程都有，并且彼此之间相互隔离</p><ul><li>程序计数器</li></ul><p>程序计数器是比较小的内存空间，记录当前线程所执行的字节码的行号指示器。</p><p><strong>程序计数器记录的两种情况：</strong></p><p>1、若当前的线程执行的是Java方法，程序计数器记录的是正在执行的JVM字节码指令地址</p><p>2、若当前的执行线程执行的是Native方法，计数器值为空（监测不到C语言）</p><p>程序计数器是<strong>唯一一块不会产生OOM异常</strong>的区域</p><ul><li>虚拟机栈</li></ul><p>虚拟机栈描述Java<strong>方法</strong>执行的<strong>内存</strong>模型。</p><p>每个方法执行的同时，都会创建一个栈桢来存储<strong>局部变量表、操作数栈、方法出口</strong>等信息。每个方法从调用直到执行完毕的过程，对应一个栈桢在虚拟机栈的入栈和出栈过程。</p><p><strong>局部变量表存放内容：</strong>8种基本数据类型和对象引用（4个字节），因此每次开辟虚拟机栈桢的大小是确定的。</p><p>生命周期与线程相同：在创建线程时，同时创建线程的虚拟机栈。在线程执行完毕时，虚拟机栈也被一同回收。</p><p><strong>此区域一共会产生两种异常：</strong></p><p>1、若线程请求的栈深度大于JVM允许的深度（-Xss设置栈容量），抛出<code>StackOverFlowError</code>异常。常见于单线程</p><p>2、虚拟机在进行栈的动态扩展时，若无法申请到足够内存，抛出OOM（<code>OutOfMemoryError</code>）异常。常见于多线程</p><ul><li>本地方法栈</li></ul><p>本地方法（<code>Native</code>方法）执行的内存模型</p><p>在<strong>HotSpot虚拟机</strong>中，本地方法栈与虚拟机栈是同一块内存区域。</p><h4 id="线程共享内存"><a href="#线程共享内存" class="headerlink" title="线程共享内存"></a>线程共享内存</h4><p>所有线程共享此内存空间，并且此内存空间<strong>对所有线程可见</strong></p><ul><li>堆（GC堆）</li></ul><p>Java堆是JVM管理的最大内存区域。当JVM启动时创建。所有线程共享此内存，此内存中存放的都是数组和对象实例。</p><p>Java堆是垃圾回收器管理的最主要内存区域。Java堆可以处于物理上不连续的内存空间。-Xmx设置堆最大值，-Xms设置堆最小值</p><p><strong>异常：</strong>若在堆中没有足够的内存完成对象实例分配并且堆无法再次扩展时，抛出OOM异常</p><ul><li>方法区</li></ul><p>用于存储已被JVM加载的类信息、常量、静态变量等数据。JDK8以前，方法区也叫永久代。JDK8以后叫做元空间（Meta Space）</p><p>方法区无法满足内存分配需求时，抛出OOM</p><ul><li>运行时常量池</li></ul><p>运行时常量池是方法区的一部分，存放字面量与符号引用</p><p><strong>字面量：</strong>字符串常量（JDK7中移入堆中）、final常量、基本数据类型的值</p><p><strong>符号引用：</strong>类、字段、方法的完全限定名、名称、描述符</p><p>JVM内存区域划分-&gt;判断对象是否存活-&gt;垃圾回收算法-&gt;</p><h4 id="对象产生的过程"><a href="#对象产生的过程" class="headerlink" title="对象产生的过程"></a>对象产生的过程</h4><p>符号引用-&gt;类-&gt;具体引用 </p><p>根据符号引用去JVM方法区拿到该类的信息，然后再去堆中开辟空间</p><h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><p>OOM共有两种：内存溢出和内存泄漏</p><p><strong>内存泄漏：</strong>无用对象无法被垃圾回收，无法解决</p><p><strong>内存溢出：</strong></p><h3 id="垃圾回收器与内存分配策略"><a href="#垃圾回收器与内存分配策略" class="headerlink" title="垃圾回收器与内存分配策略"></a>垃圾回收器与内存分配策略</h3><h4 id="判断对象是否已死"><a href="#判断对象是否已死" class="headerlink" title="判断对象是否已死"></a>判断对象是否已死</h4><ul><li>引用计数法</li></ul><p>给每个对象附加一个引用计数器，每当有一个地方引用此对象时，计数器+1；每当有一个引用失效时，计数器-1；在任意时刻，只要计数器值为0的对象就是不能再被使用，即对象已死。</p><p>引用计数法实现简单，判定效率较高，但是无法解决循环引用问题。JVM并未采用此算法</p><p><code>-XX:+printGC</code>:查看垃圾处理装置</p><ul><li>可达性分析算法</li></ul><p>Java采用可达性分析算法来判断对象是否存活（C#也适用该算法）</p><p><strong>核心思想:</strong>通过一系列<code>GC Roots</code>的对象作为起点，从这些节点开始向下搜索对象，搜索走过的路径，称为“引用链”，当一个对象到任意一个GC Roots对象没有任何的引用链相连时（从GC Roots到对象不可达），证明此对象已死。</p><p><strong>Java中能作为GC Roots的对象包含以下四种：</strong></p><p>1、虚拟机栈中的引用对象</p><p>2、类静态变量引用的对象</p><p>3、本地方法栈中引用的对象</p><p>4、常量引用的对象</p><p><strong>JDK1.2之后对于引用的概念做了扩充：</strong></p><ul><li>强引用-StrongReference</li></ul><p>强引用指的是代码中普遍存在的，类似于Object obj = new Object();</p><p>在JVM中只要强引用还在，垃圾回收器永远不会回收此类对象的空间</p><ul><li>软引用-SoftReference</li></ul><p>软引用用来描述一些有用但不必须的对象，对于仅被软引用指向的对象，在系统将要发生内存溢出之前，会将<strong>所有软引用对象</strong>进行垃圾回收。若内存够用，这些对象仍然保留。在JDK1.2之后，提供了Soft Reference来实现软引用。</p><ul><li>弱引用-WeakReference</li></ul><p>弱引用用来描述一些有用但不必须的对象，但弱引用比软引用更差一点。仅被弱引用关联的对象最多只能生存到下一次GC开始之前。当垃圾回收器开始工作时，<strong>无论当前内存是否够用</strong>，都会回收掉仅被弱引用关联的对象。JDK1.2以后，使用WeakReference来实现弱引用</p><ul><li>虚引用-PhantomReference</li></ul><p>虚引用也称为幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在完全不会对其生存时间有影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是在这个对象被GC之前，收到一个系统通知。JDK1.2之后，提供PhantomReference来描述虚引用。</p><p><strong>为什么要有虚引用：</strong></p><p>在一个虚引用被垃圾回收之前，会收到一个通知来告诉JVM该虚引用对象将被销毁</p><h4 id="对象的自我拯救-finalize"><a href="#对象的自我拯救-finalize" class="headerlink" title="对象的自我拯救-finalize"></a>对象的自我拯救-finalize</h4><p>在可达性分析算法中不可达对象，也并非“非死不可”，所有不可达的对象处于缓刑阶段。要宣告一个对象的彻底死亡，需要经历两次标记过程：</p><p>若对象在进行可达性分析之后，发现到GC Roots不可达，此对象会进行一次筛选过程。</p><p><strong>筛选的条件</strong>是此对象是否有必要执行<code>finalize()</code>。当对象没有覆写<code>finalize()</code>或<code>finalize()</code>已被调用过，JVM会将此对象彻底宣判死亡。若筛选成功（对象覆写了<code>finalize()</code>，并且未被执行过），会将此对象放到F-Queue中</p><p>如果对象在finalize方法中成功自救（此对象与任意一个GC Roots建立联系），则对象在第二次标记时被移除回收集合，成功存活；若对象在finalize中仍然与GC Roots不可达，宣告死亡。</p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>方法区的回收主要回收两部分内容：废弃常量和无用的类</p><p><strong>判断常量是否被废弃的条件：</strong></p><p>常量未被引用</p><p><strong>判断一个类是无用类的条件：</strong></p><p>1、该类的所有实例都已经被回收，也就是在堆中不存在该类的任何实例。</p><p>2、加载该类的类加载器都被回收</p><p>3、该类的Class对象没有在任何其他地方被引用，也无法通过反射访问该类的所有内容</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><ul><li>算法核心思想：</li></ul><p>整个算法分为<strong>标记清除</strong>两个阶段：标记阶段标记出此次垃圾回收需要回收的对象，清除阶段一次性清除所有带标记对象。</p><p>如图所示：</p><p><img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.PNG"></p><ul><li>弊端</li></ul><p>1.效率上：标记与清除两个阶段的效率都不高</p><p>2.空间问题：标记清除算法会产生大量的不连续空间，若程序中需要分配较大连续对象时，由于空间碎片较多因此无法找到连续内存而不得不再次出发GC</p><h4 id="复制算法-新生代垃圾回收算法"><a href="#复制算法-新生代垃圾回收算法" class="headerlink" title="复制算法-新生代垃圾回收算法"></a>复制算法-新生代垃圾回收算法</h4><ul><li>核心思想</li></ul><p>将内存块按容量划分为大小相等的两块，每次只使用其中一块内存。当使用的内存需要垃圾回收时，会将此区域的所有存活对象一次性复制到保留区域，然后将使用的内存块一次清理掉。</p><p><img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.PNG"></p><ul><li>弊端</li></ul><p>复制算法最大的问题在于内存利用率太低，商用JVM都对复制算法做了改进</p><h4 id="JVM改进后的算法"><a href="#JVM改进后的算法" class="headerlink" title="JVM改进后的算法"></a>JVM改进后的算法</h4><p>新生代中98%的对象都是“朝生夕死”（存活时间短），所以并不需要按照1:1来划分内存空间。将内存（新生代内存）分为一块较大的Eden（伊甸园）和两块较小的Survivor（幸存者空间，大小一样，一块称为From区，一块称为To区）空间。每次只使用Eden和其中一块Survivor区域。（默认比例8:1:1）</p><ul><li>HotSpot复制算法流程</li></ul><p>1.当Eden区满的时候，会触发一次垃圾垃圾回收，将所有的存活对象拷贝到From区域中，然后一次性清除Eden区；当Eden区再次触发Minor GC，会扫描Eden区的From区，将这两块空间中的存活对象拷贝到To区，而后一次性清除Eden区的From区的不存活对象</p><p>2.当后续Eden区再次发生Minor GC时，会对Eden和To区进行回收，存活对象移动到From区，后续流程类似，只是将From和To区来回作为保留区域</p><p>3.部分对象会在From与To区域中来回复制，如此交换15次（MaxTenuringThreshold,默认为15）最终会存入老年代</p><p><img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/%E5%8D%87%E7%BA%A7%E7%89%88.png"></p><p>Survivor区域若无法放下所有存活对象，需要依赖其他内存（肉老年代）</p><h4 id="标记整理算法—老年代GC算法"><a href="#标记整理算法—老年代GC算法" class="headerlink" title="标记整理算法—老年代GC算法"></a>标记整理算法—老年代GC算法</h4><p>老年代中对象存活率很高，因此不适用复制算法（需要大量进行对象的复制过程，效率很低）</p><ul><li>算法思想</li></ul><p>算法分为标记与整理两个阶段。标记过程与标记清除过程一致，整理过程需要让所有存活对象向一端移动，而后直接清理掉存活对象边界以外的内存</p><h4 id="分代回收算法"><a href="#分代回收算法" class="headerlink" title="分代回收算法"></a>分代回收算法</h4><ul><li>算法核心思想</li></ul><p>根据对象的存活周期将内存分为以下两块</p><p>新生代：每次GC都有大批对象死去，只有少量存活，因此采用复制算法</p><p>老年代：对象存活率较高，没有额外空间对其分配担保，采用标记整理算法</p><h4 id="Minor-FullGC"><a href="#Minor-FullGC" class="headerlink" title="Minor FullGC"></a>Minor FullGC</h4><p>1.MinorGC称为新生代GC：指的是发生在新生代的垃圾回收。由于新生代对象大多存活周期较短，因此MinorGC发生频率非常频繁，一般回收速度较高</p><p>2.Full GC称为老年代GC或Major GC</p><p>GC：指的是发生在老年代的垃圾回收，出现了Major</p><p>GC通常会伴随至少一次的Minor GC（并非绝对）。一般Full GC比Minor GC慢10倍以上，发生频率较低</p><h3 id="垃圾收集器（垃圾回收算法的具体实现）-JDK8"><a href="#垃圾收集器（垃圾回收算法的具体实现）-JDK8" class="headerlink" title="垃圾收集器（垃圾回收算法的具体实现）-JDK8"></a>垃圾收集器（垃圾回收算法的具体实现）-JDK8</h3><ul><li>串行</li></ul><p>垃圾回收线程与用户线程在JVM中顺序执行</p><ul><li>并行</li></ul><p>垃圾回收线程一起执行，用户线程仍处于等待状态</p><ul><li>并发</li></ul><p>垃圾回收线程与用户线程一起执行</p><ul><li>STW</li></ul><p>当垃圾回收线程工作时，用户线程处于等待状态</p><p><strong>新生代垃圾回收器：</strong></p><p>Serial（串行收集器）、ParNew（并行）、parallel Scavenge（并行）</p><p><strong>老年代垃圾回收器：</strong></p><p>CMS（并发）、Serial Old（串行）、Parallel Old（并行）</p><p>全区域垃圾回收器：G1（并发）</p><h3 id="对象分配策略"><a href="#对象分配策略" class="headerlink" title="对象分配策略"></a>对象分配策略</h3><h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>大多数情况下，对象在新生代Eden区分配。当Eden区没有足够的空间分配时，JVM发生一次Minor GC</p><p><code>-Xmn</code>:新生代内存大小</p><p><code>-XX:SurvivorRatio = 8</code>:改变分配比例</p><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p><code>-XX:PretenureSizeThreshold = 字节大小</code>对象超过规定大小就将对象放入老年代</p><h4 id="长期存活对象进入老年代"><a href="#长期存活对象进入老年代" class="headerlink" title="长期存活对象进入老年代"></a>长期存活对象进入老年代</h4><p>JVM给每个对象定义了一个对象年龄的计数器，若对象在Eden去出生并且经历一次Minor GC后，仍然存活并且能被Survivor容纳，将此对象的年龄置为1，此后对象每再Survivor区域中经历一次Minor GC，年龄就增加一岁。当其年龄增加到一定程度（默认为15），此对象晋升到老年代</p><p><code>-XX:MaxTenuringThreshold = 15</code>设置晋升到老年代的大小</p><h4 id="动态年龄判定"><a href="#动态年龄判定" class="headerlink" title="动态年龄判定"></a>动态年龄判定</h4><p>JVM并不是永远要求对象的年龄必须达到MaxTenuringThreshold规定的值，才能晋升老年代。若Survivor空间中相同年龄的所有对象大小的总和和大于Survivor空间的一半，此时年龄大于等于该年龄的所有对象直接进入老年代，无须等到MaxTenuringThreshold要求的年龄</p><h3 id="JDK命令行工具"><a href="#JDK命令行工具" class="headerlink" title="JDK命令行工具"></a>JDK命令行工具</h3><ul><li>jps***</li></ul><p><strong>JVM进程状态工具</strong></p><p>列出正在运行的JVM进程，并返回进程ID</p><p>常用参数：<code>-l</code> 输出主类的全名称，返回进程ID</p><ul><li>jstat</li></ul><p>JVM统计信息监视工具，显示本地或远程JVM中类装载、内存、垃圾回收等数据</p><p><code>jstat -gcutil PID</code>:显示垃圾回收信息</p><ul><li>jinfo</li></ul><p>JVM配置信息查看工具</p><p><code>jinfo -flags PID</code></p><ul><li>jmap***</li></ul><p>内存映像工具</p><p>jmap用于生成堆转储快照（堆得快照）</p><p><code>jmap -heap PID</code>：显示JVM堆具体信息</p><p><code>jmap -histo PID</code>:显示JVM中对象的统计信息</p><ul><li>jhat</li></ul><p>heap文件的分析工具</p><p><code>jhat heap文件路径</code></p><ul><li>jstack***</li></ul><p>Java栈跟踪工具</p><p>jstack生成当前JVM线程的快照。</p><p>可用于定位线程出现长时间停顿的原因</p><h3 id="Java内存模型—JMM"><a href="#Java内存模型—JMM" class="headerlink" title="Java内存模型—JMM"></a>Java内存模型—JMM</h3><p>Java内存模型是基于线程的，JMM定义的主要目标是为了定义程序中各个变量的访问规则（JVM中如何将变量从内存中取出以及如何将变量再写回内存的细节）。此处的变量包括实例字段、静态字段与数组元素</p><h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><p>主内存是所有线程共享的，而工作内存指的是每个线程独有的</p><p>JMM规定<strong>所有变量必须存储在主内存</strong>中。每条线程都有自己的工作内存，工作内存中保存了该线程使用到的变量的主内存副本。线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，不能直接读写主内存中的变量。不同线程之间也无法直接访问彼此的工作内存变量，线程间变量值的传递均需要通过主内存来完成。</p><h4 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h4><p><strong>JMM内存三大特性：</strong></p><ul><li>原子性</li></ul><p>基本数据类型的访问读写是具有原子性，如若需要更大范围的原子性，需要内键锁或lock体系的支持（i++、i–等操作）</p><ul><li>可见性</li></ul><p>当一个线程修改了共享变量的值，其他线程能够立即得知此修改。volatile、final、synchronized可以实现可见性</p><ul><li>有序性</li></ul><p>如果在本线程内观察，所有操作都是有序的；若在线程之外观察另外一个线程，所有操作都是无序的</p><p>JMM具备先天的有序性，即无须通过任何手段就能保证的有序性。称为JMM的happens-before原则。若两个操作的次序无法从happens-before中推导出来，则无法保证其有序性，JVM可以随意对其重排序。</p><p>要想并发程序正确执行，必须同时保证原子性、可见性以及有序性。只要有任意一个没有被保证，就有可能导致程序运行不正确</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</p><ul><li>保证此变量对所有线程的可见性</li></ul><p>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。普通变量无法做到可见性。</p><p>volatile变量在各个线程中是一致的，但是volatile变量的运算在并发下一样是不安全的。Java中运算操作并非原子性操作，必须结合内键锁或lock体系来约束。</p><ul><li>由于volatile变量只保证可见性，在不符合一下两条规则的场景下，仍然需要使用加锁来保证原子性：</li></ul><p>1.运算结果不依赖当前变量的值，或者能够确保只有单一的线程修改变量值</p><p>2.变量不需要与其他的状态变量共同参与不变约束</p><ul><li>并发场景下对于类似i++操作如何保证程序的正确结果：</li></ul><p>1、加锁</p><p>2、使用原子类（java.util.concurrent.atomic包下的所有类-内部使用CAS保证原子性）</p><ul><li>禁止指令重排（内存屏障）</li></ul><p>1.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作更改肯定全部已经执行完毕且结果已经对后面的操作可见，在其后面的操作肯定还没有执行</p><p>2.在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能提前执行</p><h4 id="懒汉式单例的线程安全问题"><a href="#懒汉式单例的线程安全问题" class="headerlink" title="懒汉式单例的线程安全问题"></a>懒汉式单例的线程安全问题</h4>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深浅拷贝</title>
      <link href="/2019/01/03/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2019/01/03/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><p>拷贝的执行函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><p>并不是所有的类都可以被拷贝，需实现<code>Cloneable</code>接口，并且在类中自定义<code>clone()</code>调用Object类提供的继承权限<code>clone()</code></p><p>若不实现Cloneable接口，在调用<code>clone()</code>时，会抛出CloneNotSupportedException异常。</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>对于浅拷贝而言，拷贝出来的对象仍然保留原对象的所有引用。</p><p>只要拷贝对象和原对象中引用的属性发生改变，其所有的该引用属性都会发生改变</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>对于深拷贝而言，拷贝出来的对象会产生新的对象。</p><p>对于拷贝的原对象和拷贝出来的对象来说，改变一个引用的属性，互不影响</p><p>对象中包含的引用只是自定义引用</p><h3 id="如何实现深拷贝"><a href="#如何实现深拷贝" class="headerlink" title="如何实现深拷贝"></a>如何实现深拷贝</h3><p>1.包含的其他类继续实现Cloneable接口，并且调用<code>clone()</code></p><p>2*.实现序列化</p><h4 id="调用clone"><a href="#调用clone" class="headerlink" title="调用clone()"></a>调用<code>clone()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baby</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Baby&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Baby <span class="title">clone</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        Baby baby = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            baby =(Baby) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Baby</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line">    <span class="keyword">public</span> Baby baby;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Monkey</span><span class="params">(String name, Integer age, Baby baby)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.baby = baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Monkey&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", baby="</span> + baby +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Baby <span class="title">getBaby</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBaby</span><span class="params">(Baby baby)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baby = baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Monkey <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Monkey monkey = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            monkey = (Monkey) <span class="keyword">super</span>.clone();</span><br><span class="line">            monkey.baby = <span class="keyword">this</span>.baby.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> monkey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Baby baby = <span class="keyword">new</span> Baby(<span class="string">"zxh"</span>,<span class="number">3</span>);</span><br><span class="line">        Monkey monkey = <span class="keyword">new</span> Monkey(<span class="string">"zh"</span>,<span class="number">88</span>,baby);</span><br><span class="line"></span><br><span class="line">        Monkey monkey1 = monkey.clone();</span><br><span class="line">        System.out.println(monkey1);</span><br><span class="line">System.out.println(monkey.baby == monkey1.baby);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><ul><li>概念</li></ul><p>将内存中保存的对象变为二进制流，进行输出或保存在文本中，即将对象变为二进制流。<br>若类要实现序列化，必须实现<code>Serializable</code>接口</p><p>Serializable接口为标识接口，只有实现了Serializable接口的类，才具备对象序列化的功能。</p><p>但要具体实现序列化和反序列化需要使用IO包中提供的两个处理类：ObjectOutputStream（序列化）、ObjectInputStream（反序列化）</p><ul><li>ObjectOutputStream（序列化）</li></ul><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectOutputStream</span><span class="params">(OutputStream out)</span></span>;</span><br></pre></td></tr></table></figure><p>将文件转化为二进制流输出到终端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writeObject(Object obj);</span><br></pre></td></tr></table></figure><p>例程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Monkey</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Monkey&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\pxx\\Desktop"</span> + <span class="string">"\\1.txt"</span>);</span><br><span class="line">        Monkey monkey = <span class="keyword">new</span> Monkey(<span class="string">"zh"</span>,<span class="number">99</span>);</span><br><span class="line">        OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(outputStream);</span><br><span class="line">        oos.writeObject(monkey);</span><br><span class="line">        oos.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>transient</code>关键字</p><p>若希望类中的若干属性不被序列化，可以在属性前添加该关键字</p></li><li><p>ObjectInputStream(反序列化)</p></li></ul><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectInputStream</span><span class="params">(InputStream in)</span></span>;</span><br></pre></td></tr></table></figure><p>将文件中的二进制流输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readObject(Object obj);</span><br></pre></td></tr></table></figure><h4 id="使用序列化实现深拷贝"><a href="#使用序列化实现深拷贝" class="headerlink" title="使用序列化实现深拷贝"></a>使用序列化实现深拷贝</h4><p>使用序列化进行深拷贝时，无须实现Cloneable接口，而需要实现Serializable接口</p><p>用序列化实现上一例程的拷贝Monkey对象的功能，代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public Monkey ObjectClone()&#123;</span><br><span class="line"></span><br><span class="line">        OutputStream outputStream = new ByteOutputStream();</span><br><span class="line">        Monkey monkey = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(outputStream);</span><br><span class="line"></span><br><span class="line">            oos.writeObject(this);</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            InputStream bis = new ByteInputStream(((ByteOutputStream) outputStream).getBytes(),((ByteOutputStream) outputStream).size());</span><br><span class="line">            ObjectInputStream ois = new ObjectInputStream(bis);</span><br><span class="line"></span><br><span class="line">            monkey = (Monkey) ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line">            bis.close();</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return monkey;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络基础概念理解</title>
      <link href="/2018/12/25/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
      <url>/2018/12/25/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>总是听到身边的人说局域网，那么局域网到底是什么呢？</p><p>如何将一个数据发送到另一台主机呢？</p><p>操作系统是如何知道网卡中有数据发来呢？</p><p>请接下这篇博客<a id="more"></a></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="局域网与公网"><a href="#局域网与公网" class="headerlink" title="局域网与公网"></a>局域网与公网</h3><ul><li><p>局域网概念—LAN</p><p>局域网指在某一区域内由多台计算机互联成的计算机组，应用在局部范围内，例如我们家里或者学校使用的无线网</p></li></ul><p>我们使用的WIFI也叫WLAN，即无线局域网。</p><p>在同一局域网内，两台主机可以直接通信</p><ul><li><p>广域网—WAN</p><p>广域网是连接不同地区局域网或城域网计算机通信的远程网，通常跨接很大的物理范围，例如我们使用的阿里云服务器</p></li></ul><p>公网接入方式：上网的计算机得到的IP地址是Internet上的非保留地址，公网的计算机和Internet上的其他计算机可随意互相访问。</p><p>任何一台在局域网上的主机，在不欠费的情况下，是可以访问公网上的服务器的</p><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>协议就像是一种约定，而网络协议也可以被理解为是在网络上的一种约定</p><ul><li>协议分层</li></ul><p>例如，两个人在打电话，这个通信过程可以将其分为两部分：通信工具和人。</p><p>当中国人和中国人打电话时，两人均使用汉语进行沟通，当其中一人使用电话进行通话时，两人依然可以正常沟通。再或者，其中一个中国人给一个英国人打电话时，两人还是可以用英语进行交流。</p><p>这也可以说明了分层的<strong>好处</strong>：其中一层发生改变整体不受影响，即分层可以更好的解耦</p><p>在分层这里要注意：同层之间才可以通信</p><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统和网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java中的类集</title>
      <link href="/2018/12/21/Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E9%9B%86/"/>
      <url>/2018/12/21/Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Java类集"><a href="#Java类集" class="headerlink" title="Java类集"></a>Java类集</h1><p>Java类集就是动态数组，类集的使用比较容易操作，但是类集的底层需要用到数据结构和多线程</p><p>所有的类集都在java.util包下<a id="more"></a></p><h3 id="Java类集的产生"><a href="#Java类集的产生" class="headerlink" title="Java类集的产生"></a>Java类集的产生</h3><p>Java类集是从JDK1.2开始应用的，用于解决数组定长问题</p><ul><li>Collection接口—<strong>单个对象</strong>保存的最顶层父接口</li></ul><p>Collection接口以及其子接口，在每次进行数据操作时只能对单个对象进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Iterable&lt;E&gt;</code>:迭代器接口（用于遍历集合）</p><p><code>Interface&lt;E&gt; iterator()</code>：取得集合的迭代器，JDK1.5之前没有泛型，则迭代器直接写在Collection接口中</p><ul><li>Collection接口中提供的核心方法</li></ul><p><strong>向类集中添加元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>取得接口的迭代器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Collection 接口只定义了存储数据的标准，但是无法区分存储类型。因此在实际中我们往往是由两个子接口List（允许数据重复）、Set（不允许数据重复）一般不直接使用Collection接口</p><h2 id="List接口—允许数据重复"><a href="#List接口—允许数据重复" class="headerlink" title="List接口—允许数据重复"></a>List接口—允许数据重复</h2><p>在进行单个集合处理时，优先考虑List接口</p><p>在List接口中，拓展了两个重要方法（List独有）</p><ul><li>根据索引取得下标数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>根据索引下标更改数据，返回原来的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br></pre></td></tr></table></figure><p>List接口有三个重要子类：ArrayList、Vector、LinkedList</p><p>List接口要想保存自定义类的对象，该类必须覆写<code>equals()</code>来使用<code>contains()</code>、<code>remove()</code></p><h3 id="ArrayList-Vector-LinkedList的区别"><a href="#ArrayList-Vector-LinkedList的区别" class="headerlink" title="ArrayList/Vector/LinkedList的区别"></a>ArrayList/Vector/LinkedList的区别</h3><ul><li>ArrayList与Vector的区别</li></ul><p>1、<strong>出现版本：</strong>ArrayList 在JDK1.2版本才出现，Vector在JDK1.0版本就已经出现</p><p>2、<strong>调用无参构造的区别：</strong>Vector在无参构造执行后将对象数组大小初始化为10，ArrayList采用懒加载策略，在构造方法阶段并不初始化数组，在第一次添加元素时才会初始化数组，大小为10</p><p>3、<strong>扩容策略：</strong>ArrayList在扩容时，会扩容到原来长度的1.5倍；Vector在扩容时，会扩容到原来的两倍</p><p>4、<strong>线程的安全性：</strong>ArrayList采用异步处理，线程不安全，效率较高；Vector采用在方法上加锁，线程安全，效率更低。（即便要使用线程安全的List也不使用Vector）</p><p>5、<strong>遍历：</strong>Vector支持较老的迭代器；ArrayList不支持</p><ul><li>ArrayList与Vector的共同点</li></ul><p>底层都使用数组实现，且都是List的子类</p><ul><li>ArrayList与LinkedList的区别</li></ul><p>LinkedList底层是双向链表，ArrayList的底层是数组</p><h2 id="Set接口—不允许数据重复"><a href="#Set接口—不允许数据重复" class="headerlink" title="Set接口—不允许数据重复"></a>Set接口—不允许数据重复</h2><p>Set接口没有扩充方法，常用子类有<code>HashSet</code>(无序存储)和<code>TreeSet</code>(有序存储)</p><p>Set接口本质上就是Map接口，Set就是value值都为PRESENT的Map</p><h3 id="Comparable接口与Comparator接口"><a href="#Comparable接口与Comparator接口" class="headerlink" title="Comparable接口与Comparator接口"></a>Comparable接口与Comparator接口</h3><ul><li>Comparable接口</li></ul><p>在Java中，若实现自定义类的比较，提供了一下两个接口：</p><p>java.lang.Comparable接口（内部比较器）:若一个类实现了Comparable接口，就表示该类可以进行比较并排序的。存放该类的Conllection或数组，可以直接通过<code>Collection.sort()</code>或Array.sort进行排序</p><p>实现了Comparable接口的类可以直接存放在TreeSet或TreeMap中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>返回值三种情况：</p><p>返回正数：当前对象大于目标对象</p><p>返回负数：当前对象小于目标对象</p><p>返回0：当前对象等于目标对象</p><ul><li>Comparator接口</li></ul><p>Comparator是外部排序接口</p><p>若要控制某个自定义类的顺序，而该类本身不支持排序—实现Comparator接口，覆写compareTo方法或实现一个比较器传入TreeSet或TreeMap中进行比较即可。</p><p>实现了Comparator接口的类作为比较器，通过该比较器来进行类排序，具有两个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1,T o2)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值与compareTo返回值完全一样</p><p>返回正数，o1&gt;o2</p><p>返回负数，o1&lt;o2</p><p>返回0，o1=o2</p><p>实现<code>Comparator</code>接口进行第三方排序—策略模式，此方法更加灵活，可以轻松改变策略进行第三方的排序方法</p><ul><li>Comparable接口与Comparator接口的关系</li></ul><p>Comparable是排序接口，若一个类实现了Comparable接口，意味着该类支持排序，是一个内部比较器（自己去和别人比）</p><p>Comparator接口是比较器接口，类本身不支持排序，专门有若干个第三方的比较器（实现了Comparator接口的类）来进行类排序，是一个外部比较器</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>底层是由哈希表和红黑树，允许存放null，无序储存</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>底层使用红黑树，不允许空值出现，允许储存</p><p>保存自定义类需实现Comparable接口或者传入比较器（compartor接口）</p><h3 id="HashSet和TreeSet的区别"><a href="#HashSet和TreeSet的区别" class="headerlink" title="HashSet和TreeSet的区别"></a>HashSet和TreeSet的区别</h3><p>1、<strong>底层实现不同：</strong>HashSet底层是由哈希表和红黑树，允许存放null，无序储存；TreeSet底层使用红黑树，不允许空值出现，允许储存</p><h3 id="重复元素比较"><a href="#重复元素比较" class="headerlink" title="重复元素比较"></a>重复元素比较</h3><p>TreeSet与TreeMap依靠Comparator或Comparable接口来区别重复元素</p><p>HashMap和HashSet不依赖比较接口，可以通过同时覆写其<code>equals()</code>和<code>HashCode()</code>方法来区分</p><p><strong>元素比较步骤：</strong></p><p>1、调用<code>hashCode()</code>计算出对象hash码决定存放的hash桶</p><p>2、使用<code>equals()</code>方法来判定两个元素内容是否相等，若相等，则不放置元素，若不相等，则在相同桶之后将元素链起来</p><p>object类内置的<code>hashCode()</code>是默认比较对象的地址转为hash码</p><p>两个对象<code>equals()</code>方法返回true，他们的hashCode必然保持相等，</p><p>两个对象的hashCode相等，不能保证他们的<code>equals()</code>一定相等，当且仅当hashCode和equals都返回true是，才说明两个对象都相等</p><ul><li>覆写<code>equals()</code>方法原则</li></ul><blockquote><p>自反性：对于任何非空引用值x，<code>x.equals(x)</code>都返回true</p><p>对称性：对于任何非空的x,y,当且仅当<code>x.equals(y)</code>返回true，<code>y.equals(x)</code>返回true</p><p>传递性：对于任何非空的x,y,z,当<code>x.equals(y)</code>返回true，<code>y.equals(z)</code>返回true,才有<code>x.equals(z)</code>返回true</p><p>一致性：对于任何非空的x,y,若x与y中属性没有变，则多次调用<code>equals()</code>方法，都返回true或false</p><p>非空性：对于任何非空引用值x，<code>x.equlas(null)</code>，返回false</p></blockquote><h3 id="集合输出—迭代器Iterator输出"><a href="#集合输出—迭代器Iterator输出" class="headerlink" title="集合输出—迭代器Iterator输出"></a>集合输出—迭代器Iterator输出</h3><ul><li>迭代输出—Collection接口支持</li></ul><p><strong>Iterator的两个核心方法</strong></p><p>判断是否还有元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>取得下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>单向迭代输出</strong></p><p>调用Collection集合子类的Iterator方法取得内置的迭代器，使用一下输出格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双向迭代输出</strong>–ListIterator</p><p>除了<code>hasNext</code>与<code>next</code>方法外还有：</p><p>判断是否有上一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasPrevious();</span><br></pre></td></tr></table></figure><p>取得上一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">previous();</span><br></pre></td></tr></table></figure><p>要想从后向前遍历，首先至少要从前向后遍历一次才可使用</p><ul><li>Enumeration枚举输出—Vector类支持</li></ul><p>判断是否有下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasMoreElements();</span><br></pre></td></tr></table></figure><p>取得下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextElement();</span><br></pre></td></tr></table></figure><ul><li>for-each输出</li></ul><p>能使用for-each的本质是各个集合类都内置了迭代器</p><ul><li>fail-fast机制</li></ul><p>ConcurrentModificationException发生在Collection集合使用迭代器遍历时，使用了集合类提供的修改集合内容方法报错。而如果使用Iterator迭代器的<code>remove()</code>不会出现此类错误</p><p>Collection集合中的modCount表示当前集合修改的次数</p><p>exceptedModCount是迭代器中记录当前集合的修改次数</p><p>当取得集合迭代器时，调用<code>new Itr()</code>会执行expectedModCount = ModCount，换言之，迭代器就是当前集合的一个副本</p><p>快速失败策略保证了所有用户在进行迭代遍历集合时，拿到的数据一定是最新的数据（避免脏读产生）</p><ul><li>fail-safe</li></ul><p>不产生ConcurrentModificationException异常，juc包下的所有线程安全集合（CopyOnWriteArrayList）</p><p><strong>以后再迭代器遍历时，不要修改集合的内容</strong></p><h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><p>Map接口是Java中保存二元偶对象的最顶层接口</p><p>Map中key值唯一，即通过可以值就可以找到对应的value值</p><ul><li>核心方法</li></ul><p>向Map中添加数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key,V value)</span></span>;</span><br></pre></td></tr></table></figure><p>根据指定的key值取得相应的value值，若没有key值，返回null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>;</span><br></pre></td></tr></table></figure><p>将Map集合变为Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure><p>返回所有key值集合，key不能重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>返回所有value值，value可以重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Map接口常用子类：HashMap、TreeMap、Hashtable、ConcurrentHashMap</p><ul><li>类比HashMap与Hashtable</li></ul><p>1、<strong>key和value的取值：</strong>HashMap的key值和value值可以取null，而Hashtable中key和value均不能取value值</p><p>2、<strong>出现的版本不同：</strong>JDK1.2产生了HashMap，JDK1.0就产生了Hashtable</p><p>3、<strong>线程安全问题：</strong>HashMap采用异步处理，线程不安全但是效率高，Hashtable采用同步处理，线程安全，效率低</p><p>4、<strong>底层实现：</strong>HashMap的底层是用哈希表和红黑树实现的，Hashtable的底层是用哈希表实现的</p><h4 id="Map集合使用迭代器输出"><a href="#Map集合使用迭代器输出" class="headerlink" title="Map集合使用迭代器输出"></a>Map集合使用迭代器输出</h4><ul><li>将Map集合转为Set集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure><h4 id="Collection与Map的储存方式"><a href="#Collection与Map的储存方式" class="headerlink" title="Collection与Map的储存方式"></a>Collection与Map的储存方式</h4><p>两者都是以对象为单位进行储存的</p><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><ul><li>栈—先入后出</li></ul><p>函数栈桢，浏览器标签页的后退，安卓Activity的后腿，编辑器撤销</p><p><strong>面试题：自己实现一个html识别器</strong></p><ul><li>队列—先入先出</li></ul><p>消息队列：kafka，RobitMQ</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>Queue接口：</p><p>入队列：<code>add()</code></p><p>出队列：<code>poll()</code></p><p>返回队列头元素，不出队：<code>peek()</code></p><h3 id="属性文件操作—资源（Properties）文件操作"><a href="#属性文件操作—资源（Properties）文件操作" class="headerlink" title="属性文件操作—资源（Properties）文件操作"></a>属性文件操作—资源（Properties）文件操作</h3><p>Java中有一种特殊的文件是以<code>.properties</code>为后缀的文件，资源文件的内容都是K,V模式的，并且K和Value都是String类型</p><ul><li>设置属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">setProperty</span><span class="params">(String key,String Value)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>取得属性,若没有指定key值，返回null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>若没有指定key值，返回默认值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getProperty(String key,String defaultValue);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JDBC</title>
      <link href="/2018/12/20/JDBC/"/>
      <url>/2018/12/20/JDBC/</url>
      
        <content type="html"><![CDATA[<p>现在的应用系统大多都离不开数据库，而Java程序访问数据库的基本方式是通过JDBC。</p><p>Java Database Connectivity，Java数据库连接。</p><p>用于执行SQL语句的Java API</p><p>JDBC使用流程如下：</p><p><img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JDBC/%E6%8D%95%E8%8E%B7.PNG"></p><a id="more"></a><h3 id="JDBC的使用"><a href="#JDBC的使用" class="headerlink" title="JDBC的使用"></a>JDBC的使用</h3><ul><li>加载JDBC驱动程序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br></pre></td></tr></table></figure><ul><li>建立数据库连接</li></ul><p>代码格式：jdbc:{数据库的名称}://host:port/databaseName?param1=value&amp;param2=value2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/memo? user=root&amp;password=root&amp;useUnicode=true&amp;characterEncoding=UTF-8"</span>);</span><br></pre></td></tr></table></figure><ul><li>创建操作命令（statement）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement statement = connection.createStatement();</span><br></pre></td></tr></table></figure><ul><li>执行SQL语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">            ResultSet resultSet = statement.executeQuery(sql);</span><br></pre></td></tr></table></figure><ul><li>处理结果集</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">                String title = resultSet.getString(<span class="string">"ename"</span>);</span><br><span class="line">                System.out.println(id == resultSet.getInt(<span class="string">"empno"</span>));</span><br><span class="line">                System.out.println(String.format(<span class="string">"id = %d,title = %s"</span>, id, title));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ul><li>释放资源（关闭结果集，命令，连接）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭结果集</span></span><br><span class="line"><span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        resultSet.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; &#125; </span><br><span class="line"><span class="comment">//关闭命令</span></span><br><span class="line"><span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        statement.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; &#125;</span><br><span class="line"><span class="comment">//关闭连接命令</span></span><br><span class="line"><span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();    </span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="Statement对象"><a href="#Statement对象" class="headerlink" title="Statement对象"></a>Statement对象</h3><p>用于将SQL语句发送到数据库中，JDBC API中主要提供了三种Statement对象</p><ul><li>Statement</li></ul><p>用于执行不带参数的简单SQL语句</p><p>SQL语句通过拼接字符串来实现，该方式效率比较低，系统会自动将该字符串定义为StringBuilder，拼接时调用<code>append()</code>方法</p><ul><li>PreparedStatement</li></ul><p>用于执行带或者不带参数的SQL语句</p><p>SQL语句会预编译在数据库系统</p><p>执行速度快于Statement对象</p><ul><li>CallableStatement</li></ul><p>用于执行数据库存储过程的调用</p><p>实际开发中最常用的是PreparedStatement，其具有以下优点：</p><blockquote><p>1、性能比Statement高（拼接字符串效率较低）</p><p>2、参数化SQL查询</p><p>3、占位符不能使用多值，占位符下标从1开始</p><p>4、SQL预编译</p><p>5、阻止常用SQL注入攻击</p></blockquote><p><strong>SQL两种执行方法：</strong></p><p>方法执行后返回单个结果集的，通常用于select语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executeQuery()</span><br></pre></td></tr></table></figure><p>方法返回值是一个整数，指示受影响的行数，通常用于update、insert、delete</p><h3 id="ResultSet对象"><a href="#ResultSet对象" class="headerlink" title="ResultSet对象"></a>ResultSet对象</h3><p>ResultSet对象被称为结果集，表示符合SQL语句执行结果的所有行，并且提供了一套<code>getXXX()</code>方法提供了对这些行中数据的访问。ResultSet就像一个迭代器，其所指的数据行叫做当前数据行。</p><p>取得某一条记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet.next()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>STL的底层与应用</title>
      <link href="/2018/08/28/STL%E7%9A%84%E5%BA%95%E5%B1%82%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2018/08/28/STL%E7%9A%84%E5%BA%95%E5%B1%82%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>STL是惠普实现的，其有多个版本，但都是在HP版本的基础上完成的</p><p>STL是C++的标准模板库，包括数据结构和算法的软件框架<a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>STL将常用的数据结构封装起来，在封装过程中使用了算法，使用方便</p><p>其具有通用、高效的特点 </p><h3 id="STL的六大组件"><a href="#STL的六大组件" class="headerlink" title="STL的六大组件"></a>STL的六大组件</h3><p>容器、适配器、迭代器、空间配置器、仿函数、算法</p><p>接下来我会从组件功能、组件实例和实例的底层实现等方面来对各组件进行讲解</p><h3 id="容器-vector、slist、array、deque等"><a href="#容器-vector、slist、array、deque等" class="headerlink" title="容器(vector、slist、array、deque等)"></a>容器(vector、slist、array、deque等)</h3><p>容器中数据的区间都是左闭右开的</p><p>容器分两种：线性和特殊线性结构</p><p>线性结构有：array、vector、slist、deque、string等</p><font color="red" size="3">vector</font><p>vector的底层是动态顺序表，底层结构：</p><div align="center"><br>    <img src="/images/posts/STL/vector.png" height="300" width="500"><br></div><p>由于vector是一段连续的空间，其迭代器被设计成一个原生态指针</p><p>在使用vector时要注意：包含其头文件<vector>并引入标准命名空间std</vector></p><p>其具体功能如下：</p><div align="center"><br>    <img src="/images/posts/STL/vector功能.png" height="500" width="500"><br></div><font color="red" size="3">list</font><p>list的底层是一个带头结点的双向单链表，底层结构：</p><div align="center"><br>    <img src="/images/posts/STL/单链表底层.png" height="300" width="500"><br></div><p>当集合需要大量的插入和删除时，考虑用list</p><p>list的迭代器需要其实现者自己提供</p><p>其具体功能如下：</p><div align="center"><br>    <img src="/images/posts/STL/list功能.png" height="500" width="500"><br></div><font color="red" size="3">deque</font><p>deque是一段假想的连续空间，是一个双端序列，可以实现动态的二维数组</p><p>deque的两端都可以进行插入和删除，其结构如下：</p><div align="center"><br>    <img src="/images/posts/STL/deque.png" height="400" width="600"><br></div><p>deque是分段连续空间，维护其连续的假象的是迭代器</p><p>若迭代器中的cur到了last的位置，即表示已到当前队列的边缘</p><p>在deque的底层，有中控器(map)记录每个队列的迭代器地址(node)，迭代器中有队列的初始位置(first)、末尾位置(last)以及当前指向位置(pur)</p><p>若创建的队列过多，中控器空间不足，则扩容中控器，新的中控器从中间开始存储迭代器(node)的地址</p><p>则deque底层实现如下：</p><div align="center"><br>    <img src="/images/posts/STL/deque底层实现.png" height="300" width="500"><br></div><p>deque的操作如下：</p><div align="center"><br>    <img src="/images/posts/STL/deque功能.png" height="300" width="500"><br></div><p>array的底层实现是静态顺序表</p><p>string也是静态顺序表，他是用来存放字符串的，而array是用来存放各种数据的</p><p>slist是带头结点的单链表</p><p>这些就不做详细讲解了</p><h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><p>仿函数是一个函数对象，即将一个类像函数一样使用</p><pre><code>class people{   public:      返回值类型 operator()(参数列表);   成员变量}；</code></pre><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>适配器是设计模式的一种，该模式的作用是将一个类的接口转换成用户希望的另一个接口</p><p>STL中适配器有三种：应用于容器的适配器、应用于迭代器的适配器、应用于仿函数的适配器</p><h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h4><p>stack和queue都是一种特殊的线性数据结构，其只能在固定端插入和删除</p><p>stack无法遍历，无begin(),end()</p><p>由于deque是双开口序列，则将其稍作改装就可以实现stack和queue</p><p>在使用priority_queue时，用户可以以任意次序将数据放进去，但是取出时，会以优先级高低取出</p><p>其以vector为底层结构，加上堆算法重新封装</p><h4 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h4><p>关联式容器是用键值对(&lt;key,value&gt;)来实现的</p><font color="red" size="3">键值对</font><p>键值对实际是一个结构体，该结构体具有两个字段，两个字段有着一一对应的关系</p><p>在其应用时</p><pre><code>pair&lt;key,value&gt;(key,value);make_pair(key,value);</code></pre><p>这两种形式都可以创建键值对，第一种是对模板类的实例化，第二种返回键值对</p><h5 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h5><p>序列式容器在查找数据时，时间复杂度为O(n)</p><p>而关联式容器map/multimap底层是由红黑树构成的</p><p>这就使得其在查找数据时时间复杂度变成了O(1)，提高了查找效率</p><font color="red" size="3">数据存储方式：</font><p>由于其底层是由红黑树构成的，则在插入变量时，会与key进行比较，则对红黑树进行中序遍历，会得到一个有序序列</p><h4 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h4><p>其底层实现也是红黑树</p><p>其与map的相同之处在于：底层结构都是红黑树</p><p>不同之处是：map中存放的是一个真正的键值对，而set中key与value相同</p><p>map与multimap,set与multiset之间的区别是map/set不可以存储重复的变量，可以去重，而multimap/multiset可以存放相同变量，只是单纯的排序</p><h4 id="unordered-map-unordered-multimap-unordered-set-unordered-multiset"><a href="#unordered-map-unordered-multimap-unordered-set-unordered-multiset" class="headerlink" title="unordered_map/unordered_multimap  unordered_set/unordered_multiset"></a>unordered_map/unordered_multimap  unordered_set/unordered_multiset</h4><p>unordered_map/unordered_multimap放置的内容是一个正常的键值对</p><p>而unordered_set/unordered_multiset放置的内容是key与value相同的键值对</p><p>其底层是由哈希桶实现的，则其的数据存放方式是无序的</p><font color="blue" size="3">map与unordered_map的区别：</font><blockquote><p>1.底层：map的底层是红黑树，unordered_map的底层是哈希桶</p></blockquote><blockquote><p>2.查找方式：map的查找效率高，为O(log2n)，而unordered_map的查找效率为O(n)</p></blockquote><blockquote><p>3.map是有序存放的，而unordered_map是无序放的</p></blockquote><blockquote><p>4.两者的应用场景不同</p></blockquote><blockquote><p>5.迭代器方式不同：map可以正向和反向遍历，而unordered_map只可以正向遍历</p></blockquote><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法有两种：与数据结构有关的算法(绑定在容器上的算法)和与数据结构无关的算法(通用算法)</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是一种设计模式，其实际上是一种行为类似于指针的对象，因此指针的功能迭代器都有</p><p>迭代器的实现只要在类中将指针的功能重载即可</p><p>迭代器的提供者就是容器的实现者</p><h3 id="空间管理"><a href="#空间管理" class="headerlink" title="空间管理"></a>空间管理</h3><h4 id="普通存放数据的原理"><a href="#普通存放数据的原理" class="headerlink" title="普通存放数据的原理"></a>普通存放数据的原理</h4><p>需要空间–&gt;new/new[]–&gt;申请空间、构造对象</p><p>new是将malloc重新封装的，使用一次malloc，在内存中除了会开辟所需空间外，还会额外开辟36个字节</p><p>结构如下图：</p><div align="center"><br>    <img src="/images/posts/STL/malloc.png" height="300" width="500"><br></div><p>通过这种形式管理空间可以防止越界访问</p><h4 id="普通方式存放数据的缺陷"><a href="#普通方式存放数据的缺陷" class="headerlink" title="普通方式存放数据的缺陷"></a>普通方式存放数据的缺陷</h4><blockquote><p>1.频繁的向系统索要小的内存块，会产生内存碎片</p></blockquote><blockquote><p>2.频繁的向系统索要小的内存块，产生额外开销，效率低</p></blockquote><blockquote><p>3.没有及时的释放空间，造成内存泄漏</p></blockquote><blockquote><p>4.空间不足时，无法获取空间</p></blockquote><h4 id="标准空间配置器"><a href="#标准空间配置器" class="headerlink" title="标准空间配置器"></a>标准空间配置器</h4><p>标准空间配置器只是将new,delete进行简单的封装，与我们平常使用的new和delete没太大区别</p><h4 id="重新设计空间配置器"><a href="#重新设计空间配置器" class="headerlink" title="重新设计空间配置器"></a>重新设计空间配置器</h4><p>重新设计空间配置器有一级空间配置器和二级空间配置器两种</p><p>重新设计空间配置器会根据用户索要空间的大小来选择空间配置器</p><font color="blue" size="3">一级空间配置器</font><p>当用户索要空间大于128个字节时，会使用一级空间配置器</p><p>一级空间配置器将malloc和free进行简单的封装</p><pre><code>void* allocate(字节数):malloc若空间充足，开辟空间成功，直接返回若空间不充足，开辟空间失败，启动空间不足应对措施(函数指针)allocate_OOM (字节数){   检测空间不足应对措施是否设置   是：malloc  //重新开辟空间   否:throw bad_alloc  //抛异常}//将空间归还系统void deallocate(void* p,size_t size){   free(p);}</code></pre><font color="blue" size="3">二级空间配置器</font><p>当用户索取空间小于128个字节时，会使用二级空间配置器</p><p>为了减少多次开辟空间造成的额外消耗，二级空间配置器会开辟一个很大空间作为内存池</p><p>同时会构造一个哈希表，其中会有128/8=16个结点，每个结点下面会挂(n+1)*8字节的内存块，构成哈希桶，以此来管理小的内存块</p><p>结构如下：</p><div align="center"><br>    <img src="/images/posts/STL/空间配置器.png" height="300" width="500"><br></div><p>空间管理如下：</p><pre><code>void* allocate(size_t size){   if(size&gt;128)       一级空间配置器   else   {       1.找size对应的哈希桶       2.检测该哈希桶有没有结点        有：将第一块内存给用户        没有：refill(size向上取整到8的整数倍，向当前链表中补充空间)   }}void* refill(size_t size){   1.通过chunk_alloc(objs,size)索要nobjs(20)个size个字节的内存块   2.nobjs = 1---&gt;返回----&gt;将一块内存返回给用户     20 &gt;= objs &gt; 1 ---&gt;将剩余的内存块挂在链表中}void* chunk_alloc(size_t&amp; nobjs,size_t size){   从内存池中索要空间     &gt;1.计算总共需要的字节数  totalBytes = nobjs*size     &gt;2.计算内存池中剩余的字节数  leftBytes =_endFree-_startFree;   if(leftByte&gt;=totalBytes)   {       提供20个内存块   }   else if (leftBytes&gt;=size)   {       nobjs=leftBytes/size;   }   else   {       0.把内存池剩余的元素处理掉(挂到对应的哈希桶中)       1.向系统索要空间补充内存池---&gt;成功---&gt;_startFree接受malloc的返回值---&gt;递归chunk_alloc()       2.如果1失败，从当前链表往后去找是否还有更大的内存块---&gt;找到了---&gt;补充到内存池---&gt;递归chunk_alloc()       3.使用一级空间配置器(内存不足应对措施)---&gt;递归chunk_alloc()   }}</code></pre><p>这种处理内存碎片的方式虽然解决了外部存在大量的内存碎片的问题，但是还是会有在哈希桶上挂的小碎片<br>​<br>可能有的地方叙述的不是很清楚，欢迎交流~</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python基本语句</title>
      <link href="/2018/08/04/Python%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5/"/>
      <url>/2018/08/04/Python%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>在了解了一下Python入门知识之后，接下来来学习一下Python的一些基础语法吧~</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="语句折行"><a href="#语句折行" class="headerlink" title="语句折行"></a>语句折行</h3><p>在编写代码时，我们会遇到语句过长的情况，这时我们要注意，代码一定要怎么简洁怎么写 </p><p> a.若该语句被小括号、中括号或大括号包起来，可直接换行书写</p><p> b.若没有括号，则需使用\来换行</p><p> c.双引号和单引号字符串都不可换行，但三引号字符串可以直接换行</p><p> d.可以把多个语句写在一行，但是最好不要这样做</p><h3 id="变量交换"><a href="#变量交换" class="headerlink" title="变量交换"></a>变量交换</h3><p>在C/C++中，若要交换两个变量的内容，需要借助一个中间变量</p><p>而在python中，可以直接进行交换</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=1</span><br><span class="line"></span><br><span class="line">y=2</span><br><span class="line"></span><br><span class="line">x,y=y,x</span><br></pre></td></tr></table></figure><p>即可交换两个变量，是不是很方便呢？</p><p>bool类型中的true和false的值也可以交换，那么真就是假，假就是真了，但不建议交换<br>​     </p><h3 id="作用域和生命周期"><a href="#作用域和生命周期" class="headerlink" title="作用域和生命周期"></a>作用域和生命周期</h3><p>在python中，def、class、lamda会改变变量作用域</p><p>用 globals() 查看当前环境内的全局变量</p><p>用 locals() 查看当前代码块的局部变量</p><h3 id="方法私有化"><a href="#方法私有化" class="headerlink" title="方法私有化"></a>方法私有化</h3><p>在python中，在方法名前加下划线表示私有化</p><p>但这只是程序员约定俗成的一种方式，并不是真正意义上的私有化</p><p>因此在python中没有真正的私有化</p><h3 id="我们在定义方法时需要注意："><a href="#我们在定义方法时需要注意：" class="headerlink" title="我们在定义方法时需要注意："></a>我们在定义方法时需要注意：</h3><p>a.方法名前加下划线表示私有，无法使用from 模块名 improt *导入</p><p>b.方法名前后各加一个下划线表示系统变量</p><p>c.方法名前后各加两个下划线表示系统变量</p><h3 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h3><p>#可以用来注释一行内容</p><p>如果我们需要注释多行内容，可以在类或函数之前加上’’’注释内容’’’来表示，这被成为文档字符串</p><font color="blue" size="3">doc属性：</font><p>每个对象都有doc属性，用 函数名.<strong>doc</strong> 即可看到使用’’’  ‘’’标注的帮助文档的内容</p><p>使用 help() 也有该作用</p><p>不只是函数或类可以添加帮助文档，模块也可以</p><font color="red" size="3">注意：</font>自己添加的帮助文档，必须放在函数或类的前面，否则无法访问<br><br>### None<br><br>在python中有一种特殊的对象，叫做None，类型为NoneType<br><br>### 对象比较<br><br>对象之间进行比较有三种：对象值的比较、对象身份的比较和对象类型的比较<br><br><font color="blue" size="3">对象值的比较</font><p>所有内建对象都可以用比较操作符进行比较，比较对象的类型必须是相同的</p><p>比较运算符的结果是true和false</p><p>比较运算符有==、!=、&lt;=、&gt;=、&lt;、&gt;</p><font color="blue" size="3">对象身份的比较</font><p>变量名只是对象的一个引用，那么多个变量名就可以引用同一个对象</p><p>可以通过 id() 获得变量引用的对象的id，同时也就可以对多个对象的身份进行比较</p><p>若得到的id值相同，则说明两个变量指向同一个对象</p><p>python还提供了 is、is not 两个关键字，用于比较两个变量名是否指向同一个对象</p><font color="blue" size="3">对象类型的比较</font><p>对于比较两个变量的类型是否相同，可以使用内建函数 type()</p><p>当然啦~类型比较也有比较两个变量的内建函数—isinstance()</p><h3 id="整数的位运算"><a href="#整数的位运算" class="headerlink" title="整数的位运算"></a>整数的位运算</h3><p>整数的位运算有&lt;&lt;、&gt;&gt;、&amp;、^、~</p><p>这些运算符看起来比较陌生的应该是~</p><p>~的功能是按位取反</p><h3 id="内置函数与内置模块"><a href="#内置函数与内置模块" class="headerlink" title="内置函数与内置模块"></a>内置函数与内置模块</h3><font color="blue" size="3">内置函数</font><p>只是一些基本内置函数的功能介绍</p><p> a.abs:求一个整型的绝对值</p><p> b.divmod：同时计算一个表达式的商和余数，返回值是一个元组</p><p> c.str：将数字转换成字符串</p><p> d.round：对浮点数进行四舍五入，共有两个参数，操作数和要保留的小数点后的位数</p><font color="blue" size="3">内置模块</font><p>内置模块主要介绍三种：</p><p> a.整型进制转换：oct()、hex()，参数为整型，返回值是对应字面值得字符串，将十进制转换成八进制和十六进制</p><p> b.math、cmath模块：提供一些方便的数学运算函数，math是常规数学，cmath是复数数学</p><p> c.随机数random模块：参数有两个，确定生成数的范围</p><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>在python中，没有 ：？这样的三目表达式</p><p>取而代之的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b if a &lt; b else a</span><br></pre></td></tr></table></figure><p>该语句的功能是：判断a是否小于b，若a小于b，则将b指向a的对象，否则a不变</p><h3 id="和循环搭配使用的else"><a href="#和循环搭配使用的else" class="headerlink" title="和循环搭配使用的else"></a>和循环搭配使用的else</h3><p>else不止可以和if一起使用，还可以和for循环、while循环搭配使用</p><p>在与循环搭配时，else语句的功能是：在循环条件不满足时会执行else语句，若break跳出循环，则不执行else的内容</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p> a.函数的参数列表不需要写参数类型</p><p> b.函数1中还可以定义函数2，但函数2的作用域只是函数2中</p><p> c.定义函数时，可以给函数指定默认参数，在调用函数时，若不显式的指定参数，就会使用默认参数</p><p> d.对于多个默认参数的函数，可以按照顺序给函数的某几个参数进行传参</p><p>对于d，若只是给指定位置的参数传参我们又该怎么解决呢？</p><font color="blue" size="3">关键字传参</font><p>对于几个默认参数传参，我们可以通过指定关键字来说明给哪个参数传参</p><font color="blue" size="3">参数组</font><p>若将元组或字典当做参数，就可以实现“可变长参数”</p><p>在参数名前加一个*，之后的内容是一个元组</p><p>在参数名前加两个*,之后的内容表示一个字典</p><p>欢迎交流~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python基础小知识</title>
      <link href="/2018/08/01/Python%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/08/01/Python%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>最近开始学习Python，以前只是听说过Python是一种脚本语言，没有进行过多的了解 </p><p>Python拥有强大的类库，支持面向过程、面向对象、函数式编程多种编程风格</p><p>通过今天的学习了解到，Python是一种脚本解释语言，像C、C++都属于编译语言</p><p>我们都了解，C/C++在编译过程中，会生成中间产物—.obj文件等，而Python不会</p><p>Python程序的执行时读一行执行一行，所以程序执行的比较慢</p><p>这也就使得Python不可以做开发底层、移动端开发和游戏</p><p>Python的脚本文件是.py，为了提高其执行效率，执行过的程序会生成.pyc文件</p><p>在执行程序时，若检测到有.pyc文件，会优先选择.pyc文件执行<a id="more"></a></p><h3 id="编程须知"><a href="#编程须知" class="headerlink" title="编程须知"></a>编程须知</h3><p>一般写程序，用Linux系统自带的编辑器</p><p>输入命令 Python 即可知道当前系统下Python的版本，这也就进入了Python的解释器</p><p>我们可以把解释器当做是一个基本的计算器，其也可以执行符合Python语法的语句</p><pre><code>例如：输入：1+2输出：3输入：print &apos;hello world&apos;输出：hello world</code></pre><p>按ctrl+d，即可退出解释器</p><p>wim test.py  创建test.py文件，进行编辑</p><p>编辑完成后，按Esc切换到命令模式，然后输入  :wq   回车就自动保存完成了</p><p>输入命令 python test.py 执行代码</p><font color="blue" size="3">两条重要指令</font><pre><code>#!/usr/bin/python有了这条指令，若要执行.py文件，就可以使用 ./test.py 命令#coding:utf-8该指令是一条声明指令，使得文件中可以编辑汉字</code></pre><p>在C/C++中，注释有2种形式：// 和 /**/</p><p>Python中的注释方法是在语句前加一个#</p><h3 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h3><p>根据对变量的赋值确定变量类型，若改变类型，需要强转</p><p>因此在定义变量时，不需要写变量类型</p><h3 id="赋值方式"><a href="#赋值方式" class="headerlink" title="赋值方式"></a>赋值方式</h3><p>赋值方式有三种：</p><p>a.链式赋值：</p><pre><code>a=b=c=1</code></pre><p>b.增量赋值</p><pre><code>a=20*b</code></pre><p>c.多元赋值</p><pre><code>x,y=1,2</code></pre><p>若同一变量多次赋值，以最后一次赋值为准</p><h3 id="变量名规范"><a href="#变量名规范" class="headerlink" title="变量名规范"></a>变量名规范</h3><p>变量名规范和C/C++相同，变量名首字可以是字母下划线不可以是数字</p><p>由多个单词组成的变量名，比较美观的命名形式：</p><p>a.两个单词之间用下划线相连   person_name</p><p>b.小驼峰—除第一个单词，其他单词首字母用大写形式   personName</p><p>c.大驼峰—每个单词的首字母用大写形式   PersonName</p><h3 id="打印变量类型"><a href="#打印变量类型" class="headerlink" title="打印变量类型"></a>打印变量类型</h3><p>type(变量名)</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Python中有整型、浮点型和字符串类型，没有字符类型。</p><p>Python中对数字大小没有限制，内存有多大，数字就可以有多大</p><p>还多了一种复数类型  比如打印一个复数： print 10+2j</p><font color="blue" size="3">字符串：</font><p>声明字符串可以用，‘’、””、”‘’”</p><p>打印一个含有引号的字符串，在C/C++中，需要使用到转义字符，而在Python中不需要</p><p>字符串的操作：</p><p>a.+代表字符串拼接</p><pre><code>print &quot;abc&quot;+&quot;def&quot;运行结果：abcdef</code></pre><p>b.*代表字符串重复</p><pre><code>print &quot;abc&quot;*3运行结果：abcabcabc</code></pre><font color="blue" size="3">下标取值法</font><p>取指定位置的元素，即一个字符串的单独元素</p><p>字符串无法改变一个位置的变量，只能重新定义一个字符串</p><p>在Python中没有字符类型，只有字符串类型</p><font color="blue" size="3">切片操作法</font><p>用str[:]==&gt;构成前闭后开区间</p><p>默认从0开始，在字符串长度结束</p><p>填写负数时，代表len-n</p><p>字符串格式化：</p><p>举个栗子：</p><pre><code>str2=&quot;num is %d&quot; % 10运行结果：num is 10</code></pre><p>%d代表要初始化的类型以及标注了初始化的位置</p><p>把要输出的内容和初始化的数值用%隔开<br>​     </p><h3 id="len"><a href="#len" class="headerlink" title="len()"></a>len()</h3><p>判断字符串长度</p><h3 id="布尔类型-bool"><a href="#布尔类型-bool" class="headerlink" title="布尔类型(bool)"></a>布尔类型(bool)</h3><p>这和我们接触到的c++里的相同，true代表真的，在运行时被当做1，false代表假的，在运行时被当做0</p><h3 id="获取用户输入的函数"><a href="#获取用户输入的函数" class="headerlink" title="获取用户输入的函数"></a>获取用户输入的函数</h3><p>获取用户输入的函数名raw_input()，返回值为str类型</p><p>例如：</p><pre><code>str1=raw_input(&quot;请输入：&quot;)</code></pre><p>当该语句运行时，屏幕会打印括号里的字符串，并等待用户输入</p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>在我们之前学过的+、-、*、/、%的基础上，没有++和–</p><p>**代表乘方：</p><pre><code>print 2**3</code></pre><p>运行结果为：8</p><p>除法有三种：</p><p>a.传统除法   即2/1</p><p>b.精确除法</p><p>输入from <strong>future</strong> import division指令</p><p>此后所有的除法都按照精确除法求值</p><p>c.地板除(//)   即将结果向下取整</p><p>例如：</p><pre><code>a=1b=2print 1//2</code></pre><p>运行结果为：0</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>有&gt;、&lt;、&gt;=、&lt;=、==、!=</p><p>与之前我们接触过的比较运算符不同的是</p><p>与或非：与是and  或是or  非是not</p><h3 id="列表、元组、字典"><a href="#列表、元组、字典" class="headerlink" title="列表、元组、字典"></a>列表、元组、字典</h3><font color="blue" size="3">列表</font><br>list[]<br><br>列表可以下标取值、对象可变、可切片操作，为前闭后开区间<br><br>定义一个列表：list=[1,0.5,”123”,[1,2]]<br><br>从这个列表中，我们可以知道，列表中放的数据可以是不同类型的<br><br>使用 type(list)  可以得到其类型 list<br><br><font color="blue" size="3">元组</font><br>tuple()<br><br>元组对象不可变，可下标访问<br><br>定义方式为：tuple=(1,2,3,4)<br><br><font color="blue" size="3">字典</font><br>dict{}<br><br>字典是以键值对的方式保存数据，可改变对象<br><br>可以通过key得到或赋值value<br><br>若赋值一个新的key，会自动添加新的键值对<br><br>### 引用<br><br>定义几个变量为相同值，可以<br><br>     a=b=c=1<br><br>这在C/C++中也是可以这样赋值，但会开辟三个空间存放数字1<br><br>而在Python中，对象有三要素：id、type、value<br><br>id是一个对象的唯一标识符，type是对象的类型，value是对象的值<br><br>所以在Python中，该语句执行后，a、b、c三个变量会引用这同一个对象，即在同一对象贴上标签<br><br>可通过 id(对象) 来判断其唯一标识符<br><br>### 代码块及缩进<br><br>在C/C++中，我们是以{}来划分代码块的，在Python中我们是以缩进相同来区分代码<br><br>例如：<br><br>     if 1&lt;2:<br><br>         print ‘yes’<br><br>     print ‘no’<br><br>由此我们可知print ‘yes’与if 1&lt;2：是一个代码块<br><br>### range(start,stop,step)<br><br>该函数的功能是：从start到stop间隔是step构成的前闭后开的区间，start的默认值为0，step默认为1<br><br>### 语句折行<br><br>在编写代码时，我们会遇到语句过长的情况，这时我们要注意，代码一定要怎么简洁怎么写<br><br> a.若该语句被小括号、中括号或大括号包起来，可直接换行书写<br><br> b.若没有括号，则需使用\来换行<br><br> c.双引号和单引号字符串都不可换行，但三引号字符串可以直接换行<br><br> d.可以把多个语句写在一行，但是最好不要这样做<br><br>### 变量交换<br><br>在C/C++中，若要交换两个变量的内容，需要借助一个中间变量<br><br>而在python中，可以直接进行交换<br><br>例如：<br><br>     x=1<br><br>     y=2<br><br>     x,y=y,x<br><br>即可交换两个变量，是不是很方便呢？<br><br>bool类型中的true和false的值也可以交换，那么真就是假，假就是真了，但不建议交换<br>​<br>### 作用域和生命周期<br><br>在python中，def、class、lamda会改变变量作用域<br><br>用 globals() 查看当前环境内的全局变量<br><br>用 locals() 查看当前代码块的局部变量<br><br>### 方法私有化<br><br>在python中，在方法名前加下划线表示私有化<br><br>但这只是程序员约定俗成的一种方式，并不是真正意义上的私有化<br><br>因此在python中没有真正的私有化<br><br>### 我们在定义方法时需要注意：<br><br>a.方法名前加下划线表示私有，无法使用from 模块名 improt *导入<br><br>b.方法名前后各加一个下划线表示系统变量<br><br>c.方法名前后各加两个下划线表示系统变量<br><br>### 文档字符串<br><br>#可以用来注释一行内容<br><br>如果我们需要注释多行内容，可以在类或函数之前加上’’’注释内容’’’来表示，这被成为文档字符串<br><br><font color="blue" size="3">doc属性：</font><p>每个对象都有doc属性，用 函数名.<strong>doc</strong> 即可看到使用’’’  ‘’’标注的帮助文档的内容</p><p>使用 help() 也有该作用</p><p>不只是函数或类可以添加帮助文档，模块也可以</p><font color="red" size="3">注意：</font>自己添加的帮助文档，必须放在函数或类的前面，否则无法访问<br><br>### None<br><br>在python中有一种特殊的对象，叫做None，类型为NoneType<br><br>### 对象比较<br><br>对象之间进行比较有三种：对象值的比较、对象身份的比较和对象类型的比较<br><br><font color="blue" size="3">对象值的比较</font><p>所有内建对象都可以用比较操作符进行比较，比较对象的类型必须是相同的</p><p>比较运算符的结果是true和false</p><p>比较运算符有==、!=、&lt;=、&gt;=、&lt;、&gt;</p><font color="blue" size="3">对象身份的比较</font><p>变量名只是对象的一个引用，那么多个变量名就可以引用同一个对象</p><p>可以通过 id() 获得变量引用的对象的id，同时也就可以对多个对象的身份进行比较</p><p>若得到的id值相同，则说明两个变量指向同一个对象</p><p>python还提供了 is、is not 两个关键字，用于比较两个变量名是否指向同一个对象</p><font color="blue" size="3">对象类型的比较</font><p>对于比较两个变量的类型是否相同，可以使用内建函数 type()</p><p>当然啦~类型比较也有比较两个变量的内建函数—isinstance()</p><h3 id="整数的位运算"><a href="#整数的位运算" class="headerlink" title="整数的位运算"></a>整数的位运算</h3><p>整数的位运算有&lt;&lt;、&gt;&gt;、&amp;、^、~</p><p>这些运算符看起来比较陌生的应该是~</p><p>~的功能是按位取反</p><h3 id="内置函数与内置模块"><a href="#内置函数与内置模块" class="headerlink" title="内置函数与内置模块"></a>内置函数与内置模块</h3><font color="blue" size="3">内置函数</font><p>只是一些基本内置函数的功能介绍</p><p> a.abs:求一个整型的绝对值</p><p> b.divmod：同时计算一个表达式的商和余数，返回值是一个元组</p><p> c.str：将数字转换成字符串</p><p> d.round：对浮点数进行四舍五入，共有两个参数，操作数和要保留的小数点后的位数</p><font color="blue" size="3">内置模块</font><p>内置模块主要介绍三种：</p><p> a.整型进制转换：oct()、hex()，参数为整型，返回值是对应字面值得字符串，将十进制转换成八进制和十六进制</p><p> b.math、cmath模块：提供一些方便的数学运算函数，math是常规数学，cmath是复数数学</p><p> c.随机数random模块：参数有两个，确定生成数的范围</p><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>在python中，没有 ：？这样的三目表达式</p><p>取而代之的是</p><pre><code>a = b if a &lt; b else a</code></pre><p>该语句的功能是：判断a是否小于b，若a小于b，则将b指向a的对象，否则a不变</p><h3 id="和循环搭配使用的else"><a href="#和循环搭配使用的else" class="headerlink" title="和循环搭配使用的else"></a>和循环搭配使用的else</h3><p>else不止可以和if一起使用，还可以和for循环、while循环搭配使用</p><p>在与循环搭配时，else语句的功能是：在循环条件不满足时会执行else语句，若break跳出循环，则不执行else的内容</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p> a.函数的参数列表不需要写参数类型</p><p> b.函数1中还可以定义函数2，但函数2的作用域只是函数2中</p><p> c.定义函数时，可以给函数指定默认参数，在调用函数时，若不显式的指定参数，就会使用默认参数</p><p> d.对于多个默认参数的函数，可以按照顺序给函数的某几个参数进行传参</p><p>对于d，若只是给指定位置的参数传参我们又该怎么解决呢？</p><font color="blue" size="3">关键字传参</font><p>对于几个默认参数传参，我们可以通过指定关键字来说明给哪个参数传参</p><font color="blue" size="3">参数组</font><p>若将元组或字典当做参数，就可以实现“可变长参数”</p><p>在参数名前加一个*，之后的内容是一个元组</p><p>在参数名前加两个*,之后的内容表示一个字典</p><p>欢迎交流~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>禅道的安装</title>
      <link href="/2018/07/26/%E7%A6%85%E9%81%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2018/07/26/%E7%A6%85%E9%81%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>测试工具有很多，接下来我将介绍几款比较经典的测试工具<a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先来了解一下测试工具的功能吧~</p><h3 id="测试工具的基本功能"><a href="#测试工具的基本功能" class="headerlink" title="测试工具的基本功能"></a>测试工具的基本功能</h3><blockquote><p>1.测试需求管理</p></blockquote><blockquote><p>2.测试用例管理 </p></blockquote><blockquote><p>3.测试过程管理</p></blockquote><blockquote><p>4.缺陷管理</p></blockquote><blockquote><p>5.报表统计</p></blockquote><blockquote><p>6.权限管理</p></blockquote><h3 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h3><font color="blue" size="3">QC</font><p>具有指定测试需求、测试计划，执行测试和跟踪缺陷的功能</p><font color="blue" size="3">CQ</font><p>配置管理工作中的变更管理工具，用于任务分配、Bug跟踪、变更管理、流程制定</p><font color="blue" size="3">JIRA</font><p>项目与事物跟踪工具，用于缺陷跟踪、客户服务、需求收集、流程审批、任务跟踪、项目跟踪和敏捷管理</p><font color="blue" size="3">Test Link</font><p>测试用例管理，用于管理测试用例和测试过程</p><font color="blue" size="3">禅道</font><p>专注研发项目管理，内置需求管理、任务管理、bug管理、缺陷管理、用例管理、计划发布</p><h3 id="禅道的安装与配置"><a href="#禅道的安装与配置" class="headerlink" title="禅道的安装与配置"></a>禅道的安装与配置</h3><p>我把我的禅道放在了百度网盘上，可随时下载</p><p><a href="https://pan.baidu.com/s/1sUtOglOv0O3UMowf3SQFaw" target="_blank" rel="noopener">下载链接</a>密码：mv00</p><p>1.双击ZenTaoPMS.9.8.3.win64.exe文件，解压文件</p><div align="center"><br>    <img src="/images/posts/测试工具/1.png" height="300" width="500"><br></div><p>2.选择安装目录</p><div align="center"><br>    <img src="/images/posts/测试工具/2.png" height="300" width="500"><br></div><p>3.在解压的文件中，找到start.exe，双击</p><div align="center"><br>    <img src="/images/posts/测试工具/3.png" height="300" width="500"><br></div><p>4.跳转到该界面，不选中下方图标，点击启动禅道</p><div align="center"><br>    <img src="/images/posts/测试工具/4.png" height="300" width="500"><br></div><p>5.当界面显示这些内容时，表示启动成功，点击访问禅道</p><div align="center"><br>    <img src="/images/posts/测试工具/5.png" height="300" width="500"><br></div><p>6.页面会自动跳转到默认浏览器，并在选择版本界面，一般我们选择的都是开源的版本，接下来的讲述也是以开源为例</p><div align="center"><br>    <img src="/images/posts/测试工具/6.png" height="300" width="500"><br></div><p>7.在登录界面，用户名为admin，默认密码为123456</p><div align="center"><br>    <img src="/images/posts/测试工具/7.png" height="300" width="500"><br></div><p>8.登陆成功后，会跳转至应用界面，第一次登陆会显示密码等级过低，这时需要改密码</p><div align="center"><br>    <img src="/images/posts/测试工具/8.png" height="300" width="500"><br></div><h3 id="安装过程遇到的问题"><a href="#安装过程遇到的问题" class="headerlink" title="安装过程遇到的问题"></a>安装过程遇到的问题</h3><p>在启动禅道时(步骤4)，若无法启动，需检查数据库端口与apachezt…端口是否不同</p><p>可以去xampp\mysql\my.ini中修改，也可以在xampp\zentao\config\my.php中修改，在此文件中还可以查看数据库密码</p><p>禅道服务启动后，会提示数据库密码太弱，建议修改密码</p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++中的强制类型转换</title>
      <link href="/2018/07/26/C-%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2018/07/26/C-%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>在学习C语言的过程中，我们会遇到不同类型变量的转换 </p><p>在C++中，同在也存在，C++中类型转换与C语言的有什么区别呢？<a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>强制类型转换有两种：显式类型转换和隐式类型转换</p><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><p>一般应用在不同类型变量的赋值中</p><pre><code>int a = 10;char b = &apos;0&apos;;b = a;</code></pre><p>不需要加关键字</p><h4 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h4><p>可以应用在不同类型指针的转换中</p><p>比如：</p><pre><code>int a = 10;char* p = (char*)&amp;a;</code></pre><p>通过(转换后的类型)这种格式来完成转换</p><p>C++中的强制类型转换有四种：static_cast、reinterepret_cast、const_cast、dynamic_cast</p><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>static_cast类似于隐式类型转换</p><p>例：<br>    int a = 10;</p><pre><code>char b = &apos;0&apos;;b = static_cast&lt;char&gt;(a);</code></pre><h3 id="reinterepret-cast"><a href="#reinterepret-cast" class="headerlink" title="reinterepret_cast"></a>reinterepret_cast</h3><p>reinterepret_cast就类似与显式类型转换</p><p>例：</p><pre><code>int a = 10;char* p;p = reinterpret_cast&lt;char*&gt;(&amp;a);</code></pre><p>​<br>欢迎交流~</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>类与结构体</title>
      <link href="/2018/07/25/%E7%B1%BB%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2018/07/25/%E7%B1%BB%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p>在学习C语言的时候，我们就已经接触到了结构体，接触到C++我们有学习到了有关于类的知识 </p><p>接下来，让我们来搞懂这些吧~<a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="C语言和C-中的结构体有什么区别"><a href="#C语言和C-中的结构体有什么区别" class="headerlink" title="C语言和C++中的结构体有什么区别"></a>C语言和C++中的结构体有什么区别</h3><p>1.C语言中的结构体不能定义函数，而C++中的结构体不只可以有函数，还可以有虚函数</p><p>2.C语言中的内部成员的访问权限只有public，而C++中的内部成员变量的访问权限有public、protected、private三种</p><p>3.C语言的结构体是不可以继承的，而C++中的结构体可以继承自结构体或类</p><h3 id="C-中类与结构体有什么区别"><a href="#C-中类与结构体有什么区别" class="headerlink" title="C++中类与结构体有什么区别"></a>C++中类与结构体有什么区别</h3><p>1.为了兼容C，结构体内部成员变量的默认访问权限是public，而类的默认访问权限是private</p><p>2.结构体的默认继承权限是public，类的默认继承权限是private</p><p>理论上结构体可以做到的类都可以做到，类能做到的结构体不一定能做到</p><p>欢迎交流~</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>测试用例的撰写</title>
      <link href="/2018/07/10/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%9A%84%E6%92%B0%E5%86%99/"/>
      <url>/2018/07/10/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%9A%84%E6%92%B0%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>欲了解如何描述有效bug、bug的级别与生命周期和测试用例的设计方法，请看正文 </p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>很多初学者都认为，测试工程师就是用来找bug的，这样说只能答对一半</p><p>想知道另一半请戳<a href="http://www.bingoxin.top/2018/07/%E5%85%B3%E4%BA%8E%E6%B5%8B%E8%AF%95/">关于测试–概念篇</a></p><h3 id="那究竟如何描述有效的bug呢？"><a href="#那究竟如何描述有效的bug呢？" class="headerlink" title="那究竟如何描述有效的bug呢？"></a>那究竟如何描述有效的bug呢？</h3><p>当且仅当规格说明书存在并且正确，程序与需求规格说明书之间的不匹配才是bug。</p><h3 id="什么是有效的bug呢？"><a href="#什么是有效的bug呢？" class="headerlink" title="什么是有效的bug呢？"></a>什么是有效的bug呢？</h3><p>作为一个测试工程师，我们不能把任何一个bug都看成是有效的</p><p>而在我们发现有效的bug时，应该从以下几个方面进行描述</p><blockquote><p>发现问题的版本<br>问题触发的环境<br>错误重现的步骤<br>预期执行的描述<br>错误行为的描述<br>不把多个bug放在一起<br>其他</p></blockquote><p>一个好的测试，是可以检查出来bug，并可以告诉开发应该如何改正的</p><p>这就需要经验的积累啦！！！</p><p>bug的种类不同，这也就出现了</p><h3 id="bug的级别划分"><a href="#bug的级别划分" class="headerlink" title="bug的级别划分"></a>bug的级别划分</h3><p>根据公司的要求，对bug级别的认定也就不同，不过bug大概分为以下几类：</p><blockquote><p>1.崩溃：像电脑崩溃、死机、死循环、数据丢失等</p></blockquote><blockquote><p>2.严重：功能部分丢失等</p></blockquote><blockquote><p>3.一般：功能没有完全实现等</p></blockquote><blockquote><p>4.次要：错别字、界面格式不规范等</p></blockquote><p>在与开发沟通bug时，一定要注意言辞</p><p>对待一些bug，我们更多地是要站在用户的角度上去想</p><h3 id="bug的生命周期"><a href="#bug的生命周期" class="headerlink" title="bug的生命周期"></a>bug的生命周期</h3><div align="center"><br>    <img src="\images\posts\测试用例\bug的生命周期.PNG" height="300" width="500"><br></div><p>敲重点啦！！！</p><h3 id="测试用例设计方法"><a href="#测试用例设计方法" class="headerlink" title="测试用例设计方法"></a>测试用例设计方法</h3><p>先来说一下什么是测试用例吧~</p><p>测试用例就是对需求进行验证，所以这就说明需求也不一定是对的。</p><p> 1.等价类</p><p>例：设置密码必须为6~8为数字或字母<br>​<br>那么在测试输入设定密码位数时，6~8位为一类(有效类)，其他位数的密码为一类(无效类)。<br>​<br> 2.边界值</p><p>例：还是第一种设计方法的题目，6位和8位是符合需求规格说明书(有效类)的边界值，5位和9位位不符合(无效类)的边界值。<br>​<br>输入5位密码、6位密码、8位密码、9位密码都为测试密码是否符合的边界值，输入5位密码、6位密码、8位密码、9位密码都为测试密码是否符合的边界值<br>​<br>用于测试输入和输出的关系，是等价类的一种补充方法</p><p> 3.基于需求</p><p>任何测试用例都是依据需求规格说明书而设计的<br>​<br> 4.因果图</p><p>依据需求规格说明书确定输入与输出的关系，能直观地表明程序输入条件和输出动作之间的相互关系。<br>​<br><strong>因果图的使用：</strong><br>​<br>（1）分析所有可能的输入和输出<br>​<br>（2）找出输入和输出的关系  </p><p>（3）画出因果图<br>​<br>（4）画出判定表<br>​<br>（5）把判定表对应一个测试用例<br> 5.正交列表</p><p>在输入输出太多的情况下，因果图无法满足，正交列表不失为一种好的解决方法<br>​<br>在正交列表中，每一列中各数字出现的次数一样多，且任何两列所构成的各有序数对出现的次数都一样多<br>​<br>因果：变量                        水平：变量的取值<br>​<br>行数：试证次数，用N表示           因素数：正交表中列的个数，用C表示<br>​<br>水平数：任何单个因素能够取得的值得最大个数，正交表中的包含的值为从0到“水平数-1”或1到水平数<br>​<br>正交表的设计步骤如下：<br>​<br>(1)确定因素<br>​<br>(2)每个因素都有哪几个水平，即变量有哪几个取值<br>​<br>(3)选择一个合适的正交表<br>​<br>(4)把变量的值映射到表中<br>​<br>(5)把每一行的各因素水平的组合作为一个测试用例<br>​<br>(6)加上你认为可疑且没有在表中出现的用例组合<br>​<br> 6.场景设计法</p><p>用业务流把各个孤立的功能点串起来，事件触发时的情景便形成了场景而同一事件不同的触发顺序和处理结果形成时间流。<br>​<br> 7.错误推测法</p><p>一般经验丰富的测试工程师善用此方式<br>​<br>每个公司都会对测试进行评价，分为同行评审、用户检查和项目组评审三种。</p><p>在讲述各测试用例的设计方法时，并未举太多的例子<br>​<br>欢迎交流~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于测试</title>
      <link href="/2018/07/05/%E5%85%B3%E4%BA%8E%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/07/05/%E5%85%B3%E4%BA%8E%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>软件开发，包括分析、计划、设计、编码、测试、维护六个过程。 </p><p>软件测试，即验证软件功能是否满足用户的需求（包括检测功能是否完好以及是否存在bug两方面）</p><p>接下来，请收下这篇————测试概念篇</p><a id="more"></a><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><h3 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h3><blockquote><p>目的：验证软件有或没有问题</p></blockquote><blockquote><p>原则：以客户为中心，遵循软件测试的规范、流程、标准和要求。</p></blockquote><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><blockquote><p>需求，即满足用户期望或正式规定的文档的条件或权能。</p></blockquote><blockquote><p>其包括软件需求和用户需求两种。</p></blockquote><h3 id="测试与调试的问题"><a href="#测试与调试的问题" class="headerlink" title="测试与调试的问题"></a>测试与调试的问题</h3><blockquote><p><strong>目的不同：</strong>测试的目的是发现问题，调试的目的是发现并解决问题</p><p><strong>参与角色不同：</strong>测试由开发人员和测试人员来完成，调试由开发人员来完成</p><p><strong>执行的阶段不同：</strong>测试贯穿整个软件开发生命周期，测试一般在开发阶段</p></blockquote><h3 id="总是碰到的bug"><a href="#总是碰到的bug" class="headerlink" title="总是碰到的bug"></a>总是碰到的bug</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当且仅当规格说明是存在的并且正确，程序与规格说明之间的不匹配是bug。</span><br></pre></td></tr></table></figure><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>为了实施测试而向被测试的系统提供的一组集合。（包括<font color="red" size="3">测试环境、操作步骤、测试数据、预期结果等</font>）</p><h4 id="在写测试用例的时候，一个功能点可能对应n条测试用例。"><a href="#在写测试用例的时候，一个功能点可能对应n条测试用例。" class="headerlink" title="在写测试用例的时候，一个功能点可能对应n条测试用例。"></a>在写测试用例的时候，一个功能点可能对应n条测试用例。</h4><font color="red" size="3">关于测试用例要注意以下问题：</font><blockquote><p>1.不知道是否较全面的测试了所有功能</p></blockquote><blockquote><p>2.测试的覆盖率，无法衡量</p></blockquote><blockquote><p>3.对新版本的重复测试很难实施</p></blockquote><blockquote><p>4.存在大量冗余测试影响测试效率</p></blockquote><h4 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h4><p>假设一个功能点写一条测试用例，1.0版本需要测试100个功能点，请问需要写多少条测试用例？</p><p>若软件升级为1.1版本，在原有的基础上增加了2个功能点，请问需要写多少条测试用例？</p><p>答案：100条、2条</p><h3 id="开发模型"><a href="#开发模型" class="headerlink" title="开发模型"></a>开发模型</h3><p>开发模型大概包括四种：</p><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5%E7%AF%87/开发类型.PNG" height="300" width="500"><br></div><blockquote><p>瀑布类型适用于需求稳定的项目，主要用于开发过的项目</p></blockquote><blockquote><p>螺旋项目强调风险，但是比较耗费时间</p></blockquote><blockquote><p>增量迭代其实是两种，增量是将代码逐步叠加到完整，而迭代是写出一个大概轮廓，然后将轮廓细化。</p></blockquote><p>  我们通常将这两种看作一类</p><blockquote><p>敏捷具有注重人与人的沟通、对文档要求低、客户参与度高等特点。</p></blockquote><p>  敏捷是软件公司最受欢迎的开发模型</p><p>所以接下来，我来为大家更加详细的介绍一下<font color="black" size="3">敏捷</font></p><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5%E7%AF%87/敏捷.PNG" height="300" width="500"><br></div><p>product owner<br>是类似于产品经理的一个职务（简称PO）</p><p>主要工作职责是整理用户故事，定义其商业价值并对其进行排序</p><p>scrum master<br>敏捷教练（简称sm）</p><p>主要工作职责是召开会议，协调项目，为研发团队服务</p><p>team<br>研发团队</p><p>PO，sm都属于team，但是两个有比较特殊一点</p><p>而在敏捷开发模式中，对于测试而言，会有两个挑战：</p><p>轻文档和快速迭代</p><h3 id="软件测试模型（V型和W型）"><a href="#软件测试模型（V型和W型）" class="headerlink" title="软件测试模型（V型和W型）"></a>软件测试模型（V型和W型）</h3><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5%E7%AF%87/V型测试模型.PNG" height="300" width="500"><br></div><p>我们可以发现V型测试模型忽略了软件测试的重要性</p><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5%E7%AF%87/W型测试模型.PNG" height="300" width="500"><br></div><p>W型测试模型与V型模型相比，虽然有所改进，但整体仍为串行结构，不能满足需求的变更</p><p>欢迎交流~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++的三大特性之多态</title>
      <link href="/2018/07/01/C-%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E5%A4%9A%E6%80%81/"/>
      <url>/2018/07/01/C-%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>若简历中提到了你对C++有所了解，那么面试官会有80%的可能性问关于多态的内容</p><p>接下来就来看一下，我总结的关于面试如何向面试官讲述关于多态的内容吧！ </p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><font color="blue" size="3">首先你可以讲述一下多态的概念</font><p>多态，即事物表现出的多种形态</p><p>然后你可以举个栗子~</p><p>就像是一个演员，他可以演好人，也可以演坏人。</p><p>接下来，可以说一下<font color="blue" size="3">多态的种类</font></p><p>多态分为静态多态和动态多态两种</p><h3 id="静态多态（函数重载、泛型编程）"><a href="#静态多态（函数重载、泛型编程）" class="headerlink" title="静态多态（函数重载、泛型编程）"></a>静态多态（函数重载、泛型编程）</h3><p>静态多态是编译器在编译期间完成的，根据实参类型调用函数，若实参类型与形参都不同，则系统会报错</p><p>关于函数重载的实现，可戳</p><h3 id="动态多态：（虚函数）"><a href="#动态多态：（虚函数）" class="headerlink" title="动态多态：（虚函数）"></a>动态多态：（虚函数）</h3><p>动态多态是在程序运行时完成的</p><p>讲到这里你可以讲一下<font color="blue" size="3">动态多态的实现条件</font></p><p>其需要满足两个条件：</p><blockquote><p>1.基类中必须包含虚函数，并且派生类中要对基类中的该虚函数进行重写</p></blockquote><blockquote><p>2.通过基类对象的指针或引用来调用虚函数</p></blockquote><p>关于动态多态的实现，可戳<a href="https://github.com/luckypxx/C-plus-plus/blob/master/%E5%A4%9A%E6%80%81.cpp" target="_blank" rel="noopener">动态多态例程</a></p><p>在上面讲述动态多态的实现条件时，提到了<font color="blue" size="3">重写</font>的概念</p><h3 id="重写的实现条件"><a href="#重写的实现条件" class="headerlink" title="重写的实现条件"></a>重写的实现条件</h3><blockquote><p>1.基类中被重写的函数必须为虚函数</p></blockquote><blockquote><p>2.基类和派生类中虚函数的原型必须保持一致（即函数名，函数返回类型，函数参数列表完全相同）</p></blockquote><p>基类中将被重写的虚函数和派生类中与其对应的虚函数的访问限定符可以不同</p><font color="red" size="3">两个例外：</font><p>a.析构函数</p><p>b.协变：基类（派生类）虚函数返回基类（派生类）指针或引用</p><p>关于多态实现的原理，请戳</p><p>欢迎交流~</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++的三大特性之继承</title>
      <link href="/2018/06/27/C-%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E7%BB%A7%E6%89%BF/"/>
      <url>/2018/06/27/C-%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>今天来为大家介绍一下继承~</p><p>继承使代码可以复用，他是为多态做铺垫的 </p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 派生类名称：继承权限 基类名称</span><br></pre></td></tr></table></figure><h3 id="继承的权限"><a href="#继承的权限" class="headerlink" title="继承的权限"></a>继承的权限</h3><p>继承的权限有public、protected、private</p><p>在这里还要提一下访问权限，有public、protected、private三种</p><p>由于基类中成员访问权限不同，以及派生类派生方式不同，会使派生类的访问权限发生变化</p><p>关系如下表所示：</p><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%85%B3%E7%B3%BB.PNG" height="300" width="500"><br></div><p>在派生类派生的过程中，需要注意一下几点：</p><blockquote><p>基类private成员不能在派生类中被访问</p></blockquote><blockquote><p>基类protected成员在类外不能被访问，但在派生类中可以</p></blockquote><blockquote><p>父类对象对子类对象也适用</p></blockquote><h3 id="派生类对象模型的构建与销毁"><a href="#派生类对象模型的构建与销毁" class="headerlink" title="派生类对象模型的构建与销毁"></a>派生类对象模型的构建与销毁</h3><p>派生类对象构建时，会先调用派生类成员，再调用基类对象成员</p><p>派生类对象销毁时，会先销毁派生类成员，再销毁基类对象成员</p><p>关于继承体系，要注意：基类对象和派生类对象不在同一作用域</p><p>若基类和派生类中有相同名称的成员，优先访问派生类中的该名称成员</p><p>继承分为普通继承和虚拟继承</p><font color="blue" size="3">首先你可以讲述一下多态的概念</font><p>欢迎交流~</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态内存开辟</title>
      <link href="/2018/06/17/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F/"/>
      <url>/2018/06/17/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="C语言中实现方式"><a href="#C语言中实现方式" class="headerlink" title="C语言中实现方式"></a>C语言中实现方式</h3><p>使用malloc、alloc、realloc在堆上开辟空间，free将申请的空间释放掉 </p><h3 id="比较malloc-calloc-realloc"><a href="#比较malloc-calloc-realloc" class="headerlink" title="比较malloc/calloc/realloc"></a>比较malloc/calloc/realloc</h3><p><strong>相同点</strong></p><p>三者都是在堆上申请空间：</p><blockquote><p>若申请成功-&gt;返回申请的空间的首地址</p></blockquote><blockquote><p>若申请失败-&gt;返回空指针</p></blockquote><p>三者的申请空间的释放都是使用free()进行操作</p><a id="more"></a><p><strong>不同点</strong></p><blockquote><p>malloc:在堆上开辟指定字节数的空间</p></blockquote><blockquote><p>calloc:开辟空间会被0初始化</p></blockquote><blockquote><p>realloc:把原来开辟的空间缩小或扩大</p></blockquote><blockquote><p>——–&gt;缩小空间—&gt;返回原空间的地址，但空间变小<br>​<br>——–&gt;扩大空间—&gt;比较原空间连续的可用空间大小与原空间空间大小之和与申请空间的大小</p><p>——————-&gt;大于—&gt;返回空间首地址</p><p>——————-&gt;小于—&gt;重新开辟空间</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void* malloc(字节数)</span><br><span class="line">void* calloc(元素个数，元素大小)</span><br><span class="line">void* realloc(void* p,字节数)</span><br></pre></td></tr></table></figure><h3 id="malloc实现原理"><a href="#malloc实现原理" class="headerlink" title="malloc实现原理"></a>malloc实现原理</h3><p>在开辟空间时，除了所需的空间之外，还会在所需空间前开辟一个结构体，后面又追加了4个字节，防止越界</p><p><strong>结构体</strong>—共32个字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define nNoManLandSize 4</span><br><span class="line">typedef struct _CrtMemBlockHeader</span><br><span class="line">&#123;</span><br><span class="line">struct _CrtMMemBlockHeader * pBlockHeaderNext;</span><br><span class="line">struct _CrtMMemBlockHeader * pBlockHeaderPrev;//双向链表</span><br><span class="line">char * szFileName;</span><br><span class="line">int nLine;</span><br><span class="line">size_t nDataSize;</span><br><span class="line">int nBlockUse;</span><br><span class="line">long lRequest;</span><br><span class="line">unsigned char gap[nNoManLandSize];</span><br><span class="line">&#125;_CrtMenBlockHeader;</span><br></pre></td></tr></table></figure><h3 id="alloca"><a href="#alloca" class="headerlink" title="_alloca"></a>_alloca</h3><p>_alloca是在栈上申请空间的，用户不需要管理，由编译器自动维护。一旦出了使用_alloca的函数，所申请的空间会自动被收回去，不需要显式释放。</p><h3 id="常见的内存泄漏"><a href="#常见的内存泄漏" class="headerlink" title="常见的内存泄漏"></a>常见的内存泄漏</h3><ul><li>内存申请了忘记释放</li><li>指向新空间的两个指针p1、p2，若p1 = p2，这时p1、p2指向同一块空间，若free(p1);free(p2),会使同一块空间被释放两次。原来p2指向的内存块，会丢失，导致内存泄漏。</li><li>使用的空间大于开辟的空间，会将防止越界的四个字节占用，在释放内存时，会出问题</li><li>释放时传入的地址与申请时的地方不同</li></ul><h1 id="C-中申请空间"><a href="#C-中申请空间" class="headerlink" title="C++中申请空间"></a>C++中申请空间</h1><h3 id="关键字new和delete"><a href="#关键字new和delete" class="headerlink" title="关键字new和delete"></a>关键字new和delete</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int* p = new int;</span><br><span class="line">int* p1 = new int(5);</span><br><span class="line">int* p2 = new int[10];</span><br><span class="line"></span><br><span class="line">delete p;</span><br><span class="line">delete p1;</span><br><span class="line">delete[] p2;//释放连续空间</span><br></pre></td></tr></table></figure><ul><li>用new申请出的空间，不需要判空，p2申请的空间时连续的(数组的形式)</li><li>用delete删除连续空间时，需使用释放p2的形式</li><li>delete和new可以进行重载</li><li>new申请的空间，是一个完整的对象</li></ul><p><strong>delete[]和new[]要成对使用，delete和new要成对使用</strong></p><p>接下来看一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Test()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Test():&quot; &lt;&lt; this &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Test()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;~Test():&quot; &lt;&lt; this &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Test* p1 = (Test*)malloc(sizeof(Test));</span><br><span class="line">Test* p2 = new Test;</span><br><span class="line">Test* p3 = new Test[10];</span><br><span class="line"></span><br><span class="line">free(p1);</span><br><span class="line">delete p2;</span><br><span class="line">delete[] p3;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F/%E6%8D%95%E8%8E%B7.PNG" height="400" width="350"><br></div><p>由此我们可以看出:</p><ul><li>new出一个对象会调用类的构造函数，delete一个对象会调用类的析构函数</li><li>malloc不会调用类的构造函数，free不会调用类的析构函数</li><li>对于p3空间的申请与销毁，p3申请并开辟了10个Test对象的空间，则调用了十次构造函数，销毁时也就调用了10次析构函数</li></ul><p>欢迎交流~</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++中类的实例化对象</title>
      <link href="/2018/06/10/C-%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/06/10/C-%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>C语言使用函数对内容进行封装的，而C++是用类进行封装的</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>类的关键字是class，而类的作用域也不同 </p><h3 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h3><p> 1.全局域</p><p> 2.局部域</p><p> 3.类域</p><p> 4.名字空间域</p><a id="more"></a><h3 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h3><p>类的实例化就是用类类型创建对象的过程 </p><p>类在创建实例化对象时，类本身并不被分配空间</p><p>类对象包括类里的成员变量</p><p>若计算类的大小，只需计算成员变量大小之和，但要注意内存对齐</p><p>空类大小为一个字节，为区分不同对象</p><h3 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h3><p>对象模型指的是对象中各个成员在内存中的布局方式 </p><p>注意：对象大小只包括成员变量，不包括方法</p><p>欢迎交流~</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++的三大特性之封装</title>
      <link href="/2018/06/06/C-%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E5%B0%81%E8%A3%85/"/>
      <url>/2018/06/06/C-%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>面试中，在问到有关C++的内容时，通常会问到C++的三大特性是什么？</p><p>C++的三大特性是封装、继承和多态</p><p>接下来我将分三次来讲解关于这三大特性的知识</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="封装的概念"><a href="#封装的概念" class="headerlink" title="封装的概念"></a>封装的概念</h4><p>隐藏对象的属性和实现细节，仅对公开接口和对象进行交互，将数据和操作数据的方法进行有机结合。</p><p>函数是一种封装方式，在C++中更多地是用类进行封装。 </p><h4 id="访问限定符"><a href="#访问限定符" class="headerlink" title="访问限定符"></a>访问限定符</h4><p>提到封装，不得不说一下访问限定符</p><p>从该访问限定符开始，到下一个访问限定符的位置，为该访问限定符的限定范围。</p><p>访问限定符有三种：public(公有)、protected(保护)、private(私有)</p><p>公有即在类外可以访问变量</p><p>保护和私有不可以在类外访问变量，若只是单纯的限定变量访问权限，二者没什么区别，</p><p>但在继承中，作用会有所不同，欲了解可戳<a href="http://www.bingoxin.top/2018/06/%E7%BB%A7%E6%89%BF/">C++的三大特性之继承</a></p><p>访问限定符只是在编译阶段有用，当数据映射到内存后，没有任何访问限定符的区别</p><p>类的默认访问权限为私有，而结构体的默认访问权限为公有(因为结构体兼容C)。</p><h4 id="在类外如何访问私有成员变量"><a href="#在类外如何访问私有成员变量" class="headerlink" title="在类外如何访问私有成员变量"></a>在类外如何访问私有成员变量</h4><p>在类外可以通过函数、指针、引用访问私有成员变量，也可以通过共有函数给私有成员变量赋值。</p><p>请戳链接，可直接看代码<a href="https://github.com/luckypxx/C-plus-plus/blob/master/%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F.cpp" target="_blank" rel="noopener">在类外如何访问私有成员变量</a></p><p>欢迎交流~</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向对象or面向过程</title>
      <link href="/2018/06/05/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1or%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/06/05/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1or%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>刚刚接触C++，了解到了一些基础概念，在之前学C语言时也没有接触过。</p><p>也算是感受到了C++的一点点魅力~</p><a id="more"></a><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><h3 id="面向过程？面向对象？"><a href="#面向过程？面向对象？" class="headerlink" title="面向过程？面向对象？"></a>面向过程？面向对象？</h3><p>C语言是面向过程的，而JAVA和C++是面向对象的。</p><blockquote><p>艾兰·库伯在《软件创新之路》中提到：</p></blockquote><blockquote><p>“面向过程和面向对象的区别并不像人们想象得那么大，面向对象的大部分思想在面向过程中也能体现,</p></blockquote><blockquote><p>但面向过程最大的问题在于系统的膨胀，面向对象将无法应付，最终导致系统的崩溃。”</p></blockquote><h3 id="面向过程和面向对象的区别大概有如下几个方面："><a href="#面向过程和面向对象的区别大概有如下几个方面：" class="headerlink" title="面向过程和面向对象的区别大概有如下几个方面："></a>面向过程和面向对象的区别大概有如下几个方面：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.面向过程重用的是函数，而面对对象重用的是类（即将数据和处理数据的过程及函数封装在一起的实体）。</span><br><span class="line"> </span><br><span class="line">2.面向过程程序设计方法的实质上是从计算机处理问题的观点来进行程序设计工作：输入--运算--输出；</span><br><span class="line"> </span><br><span class="line">面向对象程序设计方法需要使用结构化的程序来设计。</span><br><span class="line"></span><br><span class="line">3. 面向过程程序设计是一种自上而下的程序设计方法，从程序的一部分入手，一点一点地构建出整个程序；</span><br><span class="line"> </span><br><span class="line">面向对象程序设计是以一数据为中心，类作为表现数据的工具，成为划分程序的基本单位。</span><br></pre></td></tr></table></figure><p>欢迎交流~</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>叩开C++的大门</title>
      <link href="/2018/06/05/%E5%8F%A9%E5%BC%80C-%E7%9A%84%E5%A4%A7%E9%97%A8/"/>
      <url>/2018/06/05/%E5%8F%A9%E5%BC%80C-%E7%9A%84%E5%A4%A7%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="缺省函数"><a href="#缺省函数" class="headerlink" title="缺省函数"></a>缺省函数</h4><p>如果非要把缺省函数比作一个事物，它更像是一个备胎。</p><p>如果函数传参，就会将传过来的值赋值给形参</p><p>如果没有传参，则就会将缺省值传递给函数</p><a id="more"></a><p>关于缺省参数要注意以下几点：</p><blockquote><p>a.带缺省值的参数必须放在参数列表的最后面<br>b.缺省参数不能同时在函数声明和定义中出现，只能二者去一<br>c.缺省值必须是常量或者是全局变量<br>d.C语言不支持</p></blockquote><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>函数重载，即在同一作用域里，声明几个功能相同的函数，形参列表不同或返回值类型不同(参数列表中，参数个数和顺序相同)，即可构成函数重载</p><p>若只是返回值类型不同，不可构成函数重载，在这里也要注意：返回值不属于函数，参数属于函数</p><p>在C语言中，不会构成函数重载，只是由于C语言和C++的编译风格不同</p><p>在C语言中，编译完成后会在函数名前加上“_”，</p><p>在C++中，编译完成后会被修饰成由函数名，函数参数列表和返回值构成的一串特定的字符串，用于区分函数名相同的各个函数</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用，就相当于为一个变量取一个别名</p><p> int a=10;<br> int&amp; ra=a;<br>这就是引用的用法，ra和a的地址相同，变量存放的内容也相同</p><p>引用站在应用层，编译器不为其开辟空间</p><p>在使用引用时要注意：</p><blockquote><p>a.引用在定义时必须有初始化<br>b.一个变量可以有多个引用<br>c.引用一旦引用一个实体，再不能引用其他实体</p></blockquote><p>若初始变量被const修饰，其引用在定义时也要被const修饰，而初始变量就相当于常数</p><p>接下来再来说一下数组引用的代码格式：</p><p> int (&amp;array)[3]={0}; //注意符号优先级</p><p>引用可以作为函数的参数和返回值</p><p>在函数传参时，从底层来看，传引用和传指针效率相差不多</p><p>但是引用和指针还是有区别的，如下：</p><blockquote><p>引用在定义时必须初始化，而指针没有要求<br>指针可以为空，而引用不可以<br>引用一旦有所指向就不能更改，而指针指向一个变量后，还可以更改指向另一个类型相同的变量<br>在sizeof中含义不同：引用的结果为引用类型的大小，但指针始终为4(在Win10，vs2013的环境下)<br>引用自加改变的是变量的大小，指针自加改变的是指针的指向<br>有多级指针，没有多级引用<br>指针需要手动寻址，引用可以通过编译器寻址<br>使用引用更为安全</p></blockquote><p>那么引用相当于void* const类型的指针(可以改变其内容，不可改变其指向)</p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>命名空间可以将标识符本地化，避免命名冲突或名字污染</p><p>首先我们先来了解一下命名空间的定义方式：</p><p> namespace N</p><p>关于命名空间和作用域，不得不再多说几句： </p><blockquote><p>a.若一个命名空间为N，“N::”表示其空间作用域，“::”为作用限定符<br>b.相同作用域定义的命名空间名称可以相同，编译器会自动将其合成<br>c.命名空间可以嵌套(“NN1::”)</p></blockquote><p>仅仅学了这几个概念，就觉得C++功能的实现比C语言简单许多</p><p>终于敲开C++的大门啦！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>函数调用约定</title>
      <link href="/2018/06/05/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
      <url>/2018/06/05/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>在学习C语言的时候，总是碰到__cdecl，一直都只是知道他是一种函数调用约定，</p><p>今天来总结一下函数的调用约定~</p><a id="more"></a><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><h3 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h3><p>当一个函数被调用时，函数的参数会被传递给调用的函数和返回值会被返回给调用函数。函数调用约定就是描述参数是怎么传递和由谁平衡堆栈的，当然还有返回值。<br>​<br>1.<font color="red" size="3">__cdecl</font><br>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.参数是从右向左传递的，也是从右向左放在堆栈中的</span><br><span class="line"></span><br><span class="line">2.堆栈平衡是由调用函数来执行的</span><br><span class="line"></span><br><span class="line">3.函数的前面会加一个前缀_(_Test)</span><br></pre></td></tr></table></figure><p>2.<font color="red" size="3">__stdcall</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.参数是从右向左传递的，也是从右向左放在堆栈中的</span><br><span class="line"></span><br><span class="line">2.堆栈平衡是由被调用函数来执行的</span><br><span class="line"></span><br><span class="line">3.在函数名前加下划线修饰，在函数名的后面由@来修饰并、加上栈需要的字节数的空间(_Test@8)</span><br></pre></td></tr></table></figure><p>3.<font color="red" size="3">__fastcall</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.参数放在寄存器中，而不是栈中</span><br><span class="line"></span><br><span class="line">2.最左边的两个不大于4个字节的参数分别放在ecx和edx寄存器。当寄存器用完的时候，其余参数仍然从右往左的顺序压栈。</span><br></pre></td></tr></table></figure><p>4.<font color="red" size="3">__thiscall</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.C++成员函数的默认调用约定，用于限制成员函数</span><br><span class="line"></span><br><span class="line">2.参数从右向左被推入堆栈</span><br><span class="line"></span><br><span class="line">3.通过ecx寄存器来传递this指针，将其传递到X86结构上，而不是堆栈上</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库基本操作</title>
      <link href="/2018/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>刚刚接触数据库，安装了MYSQL5.7，大概需要二十分钟</p><p>接下来，就来说一下关于数据库的一些知识吧~</p><a id="more"></a><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><blockquote><h2 id="为什么要有数据库？"><a href="#为什么要有数据库？" class="headerlink" title="为什么要有数据库？"></a>为什么要有数据库？</h2></blockquote><p>我们都知道，文件就可以存储数据库</p><p>但是文件存储存在以下几个弊端：</p><blockquote><p>1.文件的安全性</p><p>2.文件不利查询以及对数据进行管理</p><p>3.文件不适合存放海量数据</p><p>4.文件在程序中控制不方便</p></blockquote><p>文件一般存储于内存和磁盘中，内存存储数据的优点是速度快，缺点是一旦断电数据就会消失</p><p>在学习数据库操作语句之前我们应该先搞清楚数据库和表的关系：</p><p>举个栗子：数据库就像图书馆的不同类别的馆，像是通信类、计算机类、自然科学类等等，</p><p>而表就像每个馆里放的书架，不知道这样来说够不够形象 0.0</p><p>接下来，就来说一下</p><h4 id="SQL的分类"><a href="#SQL的分类" class="headerlink" title="SQL的分类:"></a>SQL的分类:</h4><blockquote><p>DDL 数据定义：create,drop,alter</p><p>DML 数据操纵：insert,delete,update</p><p>DML中单独分出来的DQL：select（数据查询）</p><p>DCL 数据控制：grant,revoke,commit</p></blockquote><ul><li><p>创建数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名;</span><br></pre></td></tr></table></figure></li><li><p>进入数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> 数据库名;</span><br></pre></td></tr></table></figure></li><li><p>显示所有数据库：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;show databases;&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;create table 表名 (表里存放的内容);&gt;</span><br><span class="line">&lt;例如：create table student (id int,name varchar(32));&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是：表中内容的定义方式与C语言存在差别，数据类型放在数据名的后面，字符型数组在定义时使用()而不是[]。</p></li><li><p>显示数据库中的表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;show tables;&gt;</span><br></pre></td></tr></table></figure></li><li><p>描绘表中的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;desc 表名;&gt;</span><br></pre></td></tr></table></figure></li><li><p>在表中插入数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert into 表名(表中内容的定义的变量名) values (变量的具体内容);&gt;</span><br><span class="line"></span><br><span class="line">&lt;例如：insert into student (id,name) values (1,&apos;ht&apos;)；&gt;</span><br></pre></td></tr></table></figure></li><li><p>在表中查询数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;select * from 表名;&gt;</span><br></pre></td></tr></table></figure></li><li><p>查看警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;show warnings;&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="每条指令输入完成都要以-“-”-结尾，否则计算机会认为输入的语句并未结束"><a href="#每条指令输入完成都要以-“-”-结尾，否则计算机会认为输入的语句并未结束" class="headerlink" title="每条指令输入完成都要以 “;” 结尾，否则计算机会认为输入的语句并未结束"></a>每条指令输入完成都要以 “;” 结尾，否则计算机会认为输入的语句并未结束</h5><p>以上部分指令操作的操作界面如下 ：</p><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/database/data1.png" height="300" width="500"><br></div><br><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/database/data2.png" height="150" width="250"><br></div><ul><li>字符集(出现乱码首先考虑字符集的问题)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名 <span class="keyword">charset</span>=utf8;</span><br></pre></td></tr></table></figure><p>使用语句<code>show create database 库名</code>来查看创建库的语句，会出现以下句子：</p><p><code>CREATE DATABASE db1 /*!40100 DEFAULT CHARACTER SET utf8 */</code></p><p>40100是版本号</p><ul><li>校验规则</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名 <span class="keyword">charset</span>=utf8 <span class="keyword">collate</span> utf8_general_ci;</span><br></pre></td></tr></table></figure><h3 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h3><ul><li>备份</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -P3306 -u root -p 密码 -B 数据库名;</span><br></pre></td></tr></table></figure><ul><li>恢复</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source D:/mysql-5.7.22/mytest.sql;</span><br></pre></td></tr></table></figure><h3 id="查看连接情况"><a href="#查看连接情况" class="headerlink" title="查看连接情况"></a>查看连接情况</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span>;</span><br></pre></td></tr></table></figure><h3 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h3><ul><li>创建表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名&#123;</span><br><span class="line">列名<span class="number">1</span> 类型，</span><br><span class="line">列名<span class="number">2</span> 类型，</span><br><span class="line">...</span><br><span class="line">&#125;<span class="built_in">character</span> <span class="keyword">set</span> 字符集 <span class="keyword">collate</span> 校验规则 <span class="keyword">engine</span> 存储引擎;</span><br></pre></td></tr></table></figure><ul><li>描述表的结构</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">des 表名;</span><br></pre></td></tr></table></figure><ul><li>修改表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span>(<span class="keyword">column</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>判断两个无头结点的单链表是否相交</title>
      <link href="/2018/04/01/%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%97%A0%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/"/>
      <url>/2018/04/01/%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%97%A0%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<p>在笔试和面试中，常常会出现关于数据结构中的单链表的考题，<br>今天就来说一下关于判断两个无头结点的单链表是否相交的代码</p><a id="more"></a><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><p>无头结点的单链表自身分为两种情况，带环和不带环，</p><p>l1,l2分别代表两条链表，</p><p>用真值表来表示，1表示带环，0表示不带环</p><p>l1 0 0 1 1<br>l2 0 1 0 1</p><p>首先我们来讨论一下较为简单的不带环的情况：</p><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/data-structure/List1.gif" height="300" width="500"><br></div><p>如图所示，共有两种情况，即相交和不相交。</p><p>相交分为三种情况（可以视为一条链表的尾部分别和另一条链表的不同部分相交）：即头部、中间和尾部。</p><p>由图我们可以看出，若两条链表相交，他们的尾结点一定相同。</p><p>这可以作为我们判断两结点是否相交的判断点。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 判断两个单链表是否相交---链表不带环 </span><br><span class="line">int IsCrossWithoutCircle(PNode pHead1, PNode pHead2)//pHead1代表链表1，pHead2代表链表2</span><br><span class="line">&#123;</span><br><span class="line">PNode pTail1 = pHead1;//定义链表1的尾结点，并让其指向链表1的头结点</span><br><span class="line">PNode pTail2 = pHead2;//定义链表2的尾结点，并让其指向链表2的头结点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//两链表只要有一个为空即不相交</span><br><span class="line">if (NULL == pTail1 || NULL == pTail2)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">//遍历链表1，找到尾结点</span><br><span class="line">while (pTail1-&gt;_pNext)</span><br><span class="line">&#123;</span><br><span class="line">pTail1 = pTail1-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//遍历链表2，找到尾结点</span><br><span class="line">while (pTail2-&gt;_pNext)</span><br><span class="line">&#123;</span><br><span class="line">pTail2 = pTail2-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//判断两条链表的尾结点是否相等</span><br><span class="line">if (pTail1 == pTail2)</span><br><span class="line">&#123;</span><br><span class="line">return 1;//相等即相交，返回1</span><br><span class="line">&#125;</span><br><span class="line">return 0;//不相等即不相交，返回0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建的两条链表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//构建两条链表</span><br><span class="line">PNode pHead1;</span><br><span class="line">PNode pHead2;</span><br><span class="line"></span><br><span class="line">SListInit(&amp;pHead1);//链表初始化</span><br><span class="line">SListPushBack(&amp;pHead1, 1);//链表尾插</span><br><span class="line">SListPushBack(&amp;pHead1, 2);</span><br><span class="line">SListPushBack(&amp;pHead1, 3);</span><br><span class="line"></span><br><span class="line">SListInit(&amp;pHead2);</span><br><span class="line">SListPushBack(&amp;pHead2, 1);</span><br><span class="line">SListPushBack(&amp;pHead2, 2);</span><br><span class="line">SListPushBack(&amp;pHead2, 3);</span><br><span class="line"></span><br><span class="line">while (pHead1-&gt;_pNext)</span><br><span class="line">&#123;</span><br><span class="line">pHead1 = pHead1-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line">pHead1-&gt;_pNext = pHead2;</span><br></pre></td></tr></table></figure><p>该种情况为相交的第三种情况，测试结果如下:</p><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/data-structure/List2.gif" height="300" width="500"><br></div><p>输出1，则其相交，其他情况不再一一描述。</p><p>带环的情况也比较多，不过经过分析也不会那么复杂。</p><p>接下来我们来画图进行分析</p><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/data-structure/List3.gif" height="300" width="500"><br></div><p>在画图过程中，我们可以发现：不会出现其中一条链表带环，且两条链表相交的情况。<br>由图我们可以得知，两个带环的链表相交分为，环内相交和环外相交两种。</p><p>在判断两链表是否相交的过程中，我们还需要实现判断链表是否带环，</p><p>判断链表是否带环：</p><p>1、定义两个指针，一个一次走两个结点（pFast），一个一次走一个结点(pSlow)</p><p>2、若有环，pFast会与pSlow相遇，此时返回两指针的地址；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若无环，如果pFast==NULL，即可证明其无环，返回空指针</span><br></pre></td></tr></table></figure><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PNode IsListwithCircle(PNode pHead)</span><br><span class="line">&#123;</span><br><span class="line">PNode pFast = pHead;</span><br><span class="line">PNode pSlow = pHead;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (NULL == pHead)</span><br><span class="line">&#123;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while (pFast-&gt;_pNext)</span><br><span class="line">&#123;</span><br><span class="line">pFast = pFast-&gt;_pNext-&gt;_pNext;</span><br><span class="line">pSlow = pSlow-&gt;_pNext;</span><br><span class="line">if (pFast == pSlow)</span><br><span class="line">return pFast;</span><br><span class="line">&#125;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着判断两个链表是否相交：</p><p>大概思路就是：让两个链表的相遇点一个保持不动，一个往后走（每次走一步），若两个相遇点相遇，即可说明两条链表相交。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int IsCrossWithCircle(PNode pHead1, PNode pHead2)</span><br><span class="line">&#123;</span><br><span class="line">PNode pMeetNode1 = NULL;</span><br><span class="line">PNode pMeetNode2 = NULL;</span><br><span class="line">PNode pCur = NULL;</span><br><span class="line"></span><br><span class="line">if (NULL == pHead1 || NULL == pHead2)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pMeetNode1 = IsListwithCircle(pHead1);</span><br><span class="line">pMeetNode2 = IsListwithCircle(pHead2);</span><br><span class="line">pCur = pMeetNode1;</span><br><span class="line"></span><br><span class="line">//其中一个链表带环或两条链表均不带环</span><br><span class="line">if (NULL == pMeetNode1 || NULL == pMeetNode2)</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">//两条链表均带环</span><br><span class="line">while (pMeetNode1 != pMeetNode2)</span><br><span class="line">&#123;</span><br><span class="line">pCur = pCur-&gt;_pNext;</span><br><span class="line">if (pCur == pMeetNode1)</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于测试结果就不在展示了</p><h2 id="寄语"><a href="#寄语" class="headerlink" title="寄语"></a>寄语</h2><p>　　判断两条链表是否相交经常会出现在面试题中，如果把图画出来写程序会更有思路。</p><p>欢迎交流~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自定义类型</title>
      <link href="/2018/03/05/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/03/05/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么存在内存对齐"><a href="#为什么存在内存对齐" class="headerlink" title="为什么存在内存对齐"></a>为什么存在内存对齐</h3><blockquote><p>1.<strong>平台原因：</strong>不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常</p><p>2.<strong>性能原因：</strong>数据结构(尤其是栈)应该尽可能地在自然边界上对齐<br>–&gt;若访问未对齐的内存，处理器需要做两次内存访问；而对齐的内存访问仅需要访问一次就可以拿到数据</p></blockquote><a id="more"></a><h3 id="结构体内存对齐规则"><a href="#结构体内存对齐规则" class="headerlink" title="结构体内存对齐规则"></a>结构体内存对齐规则</h3><p>Linux中，默认对齐数是4</p><p>Windows下的vs，默认对齐数是8</p><blockquote><p>1.第一个成员在与结构体变量偏移量为0的地址处</p><p>2.其他成员变量要对齐到某个数字(对齐数)的整数倍的地址处—&gt;对齐数=编译器默认的一个对齐数与该成员大小的较小值</p><p>3.结构体总大小为最大对齐数的整数倍</p><p>4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数的整数倍</p></blockquote><p>可以说，内存对齐是用时间来弥补空间</p><h3 id="结构体传参"><a href="#结构体传参" class="headerlink" title="结构体传参"></a>结构体传参</h3><p>结构体传参时，考虑变量可能过大，不要传结构体变量，要传结构体指针</p><h3 id="位段"><a href="#位段" class="headerlink" title="位段"></a>位段</h3><p>位段的声明和结构是类似的，有两个不同点：</p><blockquote><p>1.位段的成员必须是int、unsigned int 或 signed int</p><p>2.位段的成员后边有一个冒号和一个数字</p></blockquote><p>位段成员后面的数字表示bit位，位段可以节省空间</p><p><strong>开辟空间方式</strong></p><p>由于位段里变量为int类型，因此在开辟空间时，一次开辟4个字节的空间，即32个bit位。</p><p>需要注意的是：<strong>位段是不可以跨平台的、位段不存在对齐</strong></p><h3 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h3><p>枚举，即一一列举</p><p>枚举列举的是枚举常量，第一个常量为0，之后的常量大小依次+1</p><p><strong>枚举的优点</strong></p><ul><li>增加代码的可读性和可维护性</li><li>和#define定义的标识符比较，枚举有类型检查，更加严谨</li><li>防止命名污染</li><li>便于调试</li><li>使用方便，一次可以定义多个常量</li></ul><h3 id="联合-共用体"><a href="#联合-共用体" class="headerlink" title="联合(共用体)"></a>联合(共用体)</h3><p>在共用体中定义的变量共用一块内存</p><p><strong>空间计算</strong></p><ul><li>联合的大小至少是最大成员的大小</li><li>当最大成员不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍</li></ul><h3 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h3><p>小端：低字节放低地址处，高字节放高地址处</p><p>大端：低字节放高地址，高字节放低地址</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址是由点分十进制的方式处理的</p><p>IP地址实际是整型的十进制数字，将十进制数字的每个字节转化成转化成十进制，再用.连接，就是IP地址</p><p>代码实现：<br>​    #include &lt;stdio.h&gt;<br>​    #include &lt;Windows.h&gt;<br>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">union un</span><br><span class="line">&#123;</span><br><span class="line">unsigned int num;</span><br><span class="line">struct </span><br><span class="line">&#123;</span><br><span class="line">unsigned char a;</span><br><span class="line">unsigned char b;</span><br><span class="line">unsigned char c;</span><br><span class="line">unsigned char d;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">union un myip;</span><br><span class="line">myip.num = 716872929;</span><br><span class="line">printf(&quot;%d.%d.%d.%d&quot;, myip.d, myip.c, myip.b, myip.a);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎交流~~</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>函数栈桢</title>
      <link href="/2017/12/13/%E5%87%BD%E6%95%B0%E6%A0%88%E6%A1%A2/"/>
      <url>/2017/12/13/%E5%87%BD%E6%95%B0%E6%A0%88%E6%A1%A2/</url>
      
        <content type="html"><![CDATA[<p>在做面试题的时候，我遇到了这样一道题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">int tmp=10;</span><br><span class="line">int* p=(int*)(*(&amp;tmp+1));</span><br><span class="line">*(p-1)=20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a=0;</span><br><span class="line">fun();</span><br><span class="line">printf(&quot;%d&quot;,a);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一眼看去，a的值好像并未发生改变。但是实际上并不是我们看到的这么简单哦~<a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在解这道题时，我们需要搞懂函数调用是怎么实现的？？？</p><p>接下来我就来一步一步讲解</p><h3 id="函数栈桢地址使用"><a href="#函数栈桢地址使用" class="headerlink" title="函数栈桢地址使用"></a>函数栈桢地址使用</h3><p>函数栈桢的使用是由高地址向低地址使用的</p><h3 id="函数压栈"><a href="#函数压栈" class="headerlink" title="函数压栈"></a>函数压栈</h3><p>函数压栈：在栈顶处不断放入数据</p><h3 id="函数调用时使用的寄存器"><a href="#函数调用时使用的寄存器" class="headerlink" title="函数调用时使用的寄存器"></a>函数调用时使用的寄存器</h3><ul><li>esp：函数栈顶的地址，随着压栈的进行，esp会向低地址处移动</li><li>ebp：函数栈底的地址</li></ul><h3 id="在调用main函数之前，还调用了一个函数叫做mainCRTStart"><a href="#在调用main函数之前，还调用了一个函数叫做mainCRTStart" class="headerlink" title="在调用main函数之前，还调用了一个函数叫做mainCRTStart()"></a>在调用main函数之前，还调用了一个函数叫做mainCRTStart()</h3><p>mainCRTStart是用来调用main函数的一个函数</p><p>接下来，我将以下面的代码为例，来讲解函数调用过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int Add(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">int z = 0;</span><br><span class="line">z = x + y;</span><br><span class="line">return z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">int ret = 0;</span><br><span class="line">ret = Add(a,b);</span><br><span class="line">printf(&quot;%d&quot;,ret);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h2 id="调用mainCRTStart"><a href="#调用mainCRTStart" class="headerlink" title="调用mainCRTStart()"></a>调用mainCRTStart()</h2><p>以调用mainCRTStart()来调用main函数，此时ebp在栈底，esp在栈顶。</p><h2 id="用汇编代码来看"><a href="#用汇编代码来看" class="headerlink" title="用汇编代码来看"></a>用汇编代码来看</h2><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/%E5%87%BD%E6%95%B0%E6%A0%88%E6%A1%A2/%E6%8D%95%E8%8E%B75.PNG" height="500" width="500"><br></div><p>注意：函数栈桢图中的序号与步骤号对应，汇编代码前的红色数字与步骤号也是对应的，一个步骤可能执行多条语句</p><p><strong>第一步</strong></p><p>将ebp的值压在栈顶上(红色方框)，esp由esp1移到esp2的位置</p><p><strong>第二步</strong></p><p>将esp的值赋给ebp，即ebp由ebp1的位置移到ebp2的位置</p><p><strong>第三步</strong></p><p>esp-4Ch:esp由esp2的位置移到esp3的位置，此时为esp与ebp维护的空间是为main函数开辟了空间</p><p><strong>第四步</strong></p><p>将ebx、esi、edi依次压入栈中，esp随着每次压栈向低地址处移动，则esp由esp3的位置移到esp4的位置</p><p><strong>第五步</strong></p><blockquote><p>将edi放到ebp-4Ch的位置上，即将edi移动到edi1的位置，</p></blockquote><blockquote><p>将eax的内容拷贝ecx存放内容次，放到edi向下的内容中去。将为main函数开辟的空间全部初始化成随机值</p></blockquote><p><strong>第六步</strong></p><p>为ebp-4地址处赋值，为10(a)</p><p><strong>第七步</strong></p><p>为ebp-8地址处赋值，为20(b)</p><p><strong>第八步</strong></p><p>为ebp-12地址处赋值，为0(ret)</p><p><strong>第九步</strong></p><blockquote><p>将ebp-8地址处的值赋给寄存器eax，并将eax压入栈中(_b)</p></blockquote><blockquote><p>将ebp-4地址处的值赋给寄存器ecx，并将ecx压入栈中(_a)</p></blockquote><blockquote><p>将call指令下一条指令的地址压入栈中</p></blockquote><blockquote><p>该过程进行完，esp由esp4的位置移动到esp5的位置</p></blockquote><p><strong>第十步</strong></p><p>进入Add函数中，将main函数的ebp位置压入栈中，esp由esp5位置移到esp5的位置</p><p><strong>第十一步</strong></p><p>将ebp移动到esp的位置，即将ebp由ebp2的位置移到ebp3的位置</p><p><strong>第十二步</strong></p><p>esp-44h：为Add函数开辟空间</p><p><strong>第十三步</strong></p><p>依次将ebx、esi、edi压入栈中，则esp由esp7的位置移到esp8的位置</p><p><strong>第十四步</strong></p><p>将edi移动到edi1的位置(橙色)，并将Add函数开辟的空间初始化为随机值</p><p><strong>第十五步</strong></p><p>将ebp3-4的位置初始化成0（z）</p><p><strong>第十六步</strong></p><blockquote><p>将ebp+8的位置的值(a)放入eax寄存器中</p></blockquote><blockquote><p>将eax(x)中的值加ebp+0Ch(y)，将结果放在eax寄存器中</p></blockquote><blockquote><p>将eax中的值，赋给ebp-4(z)</p></blockquote><p><strong>第十七步</strong></p><p>将ebp-4(z)中的值放入eax寄存器中</p><p><strong>第十八步</strong></p><p>将edi、esi、ebx弹出栈，将esp由eap8的位置移动到esp7的位置</p><p><strong>第十九步</strong></p><p>将esp放在ebp的位置，即esp由esp7的位置移动到esp9的位置</p><p><strong>第二十步</strong></p><p>将ebp弹出，ebp移动至main函数的栈底位置，即esp2的位置</p><p><strong>第二十一步</strong></p><p>将寄存器eax中存放的值，赋给ebp-0Ch(ret)</p><h3 id="面试题解答"><a href="#面试题解答" class="headerlink" title="面试题解答"></a>面试题解答</h3><p>其实a的值是在调用函数fun时，通过指针赋值发生的改变</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言-操作符</title>
      <link href="/2017/11/12/C%E8%AF%AD%E8%A8%80-%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2017/11/12/C%E8%AF%AD%E8%A8%80-%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>对于刚接触C语言的人来说，一提到操作符，可能也只有==、+、-、*等等。今天就来了解一下操作符的知识。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>操作符包括算术操作符、移位操作符、位操作符、赋值、单目操作符。关系操作符、逻辑操作符、条件操作符。逗号操作符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">算术操作符有：加（+）、减（-）、乘（*）、除（/）、取模（%）。</span><br></pre></td></tr></table></figure><p>在这些操作符中，需要注意的是除（/）和取模（%）的使用：</p><a id="more"></a><p>1、 浮点数相除是浮点数，整数相除是整数，浮点数除以整数为浮点数。</p><p>2、 取模（%）两边都应为整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">移位操作符有：左移（&lt;&lt;）和右移（&gt;&gt;）。</span><br></pre></td></tr></table></figure><p>在说这些之前，我们应该了解什么是源码、反码和补码。</p><p>电脑一般都是32位的，则在编程软件中，数字的二进制也是32位。正数在电脑中以源码保存，负数在电脑中以补码保存。正数的源码最高位是0，负数的源码最高位是1。正数的源码、反码、补码都相同。负数的反码是在符号位不变的基础上，其他位取反。其补码为反码+1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例如：1源码为0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">      1反码为0000 00000000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">      1补码为0000 00000000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">     -1源码为1000 00000000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">     -1反码为1111 11111111 1111 1111 1111 1111 1110</span><br><span class="line"></span><br><span class="line">     -1补码是1111 11111111 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure><p>接下来再说左移（&lt;&lt;），末位补0，最高位溢出。</p><p>例如：a=1,a&lt;&lt;2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a：00000000 0000 0000 0000 0000 0000 000100</span><br><span class="line"></span><br><span class="line">  溢出                                    补0</span><br><span class="line"></span><br><span class="line">则a&lt;&lt;2：0000 0000 0000 0000 0000 0000 0000 0100</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  int a = 1;</span><br><span class="line"></span><br><span class="line">  printf(&quot;a=%d\n&quot;,a);</span><br><span class="line"></span><br><span class="line">  a = a &lt;&lt; 2;</span><br><span class="line"></span><br><span class="line">  printf(&quot;a&lt;&lt;2=%d\n&quot;,a);</span><br><span class="line"></span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右移（&gt;&gt;）分为逻辑右移和算术右移。逻辑右移是左边补0，右边舍弃。算术右移是最高位补符号位，右边舍弃。经常使用的是算术右移。</p><p>例如：a=1，a&gt;&gt;2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a: 000000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">补符号位                                   舍弃</span><br><span class="line"></span><br><span class="line">a&lt;&lt;2: 0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  int a = 1;</span><br><span class="line"></span><br><span class="line">  printf(&quot;a=%d\n&quot;,a);</span><br><span class="line"></span><br><span class="line">  a = a &gt;&gt; 2;</span><br><span class="line"></span><br><span class="line">  printf(&quot;a&gt;&gt;2=%d\n&quot;,a);</span><br><span class="line"></span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">位操作符有三种，分别是：与（&amp;）、或（|），异或（^）的原则进行计算。</span><br></pre></td></tr></table></figure><p>与（&amp;）就是两个数的补码，每位进行比较，按照有0则为0，同为1则是1的原则进行计算。</p><p>异或（^）就是两个数的补码，每位进行比较，按照相同为0，不同为1的原则进行计算。</p><p>先看下面这段例程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int a = 3;</span><br><span class="line"></span><br><span class="line">    int b = 5;</span><br><span class="line"></span><br><span class="line">    printf(&quot;a&amp;b=%d\n&quot;,a&amp;b);</span><br><span class="line"></span><br><span class="line">    printf(&quot;a|b=%d\n&quot;,a|b);</span><br><span class="line"></span><br><span class="line">    printf(&quot;a^b=%d\n&quot;,a^b);</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a的补码是:0000 0000 0000 00000000 0000 0000 0011</p><p>b的补码是:0000 0000 0000 0000 0000 0000 0000 0101</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">则    a&amp;b=0000 0000 0000 0000 0000 0000 00000001=1</span><br><span class="line"></span><br><span class="line">      a|b=0000 0000 0000 0000 0000 0000 0000 0111=7</span><br><span class="line"></span><br><span class="line">      a^b=0000 0000 0000 0000 0000 0000 0000 0110=6</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">赋值中包括就是我们常见的=，还包括复合赋值操作符有+=、-=、*=、/=、%=、&lt;&lt;=、&gt;&gt;=、&amp;=、^=、|=。</span><br></pre></td></tr></table></figure><p>a+=2表示a=a+2，即操作符两边的数先进行计算再将计算结果赋值到操作数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关系操作符有!=、&lt;=、&gt;=、==、&lt;、&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单目操作符有！、-、+、&amp;、sizeof、~、++、--、*。</span><br></pre></td></tr></table></figure><p>！表示非，例如！（2=2），2=2为真，则！（2=2）为假。</p><p>-表示操作数的负值，-1也就是我们所说的负数。</p><p>+表示操作数的正值，一般被省略。</p><p>&amp;表示操作数的地址，例如：</p><p>int a = 10;</p><p>int* b = &a;</p><p>sizeof用于计算该操作数或表达式的字节数，初学者会认为这是一个函数，这是一个误区。</p><p>~用于整型求补操作，即将该操作数的二进制进行转换，1变为0,0变为1。</p><p>++用于操作数的自加，每次加1，++a表示先自加在使用该操作数，a++表示先使用该操作数再进行自加。</p><p><em>表示间接访问操作符，在指针中使用。</em>a表示访问a指向的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑操作符有&amp;&amp;（和）和||（或）</span><br></pre></td></tr></table></figure><p>在这里需要注意的是要和位操作符进行区分：</p><p>和即所有条件为真且为真，一个条件为假就是假</p><p>或即一个为真即为真，全部为假才是假。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件操作符包括三个部分：a？b : c</span><br></pre></td></tr></table></figure><p>a为一个判断条件，若a为真则执行b语句，若a为假则执行c语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逗号操作符使用很频繁，逗号操作符把多个表达式分隔开，表达式从左往右依次计算。</span><br></pre></td></tr></table></figure><h2 id="寄语"><a href="#寄语" class="headerlink" title="寄语"></a>寄语</h2><p>　　可能关于操作符的叙述不是很详细，欢迎交流！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
