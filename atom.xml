<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bingoxin&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.bingoxin.top/"/>
  <updated>2018-12-13T11:35:30.458Z</updated>
  <id>http://www.bingoxin.top/</id>
  
  <author>
    <name>bingoxin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊天室项目</title>
    <link href="http://www.bingoxin.top/2019/01/04/%E8%81%8A%E5%A4%A9%E5%AE%A4%E9%A1%B9%E7%9B%AE/"/>
    <id>http://www.bingoxin.top/2019/01/04/聊天室项目/</id>
    <published>2019-01-04T07:27:52.000Z</published>
    <updated>2018-12-13T11:35:30.458Z</updated>
    
    <content type="html"><![CDATA[<p>socket需要有服务器端和客户端</p><p>客户端在连接服务器时，需要指定服务器的IP（标识电脑）和端口号（标识电脑上的具体某个应用）</p><p>通信的前提是：要创建基站，并与基站建立连接。 </p><a id="more"></a><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p><strong>Scoket类</strong></p><ul><li>绑定指定域名、端口号的服务器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Socket</span><span class="params">(String host, <span class="keyword">int</span> port, InetAddress localAddr,<span class="keyword">int</span> localPort)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>获取客户端输入流，读取服务器发来的消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>获取客户端输出流，向服务器发送消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> OutputStream <span class="title">getOutputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><h4 id="基站类—ServerSocket"><a href="#基站类—ServerSocket" class="headerlink" title="基站类—ServerSocket"></a>基站类—ServerSocket</h4><ul><li>默认绑定本地IP：127.0.0.1，以及指定端口号。在本机根据指定端口号创建服务器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>等待客户端连接，线程阻塞，当有客户连接时，返回客户端socket。侦听并接受连接到本服务的客户端连接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Socket <span class="title">accept</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>当服务器与客户端建立起连接后，通过输入输出流（客户端的Scoket）来通信</p><ul><li>获取服务器端输入流，读取客户端发来的消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>获取服务器端输出流，向客户端发送消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> OutputStream <span class="title">getOutputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="简单版的单线程聊天"><a href="#简单版的单线程聊天" class="headerlink" title="简单版的单线程聊天"></a>简单版的单线程聊天</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;socket需要有服务器端和客户端&lt;/p&gt;
&lt;p&gt;客户端在连接服务器时，需要指定服务器的IP（标识电脑）和端口号（标识电脑上的具体某个应用）&lt;/p&gt;
&lt;p&gt;通信的前提是：要创建基站，并与基站建立连接。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="项目" scheme="http://www.bingoxin.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://www.bingoxin.top/2019/01/03/JVM/"/>
    <id>http://www.bingoxin.top/2019/01/03/JVM/</id>
    <published>2019-01-03T13:10:46.000Z</published>
    <updated>2019-01-09T13:06:11.019Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机是通过软件模拟的具有完整硬件功能，运行在完全隔离环境中的计算机系统。</p><p>使用最多的是VMWare和Virtual Box。</p><p>JVM是通过软件<strong>模拟Java字节码指令集</strong>，JVM只保留了PC寄存器，而普遍的虚拟机有很多寄存器。</p><p>做JVM的公司有很多家，从<strong>JDK1.3</strong>开始，HotSpot为默认JVM。</p><p>JVM上<strong>不止可以运行Java的代码</strong></p><a id="more"></a><h3 id="JVM内存区域划分"><a href="#JVM内存区域划分" class="headerlink" title="JVM内存区域划分"></a>JVM内存区域划分</h3><p>Java内存区共分为6块内存</p><h4 id="线程私有内存"><a href="#线程私有内存" class="headerlink" title="线程私有内存"></a>线程私有内存</h4><p>每个线程都有，并且彼此之间相互隔离</p><ul><li>程序计数器</li></ul><p>程序计数器是比较小的内存空间，记录当前线程所执行的字节码的行号指示器。</p><p><strong>程序计数器记录的两种情况：</strong></p><p>1、若当前的线程执行的是Java方法，程序计数器记录的是正在执行的JVM字节码指令地址</p><p>2、若当前的执行线程执行的是Native方法，计数器值为空（监测不到C语言）</p><p>程序计数器是<strong>唯一一块不会产生OOM异常</strong>的区域</p><ul><li>虚拟机栈</li></ul><p>虚拟机栈描述Java<strong>方法</strong>执行的<strong>内存</strong>模型。</p><p>每个方法执行的同时，都会创建一个栈桢来存储<strong>局部变量表、操作数栈、方法出口</strong>等信息。每个方法从调用直到执行完毕的过程，对应一个栈桢在虚拟机栈的入栈和出栈过程。</p><p><strong>局部变量表存放内容：</strong>8种基本数据类型和对象引用（4个字节），因此每次开辟虚拟机栈桢的大小是确定的。</p><p>生命周期与线程相同：在创建线程时，同时创建线程的虚拟机栈。在线程执行完毕时，虚拟机栈也被一同回收。</p><p><strong>此区域一共会产生两种异常：</strong></p><p>1、若线程请求的栈深度大于JVM允许的深度（-Xss设置栈容量），抛出<code>StackOverFlowError</code>异常。常见于单线程</p><p>2、虚拟机在进行栈的动态扩展时，若无法申请到足够内存，抛出OOM（<code>OutOfMemoryError</code>）异常。常见于多线程</p><ul><li>本地方法栈</li></ul><p>本地方法（<code>Native</code>方法）执行的内存模型</p><p>在<strong>HotSpot虚拟机</strong>中，本地方法栈与虚拟机栈是同一块内存区域。</p><h4 id="线程共享内存"><a href="#线程共享内存" class="headerlink" title="线程共享内存"></a>线程共享内存</h4><p>所有线程共享此内存空间，并且此内存空间<strong>对所有线程可见</strong></p><ul><li>堆（GC堆）</li></ul><p>Java堆是JVM管理的最大内存区域。当JVM启动时创建。所有线程共享此内存，此内存中存放的都是数组和对象实例。</p><p>Java堆是垃圾回收器管理的最主要内存区域。Java堆可以处于物理上不连续的内存空间。-Xmx设置堆最大值，-Xms设置堆最小值</p><p><strong>异常：</strong>若在堆中没有足够的内存完成对象实例分配并且堆无法再次扩展时，抛出OOM异常</p><ul><li>方法区</li></ul><p>用于存储已被JVM加载的类信息、常量、静态变量等数据。JDK8以前，方法区也叫永久代。JDK8以后叫做元空间（Meta Space）</p><p>方法区无法满足内存分配需求时，抛出OOM</p><ul><li>运行时常量池</li></ul><p>运行时常量池是方法区的一部分，存放字面量与符号引用</p><p><strong>字面量：</strong>字符串常量（JDK7中移入堆中）、final常量、基本数据类型的值</p><p><strong>符号引用：</strong>类、字段、方法的完全限定名、名称、描述符</p><p>JVM内存区域划分-&gt;判断对象是否存活-&gt;垃圾回收算法-&gt;</p><h4 id="对象产生的过程"><a href="#对象产生的过程" class="headerlink" title="对象产生的过程"></a>对象产生的过程</h4><p>符号引用-&gt;类-&gt;具体引用 </p><p>根据符号引用去JVM方法区拿到该类的信息，然后再去堆中开辟空间</p><h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><p>OOM共有两种：内存溢出和内存泄漏</p><p><strong>内存泄漏：</strong>无用对象无法被垃圾回收，无法解决</p><p><strong>内存溢出：</strong></p><h3 id="垃圾回收器与内存分配策略"><a href="#垃圾回收器与内存分配策略" class="headerlink" title="垃圾回收器与内存分配策略"></a>垃圾回收器与内存分配策略</h3><h4 id="判断对象是否已死"><a href="#判断对象是否已死" class="headerlink" title="判断对象是否已死"></a>判断对象是否已死</h4><ul><li>引用计数法</li></ul><p>给每个对象附加一个引用计数器，每当有一个地方引用此对象时，计数器+1；每当有一个引用失效时，计数器-1；在任意时刻，只要计数器值为0的对象就是不能再被使用，即对象已死。</p><p>引用计数法实现简单，判定效率较高，但是无法解决循环引用问题。JVM并未采用此算法</p><p><code>-XX:+printGC</code>:查看垃圾处理装置</p><ul><li>可达性分析算法</li></ul><p>Java采用可达性分析算法来判断对象是否存活（C#也适用该算法）</p><p><strong>核心思想:</strong>通过一系列<code>GC Roots</code>的对象作为起点，从这些节点开始向下搜索对象，搜索走过的路径，称为“引用链”，当一个对象到任意一个GC Roots对象没有任何的引用链相连时（从GC Roots到对象不可达），证明此对象已死。</p><p><strong>Java中能作为GC Roots的对象包含以下四种：</strong></p><p>1、虚拟机栈中的引用对象</p><p>2、类静态变量引用的对象</p><p>3、本地方法栈中引用的对象</p><p>4、常量引用的对象</p><p><strong>JDK1.2之后对于引用的概念做了扩充：</strong></p><ul><li>强引用-StrongReference</li></ul><p>强引用指的是代码中普遍存在的，类似于Object obj = new Object();</p><p>在JVM中只要强引用还在，垃圾回收器永远不会回收此类对象的空间</p><ul><li>软引用-SoftReference</li></ul><p>软引用用来描述一些有用但不必须的对象，对于仅被软引用指向的对象，在系统将要发生内存溢出之前，会将<strong>所有软引用对象</strong>进行垃圾回收。若内存够用，这些对象仍然保留。在JDK1.2之后，提供了Soft Reference来实现软引用。</p><ul><li>弱引用-WeakReference</li></ul><p>弱引用用来描述一些有用但不必须的对象，但弱引用比软引用更差一点。仅被弱引用关联的对象最多只能生存到下一次GC开始之前。当垃圾回收器开始工作时，<strong>无论当前内存是否够用</strong>，都会回收掉仅被弱引用关联的对象。JDK1.2以后，使用WeakReference来实现弱引用</p><ul><li>虚引用-PhantomReference</li></ul><p>虚引用也称为幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在完全不会对其生存时间有影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是在这个对象被GC之前，收到一个系统通知。JDK1.2之后，提供PhantomReference来描述虚引用。</p><p><strong>为什么要有虚引用：</strong></p><p>在一个虚引用被垃圾回收之前，会收到一个通知来告诉JVM该虚引用对象将被销毁</p><h4 id="对象的自我拯救-finalize"><a href="#对象的自我拯救-finalize" class="headerlink" title="对象的自我拯救-finalize"></a>对象的自我拯救-finalize</h4><p>在可达性分析算法中不可达对象，也并非“非死不可”，所有不可达的对象处于缓刑阶段。要宣告一个对象的彻底死亡，需要经历两次标记过程：</p><p>若对象在进行可达性分析之后，发现到GC Roots不可达，此对象会进行一次筛选过程。</p><p><strong>筛选的条件</strong>是此对象是否有必要执行<code>finalize()</code>。当对象没有覆写<code>finalize()</code>或<code>finalize()</code>已被调用过，JVM会将此对象彻底宣判死亡。若筛选成功（对象覆写了<code>finalize()</code>，并且未被执行过），会将此对象放到F-Queue中</p><p>如果对象在finalize方法中成功自救（此对象与任意一个GC Roots建立联系），则对象在第二次标记时被移除回收集合，成功存活；若对象在finalize中仍然与GC Roots不可达，宣告死亡。</p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>方法区的回收主要回收两部分内容：废弃常量和无用的类</p><p><strong>判断常量是否被废弃的条件：</strong></p><p>常量未被引用</p><p><strong>判断一个类是无用类的条件：</strong></p><p>1、该类的所有实例都已经被回收，也就是在堆中不存在该类的任何实例。</p><p>2、加载该类的类加载器都被回收</p><p>3、该类的Class对象没有在任何其他地方被引用，也无法通过反射访问该类的所有内容</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><ul><li>算法核心思想：</li></ul><p>整个算法分为<strong>标记清除</strong>两个阶段：标记阶段标记出此次垃圾回收需要回收的对象，清除阶段一次性清除所有带标记对象。</p><p>如图所示：</p><p><img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.PNG"></p><ul><li>弊端</li></ul><p>1.效率上：标记与清除两个阶段的效率都不高</p><p>2.空间问题：标记清除算法会产生大量的不连续空间，若程序中需要分配较大连续对象时，由于空间碎片较多因此无法找到连续内存而不得不再次出发GC</p><h4 id="复制算法-新生代垃圾回收算法"><a href="#复制算法-新生代垃圾回收算法" class="headerlink" title="复制算法-新生代垃圾回收算法"></a>复制算法-新生代垃圾回收算法</h4><ul><li>核心思想</li></ul><p>将内存块按容量划分为大小相等的两块，每次只使用其中一块内存。当使用的内存需要垃圾回收时，会将此区域的所有存活对象一次性复制到保留区域，然后将使用的内存块一次清理掉。</p><p><img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.PNG"></p><ul><li>弊端</li></ul><p>复制算法最大的问题在于内存利用率太低，商用JVM都对复制算法做了改进</p><h4 id="JVM改进后的算法"><a href="#JVM改进后的算法" class="headerlink" title="JVM改进后的算法"></a>JVM改进后的算法</h4><p>新生代中98%的对象都是“朝生夕死”（存活时间短），所以并不需要按照1:1来划分内存空间。将内存（新生代内存）分为一块较大的Eden（伊甸园）和两块较小的Survivor（幸存者空间，大小一样，一块称为From区，一块称为To区）空间。每次只使用Eden和其中一块Survivor区域。（默认比例8:1:1）</p><ul><li>HotSpot复制算法流程</li></ul><p>1.当Eden区满的时候，会触发一次垃圾垃圾回收，将所有的存活对象拷贝到From区域中，然后一次性清除Eden区；当Eden区再次触发Minor GC，会扫描Eden区的From区，将这两块空间中的存活对象拷贝到To区，而后一次性清除Eden区的From区的不存活对象</p><p>2.当后续Eden区再次发生Minor GC时，会对Eden和To区进行回收，存活对象移动到From区，后续流程类似，只是将From和To区来回作为保留区域</p><p>3.部分对象会在From与To区域中来回复制，如此交换15次（MaxTenuringThreshold,默认为15）最终会存入老年代</p><p><img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/%E5%8D%87%E7%BA%A7%E7%89%88.png"></p><p>Survivor区域若无法放下所有存活对象，需要依赖其他内存（肉老年代）</p><h4 id="标记整理算法—老年代GC算法"><a href="#标记整理算法—老年代GC算法" class="headerlink" title="标记整理算法—老年代GC算法"></a>标记整理算法—老年代GC算法</h4><p>老年代中对象存活率很高，因此不适用复制算法（需要大量进行对象的复制过程，效率很低）</p><ul><li>算法思想</li></ul><p>算法分为标记与整理两个阶段。标记过程与标记清除过程一致，整理过程需要让所有存活对象向一端移动，而后直接清理掉存活对象边界以外的内存</p><h4 id="分代回收算法"><a href="#分代回收算法" class="headerlink" title="分代回收算法"></a>分代回收算法</h4><ul><li>算法核心思想</li></ul><p>根据对象的存活周期将内存分为以下两块</p><p>新生代：每次GC都有大批对象死去，只有少量存活，因此采用复制算法</p><p>老年代：对象存活率较高，没有额外空间对其分配担保，采用标记整理算法</p><h4 id="Minor-FullGC"><a href="#Minor-FullGC" class="headerlink" title="Minor FullGC"></a>Minor FullGC</h4><p>1.MinorGC称为新生代GC：指的是发生在新生代的垃圾回收。由于新生代对象大多存活周期较短，因此MinorGC发生频率非常频繁，一般回收速度较高</p><p>2.Full GC称为老年代GC或Major GC</p><p>GC：指的是发生在老年代的垃圾回收，出现了Major</p><p>GC通常会伴随至少一次的Minor GC（并非绝对）。一般Full GC比Minor GC慢10倍以上，发生频率较低</p><h3 id="垃圾收集器（垃圾回收算法的具体实现）-JDK8"><a href="#垃圾收集器（垃圾回收算法的具体实现）-JDK8" class="headerlink" title="垃圾收集器（垃圾回收算法的具体实现）-JDK8"></a>垃圾收集器（垃圾回收算法的具体实现）-JDK8</h3><ul><li>串行</li></ul><p>垃圾回收线程与用户线程在JVM中顺序执行</p><ul><li>并行</li></ul><p>垃圾回收线程一起执行，用户线程仍处于等待状态</p><ul><li>并发</li></ul><p>垃圾回收线程与用户线程一起执行</p><ul><li>STW</li></ul><p>当垃圾回收线程工作时，用户线程处于等待状态</p><p><strong>新生代垃圾回收器：</strong></p><p>Serial（串行收集器）、ParNew（并行）、parallel Scavenge（并行）</p><p><strong>老年代垃圾回收器：</strong></p><p>CMS（并发）、Serial Old（串行）、Parallel Old（并行）</p><p>全区域垃圾回收器：G1（并发）</p><h3 id="对象分配策略"><a href="#对象分配策略" class="headerlink" title="对象分配策略"></a>对象分配策略</h3><h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>大多数情况下，对象在新生代Eden区分配。当Eden区没有足够的空间分配时，JVM发生一次Minor GC</p><p><code>-Xmn</code>:新生代内存大小</p><p><code>-XX:SurvivorRatio = 8</code>:改变分配比例</p><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p><code>-XX:PretenureSizeThreshold = 字节大小</code>对象超过规定大小就将对象放入老年代</p><h4 id="长期存活对象进入老年代"><a href="#长期存活对象进入老年代" class="headerlink" title="长期存活对象进入老年代"></a>长期存活对象进入老年代</h4><p>JVM给每个对象定义了一个对象年龄的计数器，若对象在Eden去出生并且经历一次Minor GC后，仍然存活并且能被Survivor容纳，将此对象的年龄置为1，此后对象每再Survivor区域中经历一次Minor GC，年龄就增加一岁。当其年龄增加到一定程度（默认为15），此对象晋升到老年代</p><p><code>-XX:MaxTenuringThreshold = 15</code>设置晋升到老年代的大小</p><h4 id="动态年龄判定"><a href="#动态年龄判定" class="headerlink" title="动态年龄判定"></a>动态年龄判定</h4><p>JVM并不是永远要求对象的年龄必须达到MaxTenuringThreshold规定的值，才能晋升老年代。若Survivor空间中相同年龄的所有对象大小的总和和大于Survivor空间的一半，此时年龄大于等于该年龄的所有对象直接进入老年代，无须等到MaxTenuringThreshold要求的年龄</p><h3 id="JDK命令行工具"><a href="#JDK命令行工具" class="headerlink" title="JDK命令行工具"></a>JDK命令行工具</h3><ul><li>jps***</li></ul><p><strong>JVM进程状态工具</strong></p><p>列出正在运行的JVM进程，并返回进程ID</p><p>常用参数：<code>-l</code> 输出主类的全名称，返回进程ID</p><ul><li>jstat</li></ul><p>JVM统计信息监视工具，显示本地或远程JVM中类装载、内存、垃圾回收等数据</p><p><code>jstat -gcutil PID</code>:显示垃圾回收信息</p><ul><li>jinfo</li></ul><p>JVM配置信息查看工具</p><p><code>jinfo -flags PID</code></p><ul><li>jmap***</li></ul><p>内存映像工具</p><p>jmap用于生成堆转储快照（堆得快照）</p><p><code>jmap -heap PID</code>：显示JVM堆具体信息</p><p><code>jmap -histo PID</code>:显示JVM中对象的统计信息</p><ul><li>jhat</li></ul><p>heap文件的分析工具</p><p><code>jhat heap文件路径</code></p><ul><li>jstack***</li></ul><p>Java栈跟踪工具</p><p>jstack生成当前JVM线程的快照。</p><p>可用于定位线程出现长时间停顿的原因</p><h3 id="Java内存模型—JMM"><a href="#Java内存模型—JMM" class="headerlink" title="Java内存模型—JMM"></a>Java内存模型—JMM</h3><p>Java内存模型是基于线程的，JMM定义的主要目标是为了定义程序中各个变量的访问规则（JVM中如何将变量从内存中取出以及如何将变量再写回内存的细节）。此处的变量包括实例字段、静态字段与数组元素</p><h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><p>主内存是所有线程共享的，而工作内存指的是每个线程独有的</p><p>JMM规定<strong>所有变量必须存储在主内存</strong>中。每条线程都有自己的工作内存，工作内存中保存了该线程使用到的变量的主内存副本。线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，不能直接读写主内存中的变量。不同线程之间也无法直接访问彼此的工作内存变量，线程间变量值的传递均需要通过主内存来完成。</p><h4 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h4><p><strong>JMM内存三大特性：</strong></p><ul><li>原子性</li></ul><p>基本数据类型的访问读写是具有原子性，如若需要更大范围的原子性，需要内键锁或lock体系的支持（i++、i–等操作）</p><ul><li>可见性</li></ul><p>当一个线程修改了共享变量的值，其他线程能够立即得知此修改。volatile、final、synchronized可以实现可见性</p><ul><li>有序性</li></ul><p>如果在本线程内观察，所有操作都是有序的；若在线程之外观察另外一个线程，所有操作都是无序的</p><p>JMM具备先天的有序性，即无须通过任何手段就能保证的有序性。称为JMM的happens-before原则。若两个操作的次序无法从happens-before中推导出来，则无法保证其有序性，JVM可以随意对其重排序。</p><p>要想并发程序正确执行，必须同时保证原子性、可见性以及有序性。只要有任意一个没有被保证，就有可能导致程序运行不正确</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</p><ul><li>保证此变量对所有线程的可见性</li></ul><p>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。普通变量无法做到可见性。</p><p>volatile变量在各个线程中是一致的，但是volatile变量的运算在并发下一样是不安全的。Java中运算操作并非原子性操作，必须结合内键锁或lock体系来约束。</p><ul><li>由于volatile变量只保证可见性，在不符合一下两条规则的场景下，仍然需要使用加锁来保证原子性：</li></ul><p>1.运算结果不依赖当前变量的值，或者能够确保只有单一的线程修改变量值</p><p>2.变量不需要与其他的状态变量共同参与不变约束</p><ul><li>并发场景下对于类似i++操作如何保证程序的正确结果：</li></ul><p>1、加锁</p><p>2、使用原子类（java.util.concurrent.atomic包下的所有类-内部使用CAS保证原子性）</p><ul><li>禁止指令重排（内存屏障）</li></ul><p>1.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作更改肯定全部已经执行完毕且结果已经对后面的操作可见，在其后面的操作肯定还没有执行</p><p>2.在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能提前执行</p><h4 id="懒汉式单例的线程安全问题"><a href="#懒汉式单例的线程安全问题" class="headerlink" title="懒汉式单例的线程安全问题"></a>懒汉式单例的线程安全问题</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虚拟机是通过软件模拟的具有完整硬件功能，运行在完全隔离环境中的计算机系统。&lt;/p&gt;
&lt;p&gt;使用最多的是VMWare和Virtual Box。&lt;/p&gt;
&lt;p&gt;JVM是通过软件&lt;strong&gt;模拟Java字节码指令集&lt;/strong&gt;，JVM只保留了PC寄存器，而普遍的虚拟机有很多寄存器。&lt;/p&gt;
&lt;p&gt;做JVM的公司有很多家，从&lt;strong&gt;JDK1.3&lt;/strong&gt;开始，HotSpot为默认JVM。&lt;/p&gt;
&lt;p&gt;JVM上&lt;strong&gt;不止可以运行Java的代码&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
      <category term="JVM" scheme="http://www.bingoxin.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深浅拷贝</title>
    <link href="http://www.bingoxin.top/2019/01/03/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://www.bingoxin.top/2019/01/03/深浅拷贝/</id>
    <published>2019-01-03T10:37:30.000Z</published>
    <updated>2019-01-03T14:13:59.364Z</updated>
    
    <content type="html"><![CDATA[<h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><p>拷贝的执行函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><p>并不是所有的类都可以被拷贝，需实现<code>Cloneable</code>接口，并且在类中自定义<code>clone()</code>调用Object类提供的继承权限<code>clone()</code></p><p>若不实现Cloneable接口，在调用<code>clone()</code>时，会抛出CloneNotSupportedException异常。</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>对于浅拷贝而言，拷贝出来的对象仍然保留原对象的所有引用。</p><p>只要拷贝对象和原对象中引用的属性发生改变，其所有的该引用属性都会发生改变</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>对于深拷贝而言，拷贝出来的对象会产生新的对象。</p><p>对于拷贝的原对象和拷贝出来的对象来说，改变一个引用的属性，互不影响</p><p>对象中包含的引用只是自定义引用</p><h3 id="如何实现深拷贝"><a href="#如何实现深拷贝" class="headerlink" title="如何实现深拷贝"></a>如何实现深拷贝</h3><p>1.包含的其他类继续实现Cloneable接口，并且调用<code>clone()</code></p><p>2*.实现序列化</p><h4 id="调用clone"><a href="#调用clone" class="headerlink" title="调用clone()"></a>调用<code>clone()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baby</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Baby&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Baby <span class="title">clone</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        Baby baby = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            baby =(Baby) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Baby</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line">    <span class="keyword">public</span> Baby baby;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Monkey</span><span class="params">(String name, Integer age, Baby baby)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.baby = baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Monkey&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", baby="</span> + baby +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Baby <span class="title">getBaby</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBaby</span><span class="params">(Baby baby)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baby = baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Monkey <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Monkey monkey = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            monkey = (Monkey) <span class="keyword">super</span>.clone();</span><br><span class="line">            monkey.baby = <span class="keyword">this</span>.baby.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> monkey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Baby baby = <span class="keyword">new</span> Baby(<span class="string">"zxh"</span>,<span class="number">3</span>);</span><br><span class="line">        Monkey monkey = <span class="keyword">new</span> Monkey(<span class="string">"zh"</span>,<span class="number">88</span>,baby);</span><br><span class="line"></span><br><span class="line">        Monkey monkey1 = monkey.clone();</span><br><span class="line">        System.out.println(monkey1);</span><br><span class="line">System.out.println(monkey.baby == monkey1.baby);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><ul><li>概念</li></ul><p>将内存中保存的对象变为二进制流，进行输出或保存在文本中，即将对象变为二进制流。<br>若类要实现序列化，必须实现<code>Serializable</code>接口</p><p>Serializable接口为标识接口，只有实现了Serializable接口的类，才具备对象序列化的功能。</p><p>但要具体实现序列化和反序列化需要使用IO包中提供的两个处理类：ObjectOutputStream（序列化）、ObjectInputStream（反序列化）</p><ul><li>ObjectOutputStream（序列化）</li></ul><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectOutputStream</span><span class="params">(OutputStream out)</span></span>;</span><br></pre></td></tr></table></figure><p>将文件转化为二进制流输出到终端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writeObject(Object obj);</span><br></pre></td></tr></table></figure><p>例程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Monkey</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Monkey&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\pxx\\Desktop"</span> + <span class="string">"\\1.txt"</span>);</span><br><span class="line">        Monkey monkey = <span class="keyword">new</span> Monkey(<span class="string">"zh"</span>,<span class="number">99</span>);</span><br><span class="line">        OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(outputStream);</span><br><span class="line">        oos.writeObject(monkey);</span><br><span class="line">        oos.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>transient</code>关键字</p><p>若希望类中的若干属性不被序列化，可以在属性前添加该关键字</p></li><li><p>ObjectInputStream(反序列化)</p></li></ul><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectInputStream</span><span class="params">(InputStream in)</span></span>;</span><br></pre></td></tr></table></figure><p>将文件中的二进制流输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readObject(Object obj);</span><br></pre></td></tr></table></figure><h4 id="使用序列化实现深拷贝"><a href="#使用序列化实现深拷贝" class="headerlink" title="使用序列化实现深拷贝"></a>使用序列化实现深拷贝</h4><p>使用序列化进行深拷贝时，无须实现Cloneable接口，而需要实现Serializable接口</p><p>用序列化实现上一例程的拷贝Monkey对象的功能，代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public Monkey ObjectClone()&#123;</span><br><span class="line"></span><br><span class="line">        OutputStream outputStream = new ByteOutputStream();</span><br><span class="line">        Monkey monkey = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(outputStream);</span><br><span class="line"></span><br><span class="line">            oos.writeObject(this);</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            InputStream bis = new ByteInputStream(((ByteOutputStream) outputStream).getBytes(),((ByteOutputStream) outputStream).size());</span><br><span class="line">            ObjectInputStream ois = new ObjectInputStream(bis);</span><br><span class="line"></span><br><span class="line">            monkey = (Monkey) ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line">            bis.close();</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return monkey;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;深浅拷贝&quot;&gt;&lt;a href=&quot;#深浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;深浅拷贝&quot;&gt;&lt;/a&gt;深浅拷贝&lt;/h3&gt;&lt;p&gt;拷贝的执行函数&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>网络基础概念理解</title>
    <link href="http://www.bingoxin.top/2018/12/25/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
    <id>http://www.bingoxin.top/2018/12/25/网络基础概念理解/</id>
    <published>2018-12-25T09:20:25.000Z</published>
    <updated>2019-01-02T13:50:37.345Z</updated>
    
    <content type="html"><![CDATA[<p>总是听到身边的人说局域网，那么局域网到底是什么呢？</p><p>如何将一个数据发送到另一台主机呢？</p><p>操作系统是如何知道网卡中有数据发来呢？</p><p>请接下这篇博客<a id="more"></a></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="局域网与公网"><a href="#局域网与公网" class="headerlink" title="局域网与公网"></a>局域网与公网</h3><ul><li><p>局域网概念—LAN</p><p>局域网指在某一区域内由多台计算机互联成的计算机组，应用在局部范围内，例如我们家里或者学校使用的无线网</p></li></ul><p>我们使用的WIFI也叫WLAN，即无线局域网。</p><p>在同一局域网内，两台主机可以直接通信</p><ul><li><p>广域网—WAN</p><p>广域网是连接不同地区局域网或城域网计算机通信的远程网，通常跨接很大的物理范围，例如我们使用的阿里云服务器</p></li></ul><p>公网接入方式：上网的计算机得到的IP地址是Internet上的非保留地址，公网的计算机和Internet上的其他计算机可随意互相访问。</p><p>任何一台在局域网上的主机，在不欠费的情况下，是可以访问公网上的服务器的</p><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>协议就像是一种约定，而网络协议也可以被理解为是在网络上的一种约定</p><ul><li>协议分层</li></ul><p>例如，两个人在打电话，这个通信过程可以将其分为两部分：通信工具和人。</p><p>当中国人和中国人打电话时，两人均使用汉语进行沟通，当其中一人使用电话进行通话时，两人依然可以正常沟通。再或者，其中一个中国人给一个英国人打电话时，两人还是可以用英语进行交流。</p><p>这也可以说明了分层的<strong>好处</strong>：其中一层发生改变整体不受影响，即分层可以更好的解耦</p><p>在分层这里要注意：同层之间才可以通信</p><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总是听到身边的人说局域网，那么局域网到底是什么呢？&lt;/p&gt;
&lt;p&gt;如何将一个数据发送到另一台主机呢？&lt;/p&gt;
&lt;p&gt;操作系统是如何知道网卡中有数据发来呢？&lt;/p&gt;
&lt;p&gt;请接下这篇博客
    
    </summary>
    
    
      <category term="操作系统和网络" scheme="http://www.bingoxin.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java中的抽象类与接口</title>
    <link href="http://www.bingoxin.top/2018/12/24/java%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
    <id>http://www.bingoxin.top/2018/12/24/java中的抽象类与接口/</id>
    <published>2018-12-24T12:13:33.000Z</published>
    <updated>2018-12-24T12:14:11.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抽象类的定义"><a href="#抽象类的定义" class="headerlink" title="抽象类的定义"></a>抽象类的定义</h3><p>抽象类只是比普通类多了一些抽象方法</p><ul><li>抽象方法</li></ul><p>只声明而未实现的方法（没有方法体），抽象方法必须使用abstract关键字类定义。并且抽象方法所在的类也一定要使用abstract来定义</p><a id="more"></a><ul><li>抽象类使用原则</li></ul><blockquote><p>a.所有抽象类必须有子类（final与abstract不能同时使用）</p><p>b.抽象类的子类必须覆写抽象类的所有抽象方法（private与abstract不能同时使用）</p><p>c.抽象类无法直接创建实例化对象，需要通过子类向上转型为其实例化</p></blockquote><ul><li>抽象类相关约定</li></ul><blockquote><p>a.抽象类一定存在构造方法，子类也一定遵循对象实例化流程。先调用父类构造再调用子类构造</p><p>b.抽象类可以没有任何抽象方法，但此时仍然不能直接创建实例化对象</p><p>c.private与abstract不能同时使用</p><p>d.final与abstract不能同时使用</p><p>e.关于内部抽象类：子类只需要覆写外部抽象类中的直接抽象方法即可。内部抽象类的抽象方法可不覆写，若要覆写内部类的抽象方法，需在子类中写一个内部类来继承父类中的内部类，再对父类内部类进行覆写</p></blockquote><h3 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h3><ul><li>设计模式</li></ul><p>解耦，引入一个第三方来解耦（高内聚，低耦合）</p><ul><li>开闭原则（OCP）</li></ul><p>一个软件实体如类、模块或函数应该对扩展开放，对修改关闭</p><ul><li>模板设计模式—基于抽象类</li></ul><p>在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板设计模式可以使得子类在不改变算法的前提下，重新定义算法中的某些步骤</p><p>请看下面的程序：</p><p>制作一杯茶和制作一杯咖啡从步骤上来看是很像的</p><p><strong>制作一杯茶</strong></p><blockquote><p>1.烧开水</p><p>2.把茶包浸泡在水中</p><p>3.把茶水导入杯子里</p><p>4.加入柠檬</p></blockquote><p><strong>制作一杯咖啡</strong></p><blockquote><p>1.烧开水</p><p>2.冲泡咖啡</p><p>3.把咖啡导入杯子里</p><p>4.加入牛奶和糖</p></blockquote><p>我们可以发现制作两种饮品时第一步和第三步是相同的，茶和咖啡可以统称为咖啡因饮品。因此可以定义一个基类成员方法包括以上四种，这四种可以统称为准备饮品，则定义一个方法依次调用四个步骤为准备饮品。让咖啡喝茶继承基类，并对第二步和第四步进行覆写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">//导入输入类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CaffeineBeverage</span></span>&#123;</span><br><span class="line">    <span class="comment">//准备饮料</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareRecipe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        boilWater();<span class="comment">//烧开水</span></span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="keyword">if</span>(customerWantsCondiments())&#123;</span><br><span class="line">            addCondiments();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在烧水"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pourInCup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"把饮料倒进杯子里"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">customerWantsCondiments</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        CaffeineBeverage caff = <span class="keyword">new</span> Coffee();</span><br><span class="line">        caff.prepareRecipe();</span><br><span class="line">        CaffeineBeverage caff1 = <span class="keyword">new</span> Tea();</span><br><span class="line">        caff1.prepareRecipe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">CaffeineBeverage</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"冲泡咖啡"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"加入牛奶和糖"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">customerWantsCondiments</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"是否要加东西？y/n"</span>);</span><br><span class="line">        String answer = <span class="keyword">null</span>;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        answer = scanner.nextLine();</span><br><span class="line">        <span class="keyword">if</span>(answer.equals(<span class="string">"y"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">extends</span> <span class="title">CaffeineBeverage</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"浸泡茶包"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加入柠檬"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;抽象类的定义&quot;&gt;&lt;a href=&quot;#抽象类的定义&quot; class=&quot;headerlink&quot; title=&quot;抽象类的定义&quot;&gt;&lt;/a&gt;抽象类的定义&lt;/h3&gt;&lt;p&gt;抽象类只是比普通类多了一些抽象方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只声明而未实现的方法（没有方法体），抽象方法必须使用abstract关键字类定义。并且抽象方法所在的类也一定要使用abstract来定义&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的类集</title>
    <link href="http://www.bingoxin.top/2018/12/21/Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E9%9B%86/"/>
    <id>http://www.bingoxin.top/2018/12/21/Java中的类集/</id>
    <published>2018-12-21T14:44:51.000Z</published>
    <updated>2019-01-08T13:53:41.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java类集"><a href="#Java类集" class="headerlink" title="Java类集"></a>Java类集</h1><p>Java类集就是动态数组，类集的使用比较容易操作，但是类集的底层需要用到数据结构和多线程</p><p>所有的类集都在java.util包下<a id="more"></a></p><h3 id="Java类集的产生"><a href="#Java类集的产生" class="headerlink" title="Java类集的产生"></a>Java类集的产生</h3><p>Java类集是从JDK1.2开始应用的，用于解决数组定长问题</p><ul><li>Collection接口—<strong>单个对象</strong>保存的最顶层父接口</li></ul><p>Collection接口以及其子接口，在每次进行数据操作时只能对单个对象进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Iterable&lt;E&gt;</code>:迭代器接口（用于遍历集合）</p><p><code>Interface&lt;E&gt; iterator()</code>：取得集合的迭代器，JDK1.5之前没有泛型，则迭代器直接写在Collection接口中</p><ul><li>Collection接口中提供的核心方法</li></ul><p><strong>向类集中添加元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>取得接口的迭代器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Collection 接口只定义了存储数据的标准，但是无法区分存储类型。因此在实际中我们往往是由两个子接口List（允许数据重复）、Set（不允许数据重复）一般不直接使用Collection接口</p><h2 id="List接口—允许数据重复"><a href="#List接口—允许数据重复" class="headerlink" title="List接口—允许数据重复"></a>List接口—允许数据重复</h2><p>在进行单个集合处理时，优先考虑List接口</p><p>在List接口中，拓展了两个重要方法（List独有）</p><ul><li>根据索引取得下标数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>根据索引下标更改数据，返回原来的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br></pre></td></tr></table></figure><p>List接口有三个重要子类：ArrayList、Vector、LinkedList</p><p>List接口要想保存自定义类的对象，该类必须覆写<code>equals()</code>来使用<code>contains()</code>、<code>remove()</code></p><h3 id="ArrayList-Vector-LinkedList的区别"><a href="#ArrayList-Vector-LinkedList的区别" class="headerlink" title="ArrayList/Vector/LinkedList的区别"></a>ArrayList/Vector/LinkedList的区别</h3><ul><li>ArrayList与Vector的区别</li></ul><p>1、<strong>出现版本：</strong>ArrayList 在JDK1.2版本才出现，Vector在JDK1.0版本就已经出现</p><p>2、<strong>调用无参构造的区别：</strong>Vector在无参构造执行后将对象数组大小初始化为10，ArrayList采用懒加载策略，在构造方法阶段并不初始化数组，在第一次添加元素时才会初始化数组，大小为10</p><p>3、<strong>扩容策略：</strong>ArrayList在扩容时，会扩容到原来长度的1.5倍；Vector在扩容时，会扩容到原来的两倍</p><p>4、<strong>线程的安全性：</strong>ArrayList采用异步处理，线程不安全，效率较高；Vector采用在方法上加锁，线程安全，效率更低。（即便要使用线程安全的List也不使用Vector）</p><p>5、<strong>遍历：</strong>Vector支持较老的迭代器；ArrayList不支持</p><ul><li>ArrayList与Vector的共同点</li></ul><p>底层都使用数组实现，且都是List的子类</p><ul><li>ArrayList与LinkedList的区别</li></ul><p>LinkedList底层是双向链表，ArrayList的底层是数组</p><h2 id="Set接口—不允许数据重复"><a href="#Set接口—不允许数据重复" class="headerlink" title="Set接口—不允许数据重复"></a>Set接口—不允许数据重复</h2><p>Set接口没有扩充方法，常用子类有<code>HashSet</code>(无序存储)和<code>TreeSet</code>(有序存储)</p><p>Set接口本质上就是Map接口，Set就是value值都为PRESENT的Map</p><h3 id="Comparable接口与Comparator接口"><a href="#Comparable接口与Comparator接口" class="headerlink" title="Comparable接口与Comparator接口"></a>Comparable接口与Comparator接口</h3><ul><li>Comparable接口</li></ul><p>在Java中，若实现自定义类的比较，提供了一下两个接口：</p><p>java.lang.Comparable接口（内部比较器）:若一个类实现了Comparable接口，就表示该类可以进行比较并排序的。存放该类的Conllection或数组，可以直接通过<code>Collection.sort()</code>或Array.sort进行排序</p><p>实现了Comparable接口的类可以直接存放在TreeSet或TreeMap中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>返回值三种情况：</p><p>返回正数：当前对象大于目标对象</p><p>返回负数：当前对象小于目标对象</p><p>返回0：当前对象等于目标对象</p><ul><li>Comparator接口</li></ul><p>Comparator是外部排序接口</p><p>若要控制某个自定义类的顺序，而该类本身不支持排序—实现Comparator接口，覆写compareTo方法或实现一个比较器传入TreeSet或TreeMap中进行比较即可。</p><p>实现了Comparator接口的类作为比较器，通过该比较器来进行类排序，具有两个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1,T o2)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值与compareTo返回值完全一样</p><p>返回正数，o1&gt;o2</p><p>返回负数，o1&lt;o2</p><p>返回0，o1=o2</p><p>实现<code>Comparator</code>接口进行第三方排序—策略模式，此方法更加灵活，可以轻松改变策略进行第三方的排序方法</p><ul><li>Comparable接口与Comparator接口的关系</li></ul><p>Comparable是排序接口，若一个类实现了Comparable接口，意味着该类支持排序，是一个内部比较器（自己去和别人比）</p><p>Comparator接口是比较器接口，类本身不支持排序，专门有若干个第三方的比较器（实现了Comparator接口的类）来进行类排序，是一个外部比较器</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>底层是由哈希表和红黑树，允许存放null，无序储存</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>底层使用红黑树，不允许空值出现，允许储存</p><p>保存自定义类需实现Comparable接口或者传入比较器（compartor接口）</p><h3 id="HashSet和TreeSet的区别"><a href="#HashSet和TreeSet的区别" class="headerlink" title="HashSet和TreeSet的区别"></a>HashSet和TreeSet的区别</h3><p>1、<strong>底层实现不同：</strong>HashSet底层是由哈希表和红黑树，允许存放null，无序储存；TreeSet底层使用红黑树，不允许空值出现，允许储存</p><h3 id="重复元素比较"><a href="#重复元素比较" class="headerlink" title="重复元素比较"></a>重复元素比较</h3><p>TreeSet与TreeMap依靠Comparator或Comparable接口来区别重复元素</p><p>HashMap和HashSet不依赖比较接口，可以通过同时覆写其<code>equals()</code>和<code>HashCode()</code>方法来区分</p><p><strong>元素比较步骤：</strong></p><p>1、调用<code>hashCode()</code>计算出对象hash码决定存放的hash桶</p><p>2、使用<code>equals()</code>方法来判定两个元素内容是否相等，若相等，则不放置元素，若不相等，则在相同桶之后将元素链起来</p><p>object类内置的<code>hashCode()</code>是默认比较对象的地址转为hash码</p><p>两个对象<code>equals()</code>方法返回true，他们的hashCode必然保持相等，</p><p>两个对象的hashCode相等，不能保证他们的<code>equals()</code>一定相等，当且仅当hashCode和equals都返回true是，才说明两个对象都相等</p><ul><li>覆写<code>equals()</code>方法原则</li></ul><blockquote><p>自反性：对于任何非空引用值x，<code>x.equals(x)</code>都返回true</p><p>对称性：对于任何非空的x,y,当且仅当<code>x.equals(y)</code>返回true，<code>y.equals(x)</code>返回true</p><p>传递性：对于任何非空的x,y,z,当<code>x.equals(y)</code>返回true，<code>y.equals(z)</code>返回true,才有<code>x.equals(z)</code>返回true</p><p>一致性：对于任何非空的x,y,若x与y中属性没有变，则多次调用<code>equals()</code>方法，都返回true或false</p><p>非空性：对于任何非空引用值x，<code>x.equlas(null)</code>，返回false</p></blockquote><h3 id="集合输出—迭代器Iterator输出"><a href="#集合输出—迭代器Iterator输出" class="headerlink" title="集合输出—迭代器Iterator输出"></a>集合输出—迭代器Iterator输出</h3><ul><li>迭代输出—Collection接口支持</li></ul><p><strong>Iterator的两个核心方法</strong></p><p>判断是否还有元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>取得下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>单向迭代输出</strong></p><p>调用Collection集合子类的Iterator方法取得内置的迭代器，使用一下输出格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双向迭代输出</strong>–ListIterator</p><p>除了<code>hasNext</code>与<code>next</code>方法外还有：</p><p>判断是否有上一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasPrevious();</span><br></pre></td></tr></table></figure><p>取得上一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">previous();</span><br></pre></td></tr></table></figure><p>要想从后向前遍历，首先至少要从前向后遍历一次才可使用</p><ul><li>Enumeration枚举输出—Vector类支持</li></ul><p>判断是否有下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasMoreElements();</span><br></pre></td></tr></table></figure><p>取得下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextElement();</span><br></pre></td></tr></table></figure><ul><li>for-each输出</li></ul><p>能使用for-each的本质是各个集合类都内置了迭代器</p><ul><li>fail-fast机制</li></ul><p>ConcurrentModificationException发生在Collection集合使用迭代器遍历时，使用了集合类提供的修改集合内容方法报错。而如果使用Iterator迭代器的<code>remove()</code>不会出现此类错误</p><p>Collection集合中的modCount表示当前集合修改的次数</p><p>exceptedModCount是迭代器中记录当前集合的修改次数</p><p>当取得集合迭代器时，调用<code>new Itr()</code>会执行expectedModCount = ModCount，换言之，迭代器就是当前集合的一个副本</p><p>快速失败策略保证了所有用户在进行迭代遍历集合时，拿到的数据一定是最新的数据（避免脏读产生）</p><ul><li>fail-safe</li></ul><p>不产生ConcurrentModificationException异常，juc包下的所有线程安全集合（CopyOnWriteArrayList）</p><p><strong>以后再迭代器遍历时，不要修改集合的内容</strong></p><h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><p>Map接口是Java中保存二元偶对象的最顶层接口</p><p>Map中key值唯一，即通过可以值就可以找到对应的value值</p><ul><li>核心方法</li></ul><p>向Map中添加数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key,V value)</span></span>;</span><br></pre></td></tr></table></figure><p>根据指定的key值取得相应的value值，若没有key值，返回null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>;</span><br></pre></td></tr></table></figure><p>将Map集合变为Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure><p>返回所有key值集合，key不能重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>返回所有value值，value可以重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Map接口常用子类：HashMap、TreeMap、Hashtable、ConcurrentHashMap</p><ul><li>类比HashMap与Hashtable</li></ul><p>1、<strong>key和value的取值：</strong>HashMap的key值和value值可以取null，而Hashtable中key和value均不能取value值</p><p>2、<strong>出现的版本不同：</strong>JDK1.2产生了HashMap，JDK1.0就产生了Hashtable</p><p>3、<strong>线程安全问题：</strong>HashMap采用异步处理，线程不安全但是效率高，Hashtable采用同步处理，线程安全，效率低</p><p>4、<strong>底层实现：</strong>HashMap的底层是用哈希表和红黑树实现的，Hashtable的底层是用哈希表实现的</p><h4 id="Map集合使用迭代器输出"><a href="#Map集合使用迭代器输出" class="headerlink" title="Map集合使用迭代器输出"></a>Map集合使用迭代器输出</h4><ul><li>将Map集合转为Set集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure><h4 id="Collection与Map的储存方式"><a href="#Collection与Map的储存方式" class="headerlink" title="Collection与Map的储存方式"></a>Collection与Map的储存方式</h4><p>两者都是以对象为单位进行储存的</p><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><ul><li>栈—先入后出</li></ul><p>函数栈桢，浏览器标签页的后退，安卓Activity的后腿，编辑器撤销</p><p><strong>面试题：自己实现一个html识别器</strong></p><ul><li>队列—先入先出</li></ul><p>消息队列：kafka，RobitMQ</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>Queue接口：</p><p>入队列：<code>add()</code></p><p>出队列：<code>poll()</code></p><p>返回队列头元素，不出队：<code>peek()</code></p><h3 id="属性文件操作—资源（Properties）文件操作"><a href="#属性文件操作—资源（Properties）文件操作" class="headerlink" title="属性文件操作—资源（Properties）文件操作"></a>属性文件操作—资源（Properties）文件操作</h3><p>Java中有一种特殊的文件是以<code>.properties</code>为后缀的文件，资源文件的内容都是K,V模式的，并且K和Value都是String类型</p><ul><li>设置属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">setProperty</span><span class="params">(String key,String Value)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>取得属性,若没有指定key值，返回null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>若没有指定key值，返回默认值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getProperty(String key,String defaultValue);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java类集&quot;&gt;&lt;a href=&quot;#Java类集&quot; class=&quot;headerlink&quot; title=&quot;Java类集&quot;&gt;&lt;/a&gt;Java类集&lt;/h1&gt;&lt;p&gt;Java类集就是动态数组，类集的使用比较容易操作，但是类集的底层需要用到数据结构和多线程&lt;/p&gt;
&lt;p&gt;所有的类集都在java.util包下
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDBC</title>
    <link href="http://www.bingoxin.top/2018/12/20/JDBC/"/>
    <id>http://www.bingoxin.top/2018/12/20/JDBC/</id>
    <published>2018-12-20T06:20:21.000Z</published>
    <updated>2019-01-02T12:58:41.473Z</updated>
    
    <content type="html"><![CDATA[<p>现在的应用系统大多都离不开数据库，而Java程序访问数据库的基本方式是通过JDBC。</p><p>Java Database Connectivity，Java数据库连接。</p><p>用于执行SQL语句的Java API</p><p>JDBC使用流程如下：</p><p><img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JDBC/%E6%8D%95%E8%8E%B7.PNG"></p><a id="more"></a><h3 id="JDBC的使用"><a href="#JDBC的使用" class="headerlink" title="JDBC的使用"></a>JDBC的使用</h3><ul><li>加载JDBC驱动程序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br></pre></td></tr></table></figure><ul><li>建立数据库连接</li></ul><p>代码格式：jdbc:{数据库的名称}://host:port/databaseName?param1=value&amp;param2=value2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/memo? user=root&amp;password=root&amp;useUnicode=true&amp;characterEncoding=UTF-8"</span>);</span><br></pre></td></tr></table></figure><ul><li>创建操作命令（statement）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement statement = connection.createStatement();</span><br></pre></td></tr></table></figure><ul><li>执行SQL语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">            ResultSet resultSet = statement.executeQuery(sql);</span><br></pre></td></tr></table></figure><ul><li>处理结果集</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">                String title = resultSet.getString(<span class="string">"ename"</span>);</span><br><span class="line">                System.out.println(id == resultSet.getInt(<span class="string">"empno"</span>));</span><br><span class="line">                System.out.println(String.format(<span class="string">"id = %d,title = %s"</span>, id, title));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ul><li>释放资源（关闭结果集，命令，连接）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭结果集</span></span><br><span class="line"><span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        resultSet.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; &#125; </span><br><span class="line"><span class="comment">//关闭命令</span></span><br><span class="line"><span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        statement.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; &#125;</span><br><span class="line"><span class="comment">//关闭连接命令</span></span><br><span class="line"><span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();    </span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="Statement对象"><a href="#Statement对象" class="headerlink" title="Statement对象"></a>Statement对象</h3><p>用于将SQL语句发送到数据库中，JDBC API中主要提供了三种Statement对象</p><ul><li>Statement</li></ul><p>用于执行不带参数的简单SQL语句</p><p>SQL语句通过拼接字符串来实现，该方式效率比较低，系统会自动将该字符串定义为StringBuilder，拼接时调用<code>append()</code>方法</p><ul><li>PreparedStatement</li></ul><p>用于执行带或者不带参数的SQL语句</p><p>SQL语句会预编译在数据库系统</p><p>执行速度快于Statement对象</p><ul><li>CallableStatement</li></ul><p>用于执行数据库存储过程的调用</p><p>实际开发中最常用的是PreparedStatement，其具有以下优点：</p><blockquote><p>1、性能比Statement高（拼接字符串效率较低）</p><p>2、参数化SQL查询</p><p>3、占位符不能使用多值，占位符下标从1开始</p><p>4、SQL预编译</p><p>5、阻止常用SQL注入攻击</p></blockquote><p><strong>SQL两种执行方法：</strong></p><p>方法执行后返回单个结果集的，通常用于select语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executeQuery()</span><br></pre></td></tr></table></figure><p>方法返回值是一个整数，指示受影响的行数，通常用于update、insert、delete</p><h3 id="ResultSet对象"><a href="#ResultSet对象" class="headerlink" title="ResultSet对象"></a>ResultSet对象</h3><p>ResultSet对象被称为结果集，表示符合SQL语句执行结果的所有行，并且提供了一套<code>getXXX()</code>方法提供了对这些行中数据的访问。ResultSet就像一个迭代器，其所指的数据行叫做当前数据行。</p><p>取得某一条记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet.next()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在的应用系统大多都离不开数据库，而Java程序访问数据库的基本方式是通过JDBC。&lt;/p&gt;
&lt;p&gt;Java Database Connectivity，Java数据库连接。&lt;/p&gt;
&lt;p&gt;用于执行SQL语句的Java API&lt;/p&gt;
&lt;p&gt;JDBC使用流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JDBC/%E6%8D%95%E8%8E%B7.PNG&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://www.bingoxin.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="http://www.bingoxin.top/2018/12/16/%E8%BF%9B%E7%A8%8B/"/>
    <id>http://www.bingoxin.top/2018/12/16/进程/</id>
    <published>2018-12-16T12:03:24.000Z</published>
    <updated>2018-12-17T12:04:18.854Z</updated>
    
    <content type="html"><![CDATA[<h3 id="冯诺依曼体系结构"><a href="#冯诺依曼体系结构" class="headerlink" title="冯诺依曼体系结构"></a>冯诺依曼体系结构</h3><ul><li>组成</li></ul><p>包括输入单元、输入设备、存储器、运算器、控制器、输出单元、输出设备</p><p>存储器更多指的是内存</p><ul><li>关于冯诺依曼</li></ul><p>a.CPU只能对内存进行读写，不能访问外设</p><p>b.外设要读入或输出数据，只能写入内存或者从内存中读取，即所有外设只能和内存打交道</p><a id="more"></a><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li>概念</li></ul><p>操作系统包括：内核(进程管理、内存管理、文件管理、驱动管理)和其他程序(函数库、shell程序等)</p><ul><li>设计操作系统的目的</li></ul><p>a.与硬件交互，管理所有的软件和硬件</p><p>b.为用户提供一个良好的执行环境</p><ul><li>管理的概念</li></ul><p>即先将被管理对象描述起来，再将被管理对象组织起来</p><p>假如硬盘中存着一个程序，对程序进行编译后会生成一个可执行文件，而这个可执行文件就会加载到内存中供操作系统读取，但在内存中的仅仅是代码和数据。一个程序会生成一个进程，那么在操作系统中就会维护一个结构体(PCB)，结构体中该程序的属性。操作系统中不只有一个进程，那么就会产生多个结构体，为了方便管理，使用链表来将这些结构体连接起来，这是操作系统只需要知道该链表的头结点。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程之间是互相<strong>独立</strong>的，虽然代码有可能相同，但是各个进程都在维护各自的数据，因此进程之间是互不干扰的</p><ul><li>进程的控制块—PCB</li></ul><p>PCB包含一些字段，字段中包含程序的数据</p><ul><li>进程的字段</li></ul><p>pid（唯一标识符）、优先级、状态、</p><ul><li>进程的状态</li></ul><p>在不同的操作系统中，进程的状态是不同的</p><blockquote><ul><li><p><strong>R</strong>(unning)—可执行状态</p></li><li><p><strong>S</strong>(leep)—休眠状态</p></li><li><p><strong>T</strong>(stop)—停止状态</p></li><li><p><strong>D</strong>(isk sleep)—深度睡眠，不会被杀死</p></li><li><p><strong>X</strong>(dead)—死亡状态</p></li><li><p><strong>Z</strong>(zombie)—僵尸状态(进程已经退出，但仍保留该进程的信息，僵尸进程过多会导致内存泄漏问题)</p></li></ul></blockquote><ul><li>进程并发—进程间切换</li></ul><p>在一段时间内，多个进程在同一个CPU下采用进程切换的方式进行，让多个进程都得以推进</p><ul><li>进程并行</li></ul><p>同一时刻，多个进程在多个CPU下分别进行</p><ul><li>硬件上下文</li></ul><p>进程在运行期间在CPU寄存器上产生的数据</p><p>切换的时候将数据保存，返回时被恢复</p><p>硬件上下文被保存在PCB中</p><ul><li>查看进程的两种方式</li></ul><p>1.ps axj</p><p>2.查看proc目录</p><ul><li>获取pid的方法</li></ul><p>有pid就能实现进程调度</p><p><strong>获取当前进程pid：</strong> <code>getpid()</code></p><p><strong>获取父进程pid：</strong> <code>getppid()</code></p><ul><li>外壳程序</li></ul><p>操作系统通过外壳向用户传输数据，用户通过外壳向操作系统输入数据</p><blockquote><p>Windows系统的外壳是：窗口界面</p><p>Linux系统的外壳是：终端命令行</p></blockquote><p>shell：外壳程序的统称</p><p>bash（命令行解释器）：本身就是进程，为Linux系统下的父进程，可以创建子进程</p><ul><li>创建子进程</li></ul><p>关键字：fork（系统调用）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> id = fork();  <span class="comment">//当id = 0时，表示创建子进程成功，当id &gt; 0时，表示正在进行父进程，id为子进程的pid</span></span><br></pre></td></tr></table></figure><p>fork之后创建的子进程的代码是从父进程继承来的，即代码时共享的，但数据时各自私有的（写时拷贝）。因为代码是相同的，子进程的PCB中的内容大部分是和父进程PCB中的内容是一样的</p><ul><li>孤儿进程</li></ul><p>父进程提前退出，而子进程还在，子进程就会被1号进程领养，即子进程的ppid = 1</p><ul><li>修改进程</li></ul><p>关键字：kill</p><p>查看kill手册：<code>kill -l</code></p><h3 id="进程的优先级（PRI）"><a href="#进程的优先级（PRI）" class="headerlink" title="进程的优先级（PRI）"></a>进程的优先级（PRI）</h3><ul><li>取值范围：60~99</li></ul><p><strong>优先级值越小越早被执行，值越小进程优先级越高</strong></p><ul><li><strong>查看优先级命令：</strong>ps -l</li></ul><p>操作系统会在链表中找优先级最高的进程，只要该程序的状态是非r状态，操作系统将其对应的代码块放在CPU上执行</p><p>由于可能同时进行多个进程，若挨个查找链表中的结构体会浪费太多时间，则操作系统会有两条链表，一条用于存放r状态的进程（可执行队列），一条用于存放非r状态的进程</p><ul><li><strong>修正值nice</strong></li></ul><p>取值范围：-20~19</p><p>PRI（new） =PRI（OLD）+nice(修正值)</p><ul><li><strong>renice</strong>—修改nice的值</li></ul><p><code>sudo renice 修改值 -p pid</code> </p><ul><li><strong>nice</strong>—在进程开始进行时，指明优先级</li></ul><p><code>sudo nice -n 修改值</code></p><ul><li><strong>top</strong></li></ul><p>输入top-&gt;按 r-&gt;输入进程pid-&gt;输入nice值</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul><li>概念</li></ul><p>在操作系统中，用来指定操作系统运行环境的一些参数</p><ul><li>常见环境变量</li></ul><blockquote><p>PATH:命令搜索路径</p><p>HOME:指定用户的主工作目录</p><p>HISTSIZE:保存历史命令记录的条数</p><p>SHELL:当前shell，通常是bash</p></blockquote><p>ls是一个环境变量，它是一个二进制可执行程序，之所以它可以在任何路径下都可以使用，是因为它是被放在PATH下，PATH是什么呢？这是你可以在操作系统中输入<code>echo $PATH</code>你会得到一串路径，也就是说，当你把可执行文件放在这一串路径中的其中一个里，这个可执行文件就可以在任何路径下执行。</p><ul><li>如何让一个可执行文件可以在任何路径下都可以执行呢</li></ul><p>a.把可执行文件放在PATH中的一个路径下</p><p>b.将可执行文件的路径放在PATH中，使用命令<code>PATH=$PATH:可执行文件所在路径</code></p><h3 id="程序的地址空间"><a href="#程序的地址空间" class="headerlink" title="程序的地址空间"></a>程序的地址空间</h3><ul><li>虚拟地址空间</li></ul><p>每个进程都会创建一个PCB，每个PCB都会指向一个虚拟地址空间</p><ul><li>物理内存</li></ul><p>进程的代码和数据最终被写在物理内存中</p><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>目前所接触到创建进程的方式有两种：使用fork()函数、执行一个程序</p><p>当一个进程被创建时，操作系统会为该进程维护一个结构体（PCB），PCB中有该进程的属性。而每个PCB都会指向一个虚拟地址空间，虚拟地址空间中保存着进程的代码和数据。当一个进程和其子进程同时开始运行时，操作系统会为这两个进程维护一个数据结构—叫做页表，页表的功能是：将虚拟地址空间里的内容映射到物理内存中去。而此时，物理内存中就会有进程的代码和数据由于两个进程的代码是共享的，因此在物理内存中两个进程的代码映射区相同，而其数据不同。这也就是<strong>写时拷贝</strong>。</p><h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><p>退出的情况共有三种：代码运行完毕且结果正确，代码执行完毕但结果不对，代码异常终止</p><ul><li>判断结果是否正确</li></ul><p>使用<code>echo $?</code>，查看进程退出码</p><p>可以使用的方法:<code>_exit()</code>、<code>exit()</code>、return</p><ul><li><code>_exit()</code></li></ul><p><code>void _exit(int status)</code>status定义了进程终止状态，父进程可以通过<code>wait()</code>来获取该值（status只有低八位可以被父进程使用）</p><ul><li><code>exit()</code></li></ul><p>也可以结束进程，与<code>_exit()</code>的区别是：<code>exit()</code>会关闭流和刷新缓冲区，<code>_exit()</code>直接将进程关闭</p><p>进程终止时，释放数据结构，保留PCB中的数据，那么此时进程的状态就为僵尸进程</p><h3 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h3><p>若父进程不管理子进程，子进程若编程僵尸进程，这是父进程就没办法将该进程kill掉，从而造成内存泄漏。父进程需要知道子进程是否正常退出，而进程的退出有三种，又该如何判断呢？</p><ul><li><code>wait()</code></li></ul><p><code>pid_t wait(int* status)</code></p><p>若该进程成功结束，则返回该进程的pid，否则返回-1</p><p>参数为子进程退出状态</p><ul><li><code>waitpid()</code></li></ul><p><code>pid-t waitpid(pid_t pid,int* status,int options)</code></p><p>正常返回时，返回子进程的pid</p><ul><li><p>status</p><p>status的低八位为进程的退出码，第七位为该进程的结束信号，当退出信号为0，说明代码执行完但结果不对</p></li></ul><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><ul><li>概念</li></ul><p>守护进程是在后台运行的一种特殊进程，独立于控制终端且周期性的执行任务或等待处理任务，则守护进程不受用户登录注销的影响。</p><ul><li>守护进程经常采用以d结尾的名字</li><li>TPGID一栏写着-1的都是守护进程</li></ul><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;冯诺依曼体系结构&quot;&gt;&lt;a href=&quot;#冯诺依曼体系结构&quot; class=&quot;headerlink&quot; title=&quot;冯诺依曼体系结构&quot;&gt;&lt;/a&gt;冯诺依曼体系结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;组成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;包括输入单元、输入设备、存储器、运算器、控制器、输出单元、输出设备&lt;/p&gt;
&lt;p&gt;存储器更多指的是内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于冯诺依曼&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;a.CPU只能对内存进行读写，不能访问外设&lt;/p&gt;
&lt;p&gt;b.外设要读入或输出数据，只能写入内存或者从内存中读取，即所有外设只能和内存打交道&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.bingoxin.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java中的模块与包</title>
    <link href="http://www.bingoxin.top/2018/10/29/Java%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"/>
    <id>http://www.bingoxin.top/2018/10/29/Java中的模块与包/</id>
    <published>2018-10-29T12:21:15.000Z</published>
    <updated>2018-12-30T12:21:45.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="包的定义与使用"><a href="#包的定义与使用" class="headerlink" title="包的定义与使用"></a>包的定义与使用</h3><p>包就是文件夹</p><p>在源文件首行<code>package 包名称</code></p><ul><li>打包编译命令</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d . Test.java</span><br></pre></td></tr></table></figure><p>-d ：根据package定义的包名称创建生成目录</p><p>.：在当前目录下生成</p><ul><li>执行命令</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java www.bit.java.Test</span><br></pre></td></tr></table></figure><ul><li>自动打包 编译命令（将当前路径下所有源文件按照主类的使用情况自动编译）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d . .<span class="comment">/*.java</span></span><br></pre></td></tr></table></figure><h3 id="关键字default"><a href="#关键字default" class="headerlink" title="关键字default"></a>关键字default</h3><ul><li>包访问权限</li></ul><p>定义：本包下的所有源文件可以互相调用属性与方法</p><ul><li>常用包</li></ul><p><strong>java.lang:</strong>系统常用基础类（Object、String(sb)、包装类）</p><p>此包在JDK1.1之后自动导入</p><p><strong>java.util:</strong>java提供的工具程序包，类集（ArrayList、HashMap）</p><p><strong>java.util.concurrent</strong></p><p>在JDK1.8中，接口中的方法用default修饰，方法可以有方法体</p><h3 id="继承访问权限—protected"><a href="#继承访问权限—protected" class="headerlink" title="继承访问权限—protected"></a>继承访问权限—protected</h3><h3 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h3><p><strong>Error：</strong>描述Java运行时内部错误与资源耗尽错误。这种内部错误一旦出现，除了告知用户并使程序安全终止之外，再无能为力</p><p><strong>Exception：</strong>（程序出错）</p><p><strong>TOException：</strong>程序本身没有问题，由于IO处理导致的程序错误</p><p><strong>RuntimeException：</strong>由于程序错误导致的</p><p><strong>非受查异常：</strong>所有继承与Error或RuntimeException的异常类称为非受查异常（不需要强制处理）</p><p><strong>受查异常：</strong>所有继承于Exception与IOException的类成为受查异常类（需要强制处理）</p><ul><li>异常处理格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    code</span><br><span class="line">&#125;[<span class="keyword">catch</span>(异常类 对象)]&#123;</span><br><span class="line">    出异常的操作</span><br><span class="line">&#125;[<span class="keyword">finally</span>]&#123;</span><br><span class="line">    异常出口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>常用异常格式</li></ul><p>try…catch…</p><p>try…finally…</p><p>try…catch…finally…</p><p>无论是否产生异常，无论try、catch是否返回语句，最终都会执行finally块</p><p><strong>打印错误堆栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.printStackTrace();</span><br></pre></td></tr></table></figure><ul><li>throws关键字</li></ul><p>在进行方法定义时，如果要明确告诉调用者本方法可能产生哪些异常，可以使用throws方法进行声明，表示将异常抛回给调用方。并且当方法出现问题后可以不进行处理</p><ul><li>throw关键字—用在方法中</li></ul><p>throw语句直接用在方法中，表示人为进行异常的抛出，一般与自定义的异常类搭配使用</p><p>如果异常类对象不希望由JVM产生而通过用户产生，就可以使用throw语句来完成</p><p>例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 1).定义一个MulException类继承Exception类，要求两数相乘等于100报错，在主类中定义一个方法，在方法中抛出此异常，在主方法观察结果。</span></span><br><span class="line"><span class="comment"> * 2).定义一个DivException类继承RuntimeException类，要求两数相除等于2报错，在主类中定义一个方法，在方法中抛出此异常，在主方法观察结果。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MulException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MulException</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DivException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DivException</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                test();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            test1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Exception是受查异常，必须强制处理</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(i*j == <span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MulException(<span class="string">"两数相乘等于100"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">if</span>(x/y == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> DivException(<span class="string">"两数相除不能等于2"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>启动断言需要使用-ea参数手工开启，默认不开启断言，属于Error</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;包的定义与使用&quot;&gt;&lt;a href=&quot;#包的定义与使用&quot; class=&quot;headerlink&quot; title=&quot;包的定义与使用&quot;&gt;&lt;/a&gt;包的定义与使用&lt;/h3&gt;&lt;p&gt;包就是文件夹&lt;/p&gt;
&lt;p&gt;在源文件首行&lt;code&gt;package 包名称&lt;/code&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的三大设计模式</title>
    <link href="http://www.bingoxin.top/2018/10/28/Java%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.bingoxin.top/2018/10/28/Java中的三大设计模式/</id>
    <published>2018-10-28T12:19:22.000Z</published>
    <updated>2018-12-29T12:19:59.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>将客户端的new操作解耦到第三方（工厂类）</p><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><ul><li>特点</li></ul><blockquote><p>a.拥有具体的产品类</p><p>b.多个具体产品类</p><p>c.一个工厂—&gt;new操作在此工厂中进行，客户端通过工厂类获取具体实例</p></blockquote><a id="more"></a><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><ul><li>概念</li></ul><p>定义一个用来创建对象的接口，让子类决定实例化哪一个类</p><p>针对每个产品（产品族）提供一个共产类，客户端需要判断使用哪个工厂</p><ul><li>特点</li></ul><p>横向扩展方便</p><blockquote><p>a.一个抽象产品类</p><p>b.多个具体产品类</p><p>c.一个针对产品类的抽象工厂</p><p>d.多个具体工厂（每个产品家族拥有自己的工厂）</p></blockquote><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ul><li>特点</li></ul><p>两个子类共同实现同一个接口，其中一个子类负责真实业务实现，另一个子类完成辅助真实业务主题的操作</p><h3 id="开发时注意："><a href="#开发时注意：" class="headerlink" title="开发时注意："></a>开发时注意：</h3><p>1.接口是Java的核心，慢慢会学到接口更多的使用与设计</p><p>2.开发之中优先考虑接口，以避免单继承局限</p><p>3.抽象类是模板，有层次感；接口更关心行为与混合</p><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><ul><li>特点</li></ul><p>一个类只允许产生一个实例化对象</p><blockquote><p>构造方法私有化</p><p>在类内部实现对象的实例化</p><p>使用getter方法创建对象</p></blockquote><p><strong>饿汉式单例：</strong>先new为敬</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleEx</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleEx singleEx = <span class="keyword">new</span> SingleEx();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleEx</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleEx <span class="title">getSingleEx</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getSingle"</span>);</span><br><span class="line">        <span class="keyword">return</span> singleEx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingleEx singleEx =SingleEx.getSingleEx();</span><br><span class="line">        System.out.println(singleEx);</span><br><span class="line">        SingleEx singleEx1 =SingleEx.getSingleEx();</span><br><span class="line">        System.out.println(singleEx1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>懒汉式单例：</strong>用时再new</p><p>只是实例化时机与饿汉式不同，懒汉式单例存在线程安全问题（双重加锁单例模式）</p><h3 id="多例模式"><a href="#多例模式" class="headerlink" title="多例模式"></a>多例模式</h3><p>多例模式只是比单例模式多了一些内部实例化对象而已</p><p>无论是单例还是多例：</p><p>a.构造方法私有化</p><p>b.类内部提供静态方法返回有限个数对象</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h3&gt;&lt;p&gt;将客户端的new操作解耦到第三方（工厂类）&lt;/p&gt;
&lt;h4 id=&quot;简单工厂&quot;&gt;&lt;a href=&quot;#简单工厂&quot; class=&quot;headerlink&quot; title=&quot;简单工厂&quot;&gt;&lt;/a&gt;简单工厂&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;特点&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;a.拥有具体的产品类&lt;/p&gt;
&lt;p&gt;b.多个具体产品类&lt;/p&gt;
&lt;p&gt;c.一个工厂—&amp;gt;new操作在此工厂中进行，客户端通过工厂类获取具体实例&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的String类</title>
    <link href="http://www.bingoxin.top/2018/10/27/Java%E4%B8%AD%E7%9A%84String%E7%B1%BB/"/>
    <id>http://www.bingoxin.top/2018/10/27/Java中的String类/</id>
    <published>2018-10-27T12:16:33.000Z</published>
    <updated>2018-12-27T12:17:48.183Z</updated>
    
    <content type="html"><![CDATA[<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><ul><li>String的两种实例化方式</li></ul><p>a.直接赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String string = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><p>b.通过构造方法构造实例化对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String string = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>字符串相等比较</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"hello"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(str1 == str2);</span><br></pre></td></tr></table></figure><p>输出结果为：false</p><p>“==”是对两个数据的值进行比较，则语句3其实是str1的内容与str2的地址进行比较的，因此结果为false。</p><p>若要对两个String类进行比较，应该使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1.equals(str2);</span><br></pre></td></tr></table></figure><ul><li>字符串的常量是String类的匿名对象</li></ul><p>“hello”是一个String类的匿名对象</p><p>请看一下两个案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(<span class="string">"hello"</span>.equals(str));</span><br></pre></td></tr></table></figure><p>结果输出为：false</p><p>因为str没有指向的变量，也就和”hello”不相等了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(str.equals(<span class="string">"hello"</span>));</span><br></pre></td></tr></table></figure><p>输出结果为：空指针异常</p><p><strong>在使用equals方法时需注意：</strong></p><p>判断String类匿名对象与实例化对象是否相等时，需使用案例一，即将字符串常量写在前面</p><ul><li>String类使用共享设计模式</li></ul><p>在JVM底层自动维护一个字符串对象池（对象数组）</p><p>如果采用直接赋值的模式进行String类的对象实例化操作，此对象将自动保存到对象池中，如果下次继续采用直接赋值的模式声明String对象，先去对象池中找是否有指定内容，如果有，直接引用；如果没有，开辟新的空间而后将其保存到对象池中，以供下次使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(str1 == str2);</span><br><span class="line">System.out.println(str == str2);</span><br><span class="line">System.out.println(str1 == str);</span><br></pre></td></tr></table></figure><p>运行结果为：</p><p>ture</p><p>ture</p><p>ture</p><ul><li>字符串的手工入池操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"hello"</span>).intern();</span><br></pre></td></tr></table></figure><ul><li>String类中两种对象实例化的区别</li></ul><p><strong>直接赋值：</strong>只会开辟一块堆内存空间，并且该字符串对象可以自动保存在对象池中以供下次使用</p><p><strong>构造方法：</strong>会开辟两块堆内存空间，其中一块成为垃圾空间，不会自动保存到对象池中，但可以使用<code>intern()</code>方法手工入池</p><ul><li>字符串常量不可变更</li></ul><p>字符串一旦定义后不可改变</p><ul><li>字符串使用原则</li></ul><p>1.字符串使用就采用直接赋值</p><p>2.字符串比较就使用equals()实现</p><p>3.字符串改变别太多</p><ul><li>字符与字符串</li></ul><p>1.字符数组转为字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span> <span class="params">(<span class="keyword">int</span> []value)</span></span>;</span><br></pre></td></tr></table></figure><p>2.将字符串按照索引转为单个字符</p><p>String -&gt; char</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">//返回指定索引下标的字符</span></span></span><br></pre></td></tr></table></figure><p>3.将字符串转为字符数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray()</span><br></pre></td></tr></table></figure><ul><li>字节数组与字符串</li></ul><p>用String类的构造方法将字节数组转成字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span></span><br></pre></td></tr></table></figure><p>将字符串转为字节数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(String charset);</span><br></pre></td></tr></table></figure><ul><li>字符串比较</li></ul><p><strong>相等比较</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1.equals(str2)</span><br></pre></td></tr></table></figure><p><strong>不区分大小写的比较</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String str2)</span></span></span><br></pre></td></tr></table></figure><p><strong>两个字符串的关系</strong></p><p>>0：表示本字符串大于目标字符串</p><p>&lt;0：表示本字符串小于目标字符串</p><p>=0：表示本字符串等于目标字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String str2)</span></span></span><br></pre></td></tr></table></figure><ul><li>字符串查找</li></ul><p>从一个完整的字符串之中判断指定内容是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String str)</span><span class="comment">//对象方法</span></span></span><br></pre></td></tr></table></figure><p>判断是否以指定的字符串开头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String str)</span><span class="comment">//起始位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix,<span class="keyword">int</span> offset)</span><span class="comment">//偏移量为offset的位置开始</span></span></span><br></pre></td></tr></table></figure><p>判断是否以指定字符串结尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String str)</span></span></span><br></pre></td></tr></table></figure><ul><li>字符串替换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String regex,String replacement)</span></span></span><br><span class="line"><span class="function">例：</span></span><br><span class="line"><span class="function">str.<span class="title">replaceAll</span><span class="params">(<span class="string">"l"</span>,<span class="string">"_"</span>)</span>:将str中的所有l换成_</span></span><br></pre></td></tr></table></figure><ul><li>字符串拆分</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex)</span><br><span class="line"><span class="keyword">public</span> String[] split(String regex,<span class="keyword">int</span> limit)<span class="comment">//将字符串拆分成数组长度为limit的子字符串数组</span></span><br></pre></td></tr></table></figure><p>请看下面的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"129.168.1.1"</span>;</span><br><span class="line">String result = str.split(<span class="string">"."</span>);</span><br><span class="line"><span class="keyword">for</span>(str temp:result)&#123;</span><br><span class="line">    System.out.print(temp+<span class="string">"、"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其输出结果为：</p><p>即没有输出。</p><p>而我们想要的的结果是：129、168、1、1</p><p>在这里我们要注意，”.”在Java语言中表示类的引用，其为特殊字符，因此需要转义</p><p>如一下程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"129.168.1.1"</span>;</span><br><span class="line">String result = str.split(<span class="string">"\\."</span>);</span><br><span class="line"><span class="keyword">for</span>(str temp:result)&#123;</span><br><span class="line">    System.out.print(temp+<span class="string">"、"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来请看两次截取的一段程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"Lisa:18|Tom:20"</span>;</span><br><span class="line">        String[] result = str.split(<span class="string">"\\|"</span>);</span><br><span class="line">        <span class="keyword">for</span>(String temp:result)&#123;</span><br><span class="line">            String name = temp.split(<span class="string">":"</span>)[<span class="number">0</span>];</span><br><span class="line">            String age = temp.split(<span class="string">":"</span>)[<span class="number">1</span>];</span><br><span class="line">            System.out.println(<span class="string">"姓名："</span>+name);</span><br><span class="line">            System.out.println(<span class="string">"年龄:"</span>+age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>特殊字符需要转义后拆分</strong></p><ul><li>字符串截取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span><span class="comment">//从指定索引截取到结尾</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex,<span class="keyword">int</span> endIndex)</span><span class="comment">//从指定索引截取部分内容,左闭右开</span></span></span><br></pre></td></tr></table></figure><ul><li>去除字符串的左右空格，保留中间空格</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>字符串转大小写</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">()</span></span>;<span class="comment">//字符串全部转为大写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">()</span></span>;<span class="comment">//字符串全部转为小写</span></span><br></pre></td></tr></table></figure><ul><li>判断字符串是否为空字符串，不判断null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h3><ul><li>字符串拼接方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(各种数据类型)</span></span></span><br></pre></td></tr></table></figure><ul><li>StringBuffer与String类的相互转换</li></ul><p><strong>StringBuffer-&gt;String</strong></p><p>调用StringBuffer的构造方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> StringBuffer(<span class="string">"str"</span>);</span><br></pre></td></tr></table></figure><p><strong>String-&gt;StringBuffer</strong></p><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer.toString()</span><br></pre></td></tr></table></figure><ul><li>字符串反转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reverse():StringBuffer</span><br></pre></td></tr></table></figure><ul><li>删除（修改）指定范围的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="keyword">int</span> start,<span class="keyword">int</span> end):StringBuffer</span><br><span class="line">insert(<span class="keyword">int</span> offset,各种数据类型):StringBuffer</span><br></pre></td></tr></table></figure><ul><li>String、StringBuffer、StringBuilder的区别</li></ul><p>1.String内容不可改变，StringBuffer、StringBuilder内容可以改变</p><p>2.StringBuffer JDK1.0，采用同步处理，线程安全，效率较低</p><p>StringBuilder(JDK1.5)，采用同步处理，线程不安全，效率高，当在String对象进行“+”，编译时会将String类变成StringBuilder进行append()处理</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;String类&quot;&gt;&lt;a href=&quot;#String类&quot; class=&quot;headerlink&quot; title=&quot;String类&quot;&gt;&lt;/a&gt;String类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;String的两种实例化方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;a.直接赋值&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String string = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;b.通过构造方法构造实例化对象&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String string = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中接口定义与应用</title>
    <link href="http://www.bingoxin.top/2018/10/24/Java%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>http://www.bingoxin.top/2018/10/24/Java中接口定义与应用/</id>
    <published>2018-10-24T12:15:13.000Z</published>
    <updated>2018-12-24T12:15:42.589Z</updated>
    
    <content type="html"><![CDATA[<h3 id="接口的定义及使用"><a href="#接口的定义及使用" class="headerlink" title="接口的定义及使用"></a>接口的定义及使用</h3><ul><li>接口优先原则</li></ul><p>在一个操作既可以使用抽象类又可以使用接口的时候，优先考虑使用接口</p><ul><li>接口的概念</li></ul><p>接口就是抽象方法与全局常量的集合（纯粹版的抽象类），interface关键字定义接口</p><a id="more"></a><ul><li>接口命名规则</li></ul><p>使用I开头</p><ul><li>接口的继承</li></ul><p>子类要想使用接口，<code>implements</code>实现接口，一个子类可以同时实现多个父接口（避免单继承局限）</p><ul><li>子类命名规范</li></ul><p>接口名为IMyInterFace，子类实现此接口命名为MyInterFaceImpl</p><p>父接口间的相互转换：前提是两个父接口拥有共同的实现子类</p><ul><li>接口使用限制</li></ul><p>接口中只允许public权限（不管是方法还是常量，即便不写修饰权限也是public）</p><ul><li>阿里编码规约</li></ul><p>接口中不要出现任何修饰符号，public也不要加</p><ul><li>子类接口与继承</li></ul><p>当子类既需要接口又需要继承抽象类时，请先使用extends继承一个抽象类，而后使用implements实现多个接口</p><ul><li>抽象类与接口</li></ul><p>一个抽象类可以使用implements实现多个接口，接口不能继承抽象类</p><ul><li>接口的继承</li></ul><p>一个抽象类可以使用implements实现多个接口，接口不能继承抽象类</p><ul><li>接口的应用</li></ul><blockquote><p>a.定义操作标准</p><p>b.表示能力</p><p>c.分布式开发之中暴露远程服务方法</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;接口的定义及使用&quot;&gt;&lt;a href=&quot;#接口的定义及使用&quot; class=&quot;headerlink&quot; title=&quot;接口的定义及使用&quot;&gt;&lt;/a&gt;接口的定义及使用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;接口优先原则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在一个操作既可以使用抽象类又可以使用接口的时候，优先考虑使用接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口的概念&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接口就是抽象方法与全局常量的集合（纯粹版的抽象类），interface关键字定义接口&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的内部类</title>
    <link href="http://www.bingoxin.top/2018/10/19/Java%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://www.bingoxin.top/2018/10/19/Java中的内部类/</id>
    <published>2018-10-19T12:11:54.000Z</published>
    <updated>2018-12-22T12:12:45.931Z</updated>
    
    <content type="html"><![CDATA[<ul><li>定义</li></ul><p>在一个类中进行其他类结构的嵌套</p><ul><li>内部类的优点</li></ul><blockquote><p>a.内部类可以访问外部类定义的所有数据</p><p>b.内部类可以实现Java的单继承局限</p><p>c.内部类可以对同一包中的其他类隐藏起来，仅供外部类使用—封装</p></blockquote><a id="more"></a><ul><li>内部类缺点</li></ul><p>结构复杂</p><ul><li>内部类与外部类的关系</li></ul><blockquote><p>a.对于非静态内部类而言，内部类的创建需要依赖外部类的实例化对象，在没有外部类对象之前是无法创建内部类的。</p><p>b.内部类是一个相对独立的个体，与外部类不是<code>is-a</code>关系</p><p>c.内部类可以直接访问外部类元素（包括私有域），但是外部类不可以直接访问内部类元素，需要通过内部类的引用间接访问</p></blockquote><ul><li>创建内部类语法（在外部类之外）</li></ul><p><strong>创建非静态内部类：</strong></p><p>外部类.内部类 内部类引用 = new 外部类().new 内部类();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outter.Inner in = <span class="keyword">new</span> Outter().new Inner();</span><br></pre></td></tr></table></figure><p><strong>创建静态内部类：</strong></p><p>外部类.内部类 内部类引用 = new 外部类.内部类（）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outter.Inner in = <span class="keyword">new</span> Outter.Inner();<span class="comment">//静态类与对象无关</span></span><br></pre></td></tr></table></figure><ul><li>内部类的分类</li></ul><p><strong>非静态成员内部类</strong>—成员方法</p><blockquote><p>成员内部类不能存在任何static变量或方法，可以访问外部类的静态域</p><p>成员内部类需要依附外部类new Outter(). new Inner();</p><p>内部类可以使用private封装，表示私有内部类，该内部类仅供外部类使用(HaspMap中的Entry内部类，ArrayList中的Node内部类)</p></blockquote><p><strong>静态内部类</strong>–静态方法</p><blockquote><p>静态内部类的创建不需要外部类，可以直接创建</p><p>静态内部类不可以访问外部类的任何非static域</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name = <span class="string">"test"</span>;</span><br><span class="line">Inner()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Outter()&#123;</span><br><span class="line">System.out.println(<span class="string">"Outter的构造函数"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Outter.Inner in = <span class="keyword">new</span> Outter.Inner();<span class="comment">//创建内部类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法内部类</strong>—类比成员内部类</p><blockquote><p>a.方法内部类不能使用任何访问权限修饰符 public、private、protected均不允许使用</p><p>b.方法内部类对外（方法外）完全隐藏，除了该方法可以访问他之外，其余地方均不能访问</p><p>c.方法内部类要想声明方法形参，该形参必须使用final声明（JDK8变为隐式final声明）</p></blockquote><p><strong>匿名内部类</strong>—方法内部类的特殊版本</p><blockquote><p>a.匿名内部类必须继承一个抽象类或者实现一个接口</p><p>b.匿名内部类没有构造方法，因为他没有类名</p></blockquote><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在一个类中进行其他类结构的嵌套&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部类的优点&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;a.内部类可以访问外部类定义的所有数据&lt;/p&gt;
&lt;p&gt;b.内部类可以实现Java的单继承局限&lt;/p&gt;
&lt;p&gt;c.内部类可以对同一包中的其他类隐藏起来，仅供外部类使用—封装&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的继承与多态</title>
    <link href="http://www.bingoxin.top/2018/10/12/Java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
    <id>http://www.bingoxin.top/2018/10/12/Java中的继承与多态/</id>
    <published>2018-10-12T12:09:49.000Z</published>
    <updated>2018-12-22T12:10:35.310Z</updated>
    
    <content type="html"><![CDATA[<h3 id="static方法（类方法）"><a href="#static方法（类方法）" class="headerlink" title="static方法（类方法）"></a>static方法（类方法）</h3><p>与对象实例化无关，通过类名直接调用，常见于工具方法</p><ul><li>a.静态方法不能访问类中的普通属性<ul><li>静态方法和对象实例化无关，普通属性在堆上保存</li></ul></li><li>b.静态方法可以访问类中的静态属性</li><li>c.普通方法可以访问类中静态属性</li><li><p>d.普通方法可以访问类中普通属性</p></li><li><p>用static修饰类</p></li></ul><p>static只能修饰内部类，不能修饰外部类</p><a id="more"></a><p>可以通过下面的程序进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num1 ;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num2;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"普通成员函数调用普通属性"</span> + num1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"普通成员函数调用静态属性"</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"静态成员函数调用普通属性"</span> + num1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"静态成员函数调用静态属性"</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>定义：使用{}定义的一段代码</p><p>根据代码块出现的位置以及关键字不同，分为以下四类代码块：</p><ul><li>a.普通代码块</li><li>b.构造块</li><li>c.静态代码块</li><li>d.同步代码块（和多线程同步有关）</li></ul><p><strong>普通代码块</strong></p><p>定义在方法中的代码块</p><p><strong>构造块</strong></p><p>定义在类中的代码块（不加任何修饰符）</p><p>当有对象产生时，构造块优先于构造方法执行，产生几个对象，就调用几次构造块</p><p><strong>作用：</strong>在构造方法执行之前进行一些初始化操作</p><p><strong>静态代码块</strong></p><p>定义：在类中使用static关键字定义的代码块</p><p>根据定义，可分为以下两类：</p><ul><li>a.非主类的静态代码块</li><li>b.主类中的静态代码块</li></ul><p><strong>非主类的静态代码块</strong></p><p>静态代码块在<strong>类加载时</strong>被调用，优先于构造块，不管产生多少实例化对象，只会被调用一次</p><p><strong>主类中的静态代码块</strong></p><p>主类中的静态代码块优先于主方法执行</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>概念：无须重写原有类代码的基础上，就拥有原有类所有属性与方法，对原有类进行功能上的扩展</p><p>关键字：extends</p><p>继承强调可重复性</p><p>子类（派生类）</p><p>父类（基类，超类）</p><p> class 基类 extends 父类</p><ul><li>继承的限制</li></ul><blockquote><p>a.子类实例化前先调用父类构造方法产生父类对象后，再调用子类构造</p><p>b.java只有单继承没有多继承</p><p>c.在进行继承的时候，子类会继承父类所有结构（包含私有属性、构造方法、普通方法）</p></blockquote><ul><li>显式继承（用public、default声明）</li></ul><p>可以直接调用：父类中所有非私有操作</p><ul><li>隐式继承（用private声明）</li></ul><p>必须通过其他形式调用-&gt;getter与setter，不能直接调用，父类中的所有私有操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">Person()&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Person::Person()"</span>+age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(<span class="keyword">int</span> _age)&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Person::Person(int _age)"</span>+age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line">Teacher()&#123;</span><br><span class="line">System.out.println(<span class="string">"Teacher::Teacher()"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Teacher(String _name)&#123;</span><br><span class="line">System.out.println(<span class="string">"Teacher::Teacher(String)"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法覆写-override"><a href="#方法覆写-override" class="headerlink" title="方法覆写-override"></a>方法覆写-override</h3><p>覆写概念：发生在有继承关系的类之中，子类定义了与父类完全相同的方法（返回值、参数列表、方法名全相同），被覆写的方法不能拥有比父类更为严格的访问控制权限，且隐式继承的方法无法被覆写</p><p><strong>判断当前方法调用的是哪个类的方法：</strong></p><blockquote><p>a.当前使用的对象是通过哪个类new的</p><p>b.调用方法是否被子类所覆写，若被覆写，则调用的一定是子类所覆写后的方法</p></blockquote><ul><li>访问权限</li></ul><blockquote><p>private：私有访问</p><p>default：包访问权限</p><p>public：公有访问权限</p></blockquote><p><strong>方法重写例程如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">Person()&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Person::Person()"</span>+age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(<span class="keyword">int</span> _age)&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Person::Person(int _age)"</span>+age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line">Teacher()&#123;</span><br><span class="line">System.out.println(<span class="string">"Teacher::Teacher()"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Teacher(String _name)&#123;</span><br><span class="line">System.out.println(<span class="string">"Teacher::Teacher(String)"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.getInfo();</span><br><span class="line">System.out.println(name+age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法重载与方法重写"><a href="#方法重载与方法重写" class="headerlink" title="方法重载与方法重写"></a>方法重载与方法重写</h3><ul><li>概念上</li></ul><p>重载是指在同一个类中，方法名相同且参数列表中参数个数和参数类型不同，与返回值无关</p><p>覆写是指在继承关系的类中，子类定义了与父类完全相同的方法（返回值类型、方法名、参数列表都相同），子类中被覆写的方法不能拥有比父类更严格的访问控制权限，且隐式继承的方法无法覆写</p><ul><li>范围上</li></ul><p>重载发生在同一个类中，重写发生在继承关系中</p><ul><li>权限要求</li></ul><p>重载没有权限要求，重写中权限不能是private且子类权限不能比父类权限更严格</p><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><ul><li>super表示调用父类方法</li></ul><blockquote><p>a. 调用父类构造方法super（参数列表）</p><p>子类中调用父类无参构造时，super()可写可不写。</p><p>子类中调用父类有参构造时，super（参数列表）必须要写，告知编译器调用的是哪个父类有参构造</p><p>super与this在构造方法中不能同时存在，即子类不存在构造方法的互相调用</p><p>b. super调用父类普通方法</p><p>super.方法名（参数列表），super调用的一定是被覆写的方法</p></blockquote><ul><li>super表示调用父类属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">Person()&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Person::Person()"</span>+age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(<span class="keyword">int</span> _age)&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Person::Person(int _age)"</span>+age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line">Teacher()&#123;</span><br><span class="line">        <span class="keyword">super</span>.age = <span class="number">12</span>;<span class="comment">//super调用父类属性</span></span><br><span class="line">System.out.println(<span class="string">"Teacher::Teacher()"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Teacher(String _name)&#123;</span><br><span class="line"><span class="keyword">super</span>(<span class="number">12</span>);<span class="comment">//super调用父类有参构造函数</span></span><br><span class="line">System.out.println(<span class="string">"Teacher::Teacher(String)"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.getInfo();<span class="comment">//super调用父类普通函数</span></span><br><span class="line">System.out.println(name+age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ul><li>修饰类</li></ul><p>当一个类用final关键字定义后，表示该类不允许被继承。</p><p>同时，该类中的所有<strong>方法</strong>都会被隐式加上final关键字（不包括成员变量）</p><p>string类以及8大数据类型的包装类都是final类—保护性</p><ul><li>修饰方法</li></ul><p>当一个方法被final关键字定义后，表示该方法不允许被<strong>覆写</strong></p><p>final方法常用于模板方法—保护性</p><ul><li>final修饰属性</li></ul><p>当属性被final修饰后，表示该<strong>属性值不可变</strong>。并且该属性要在<strong>声明时初始化</strong></p><p><strong>被final修饰的变量初始化方法</strong></p><blockquote><p>在声明时初始化</p><p>在构造函数里初始化</p><p>在代码块初始化</p></blockquote><p><strong>final修饰基本数据类型变量</strong></p><p>类中常量一般使用final+static，描述<strong>全局常量</strong></p><p>全局常量命名规范：多个单词全大写，且单词间以_分隔</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MY_NUM = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>final修饰引用数据类型变量</strong></p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li>概念</li></ul><p>同一个类实例化的相同方法在不同情形下有不同的表现形式</p><ul><li>向上转型—用于参数统一化</li></ul><p>父类 父类引用 = new 子类();</p><p>Person per = new Student();</p><ul><li>向下转型—需要强制类型转换—父类引用需要调用子类扩充方法时</li></ul><p>子类 子类引用 = （子类）父类实例</p><p>Student stu = (Student) new Person();</p><p>要发生向下转型，必须先发生向上转型（ClassCastException—&gt;运行时异常，发生在两个不能强转的类之间）</p><ul><li>instanceof类</li></ul><p>引用instanceof类：表示该引用能否指向该类实例 返回boolean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">per instanceof Student</span><br></pre></td></tr></table></figure><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;static方法（类方法）&quot;&gt;&lt;a href=&quot;#static方法（类方法）&quot; class=&quot;headerlink&quot; title=&quot;static方法（类方法）&quot;&gt;&lt;/a&gt;static方法（类方法）&lt;/h3&gt;&lt;p&gt;与对象实例化无关，通过类名直接调用，常见于工具方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a.静态方法不能访问类中的普通属性&lt;ul&gt;
&lt;li&gt;静态方法和对象实例化无关，普通属性在堆上保存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;b.静态方法可以访问类中的静态属性&lt;/li&gt;
&lt;li&gt;c.普通方法可以访问类中静态属性&lt;/li&gt;
&lt;li&gt;&lt;p&gt;d.普通方法可以访问类中普通属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用static修饰类&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;static只能修饰内部类，不能修饰外部类&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>求1+2+3+...+n</title>
    <link href="http://www.bingoxin.top/2018/10/09/%E6%B1%821-2-3-n/"/>
    <id>http://www.bingoxin.top/2018/10/09/求1-2-3-n/</id>
    <published>2018-10-09T12:08:00.000Z</published>
    <updated>2018-12-21T12:08:43.252Z</updated>
    
    <content type="html"><![CDATA[<p>今天做了一道面试题，题目描述如下：</p><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><a id="more"></a><p>看到这道题，题目要求不能用循环，我首先想到的是用递归。</p><p>于是我想到了如下解法：</p><pre><code>class Solution {public:    int Sum_Solution(int n) {        int ret = n;        if(n &gt; 0)            ret += Sum_Solution(n-1);        return ret;    }};</code></pre><p>我又看了一下别人的程序：</p><pre><code>class Solution {public:    int Sum_Solution(int n) {        int ret = n;        bool choose = ((n&gt;0)&amp;&amp;((ret += Sum_Solution(n-1)) &gt; 0));        return ret;    }};</code></pre><p>感叹一下，这个短路与用的真是巧妙~</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天做了一道面试题，题目描述如下：&lt;/p&gt;
&lt;p&gt;求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://www.bingoxin.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>初识Java</title>
    <link href="http://www.bingoxin.top/2018/09/20/%E5%88%9D%E8%AF%86Java/"/>
    <id>http://www.bingoxin.top/2018/09/20/初识Java/</id>
    <published>2018-09-20T12:06:27.000Z</published>
    <updated>2018-12-20T12:07:12.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>首先说一下Java的源文件</p><p>Java源文件的格式是：文件名.java，以此来保存原始java代码</p><p>Java是一种半解释半编译语言</p><p><strong>编译过程：</strong></p><p>输入命令javac 要编译的源文件，生成.class 文件（二进制文件），来给JVM阅读的，启动JVM小虚拟机</p><p>若源文件中有汉字，编译命令需使用：</p><pre><code>javac -encoding UTF-8 文件名.java</code></pre><p><strong>解释过程：</strong></p><p>输入命令：java 主类名</p><p>若要给主类中默认参数赋值，在解释过程中使用</p><pre><code>java 主类名 参数1 参数2 ... </code></pre><a id="more"></a><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote><p>a.单行注释：//</p><p>b.多行注释: /<em> </em>/</p><p>c.文档注释：/*<em> </em>/ (用于方法与类之上描述其作用)</p></blockquote><h3 id="标识符、类与常量的命名"><a href="#标识符、类与常量的命名" class="headerlink" title="标识符、类与常量的命名"></a>标识符、类与常量的命名</h3><ul><li>标识符命名</li></ul><blockquote><p>a.java指定的标识符由字母、字符和_组成，不能用数字开头，不能使用java中的关键字</p><p>b.标识符采用有意义的简单命名</p><p>c.对于变量和方法，标识符由多个单词组成，采用驼峰命名，即第一个单词的首字母小写，第二个之后的单词首字母大写。</p></blockquote><ul><li>类的命名</li></ul><p>类名以大写字母开头，如果类名由多个单词组成，则每个单词首字母大写。</p><p>Java源文件文件名必须与公共类(public class)的名称相同。</p><ul><li>常量命名</li></ul><p>全大写，多个单词以_连接</p><h3 id="数据类型划分"><a href="#数据类型划分" class="headerlink" title="数据类型划分"></a>数据类型划分</h3><ul><li>基本数据类型：(8大基本数据类型)</li></ul><p>数值型：</p><pre><code>整型：byte(-128~127)、short、int(-2^31~2^31-1)、long(-2^63~2^63-1)(默认值是0)浮点型：double、float(默认值是0.0)</code></pre><p>字符型：</p><pre><code>char(默认值是\u0000)</code></pre><p>布尔型：</p><p>表示真假用true和false</p><pre><code>boolean(默认值是false)</code></pre><ul><li><p>引用数据类型</p><p>数组、类、接口(默认值为null)</p></li></ul><p>数据类型使用：</p><blockquote><p>a.描述整数就用int，描述小数就用double</p><p>b.long一般用于描述日期、时间、内存或者文件大小</p><p>c.编码转换或者二进制流的操作使用byte</p><p>d.char一般用于描述中文(基本忽略)</p></blockquote><p>在java程序中，任何一个整型常量都是int类型</p><p>在java中声明一个long类型的常量，要在数字后加上L或l</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>大数据类型与小数据类型做数据类型运算时，小的数据类型会自动转换成大的数据类型，无需强转</p><p>大的数据类型类型转为小的数据类型必须强转，可能会丢失内容</p><p>强转一定是从大的数据类型到小的数据类型</p><p><strong>byte与int类型转换：</strong></p><p>整型常量赋值给byte变量时，若常量值在byte类型保存范围内可以直接赋值无须强转；整型变量无论是否在byte类型的保存范围中，一律需要强转</p><p><strong>注意：</strong></p><p>小数默认类型为double类型，要声明float类型，需要在浮点数常量后加f或F</p><p>所有数据类型的默认值必须结合类来观察，主方法中不存在默认值</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;p&gt;首先说一下Java的源文件&lt;/p&gt;
&lt;p&gt;Java源文件的格式是：文件名.java，以此来保存原始java代码&lt;/p&gt;
&lt;p&gt;Java是一种半解释半编译语言&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入命令javac 要编译的源文件，生成.class 文件（二进制文件），来给JVM阅读的，启动JVM小虚拟机&lt;/p&gt;
&lt;p&gt;若源文件中有汉字，编译命令需使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;javac -encoding UTF-8 文件名.java
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;解释过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入命令：java 主类名&lt;/p&gt;
&lt;p&gt;若要给主类中默认参数赋值，在解释过程中使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java 主类名 参数1 参数2 ... 
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>线程</title>
    <link href="http://www.bingoxin.top/2018/09/17/%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.bingoxin.top/2018/09/17/线程/</id>
    <published>2018-09-17T12:04:43.000Z</published>
    <updated>2018-12-18T12:05:38.373Z</updated>
    
    <content type="html"><![CDATA[<p>当多个PCB指向同一块虚拟地址空间时，这些PCB的资源是共享的，而该PCB被称为一个线程。但是对于CPU来说，是没有办法判断一个PCB是一个进程还是线程。每个PCB都是小于等于一个进程的，则将Linux中的一个进程是一个轻量级进程，这也就可以看出：在Linux下，没有真正意义的线程，线程使用进程模拟出来的。</p><a id="more"></a><p>由以上描述可以发现，在Linux下，进程是承担分配系统资源的基本单位，是由一个执行流、虚拟地址空间、页表和映射关系组成的。线程是调度的基本单位，由多个执行流、一个虚拟地址空间、页表和映射关系组成的。那么在Linux中，就没有进程和线程的区别，则线程称为轻量级进程。</p><h3 id="线程的优点"><a href="#线程的优点" class="headerlink" title="线程的优点"></a>线程的优点</h3><blockquote><p>1.创建一个线程要比创建一个进程的代价小的多</p><p>2.与进程相比线程切换的工作量要小的多</p><p>3.线程占用的资源比较小</p><p>4.线程可以并行</p></blockquote><h3 id="线程的缺点"><a href="#线程的缺点" class="headerlink" title="线程的缺点"></a>线程的缺点</h3><blockquote><p>1.性能缺失</p><p>2.健壮性降低</p><p>3.缺乏访问控制</p><p>4.编程难度提高</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当多个PCB指向同一块虚拟地址空间时，这些PCB的资源是共享的，而该PCB被称为一个线程。但是对于CPU来说，是没有办法判断一个PCB是一个进程还是线程。每个PCB都是小于等于一个进程的，则将Linux中的一个进程是一个轻量级进程，这也就可以看出：在Linux下，没有真正意义的线程，线程使用进程模拟出来的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.bingoxin.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的开发工具</title>
    <link href="http://www.bingoxin.top/2018/09/06/Linux%E4%B8%AD%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.bingoxin.top/2018/09/06/Linux中的开发工具/</id>
    <published>2018-09-06T12:01:47.000Z</published>
    <updated>2018-12-16T12:02:32.465Z</updated>
    
    <content type="html"><![CDATA[<p>使用Linux，免不了和开发工具打交道，开发工具都有哪些呢？</p><a id="more"></a><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>说起文本编辑器，大家首先想到的应该就是vim了，毕竟只要打开一个文本都需要的它</p><p>你的vim可能什么特殊功能都没有</p><p>接下来看一下有关于vim的配置吧~</p><h4 id="首先输入命令"><a href="#首先输入命令" class="headerlink" title="首先输入命令"></a>首先输入命令</h4><pre><code>su  </code></pre><p>这时需要输入密码，将权限切换到root权限</p><h4 id="输入以下指令"><a href="#输入以下指令" class="headerlink" title="输入以下指令"></a>输入以下指令</h4><pre><code>cd ~cd /etcvim vimrc</code></pre><p>进入到vimrc的文本编辑</p><h4 id="在最后一行加入"><a href="#在最后一行加入" class="headerlink" title="在最后一行加入"></a>在最后一行加入</h4><pre><code>set nuset tabstop=4set cursorline</code></pre><p>即可更改vim的配置，三条语句的作用一次是</p><blockquote><p>在左侧添加行号</p></blockquote><blockquote><p>tab键的空格数，赋值为4，即一个tab键等于4个空格</p></blockquote><blockquote><p>标识当前行</p></blockquote><p>在Linux下，还有Emacs、Sublime Text、Lime、Atom等</p><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>Linux中常见的编译器就是gcc</p><p>gcc是C语言编译器</p><blockquote><p>-c 只编译子程序</p><p>-o 产生目标文件</p><p>-g 附加调试信息</p></blockquote><p>例如，<strong>test.c的编译过程</strong></p><p>gcc -E test.c   预处理  会生成临时文件test.i</p><p>gcc -S test.i -o test.s  生成汇编代码  会生成临时文件test.s</p><p>gcc -c test.s -o test.o  生成二进制文件  会生成临时文件test.o</p><p>gcc -o test test.o  进行链接操作  会生成可执行文件test</p><h3 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h3><p>GDB是一个调试程序的调试器</p><p>GDB可以调试C、C++等</p><h3 id="make与makefile"><a href="#make与makefile" class="headerlink" title="make与makefile"></a>make与makefile</h3><p>我们在编译一个C文件后，会产生一个a.out文件，这是一个可执行的二进制文件，若要执行文件，使用./a.out即可</p><p>注意：make不是编译器</p><h4 id="make与makefile的区别："><a href="#make与makefile的区别：" class="headerlink" title="make与makefile的区别："></a>make与makefile的区别：</h4><p>make是一条命令，makefile是一个文件</p><h4 id="makefile的编写"><a href="#makefile的编写" class="headerlink" title="makefile的编写"></a>makefile的编写</h4><p>在讲makefile的撰写之前，先来解释两个名词—依赖关系、依赖方法</p><p><strong>依赖关系</strong>可以看做是两个文件确定之间的关系</p><p><strong>依赖方法</strong>可以看做是两个文件的关系实现的过程</p><ul><li>makefile中放依赖方法和依赖关系</li><li>makefile中可以只有依赖方法</li><li>makefile中依赖方法要以Tab键开头</li></ul><p>例如：</p><pre><code>test:test.c    gcc -o test test.c.THONY:clean clean:    rm -f test</code></pre><p>test:test.c  是依赖关系</p><p>gcc -o test test.c   是依赖方法</p><p>.THONY clean  中的clean是一个伪目标，凡是伪目标，都是总是被执行的；而非伪目标只有被修改时才能编译。</p><p>那么如何确定文件是否是被修改呢？</p><p>当然是看文件最后一次被修改的时间啦~</p><h4 id="make的使用"><a href="#make的使用" class="headerlink" title="make的使用"></a>make的使用</h4><p>每次修改完要编译的文件后，使用 make 命令，如上述makefile：会产生一个test文件，若要执行test.c，只需使用 ./test 即可执行。</p><p>若要执行伪目标，使用 make clean 命令即可</p><h3 id="yum工具—软件包管理器"><a href="#yum工具—软件包管理器" class="headerlink" title="yum工具—软件包管理器"></a>yum工具—软件包管理器</h3><p>yum是一种可以安装软件的工具</p><p>在linux环境下，安装有以下两种：</p><blockquote><p>源码安装：在网上会下载一些程序的源码，编译后就得到了可执行程序(使用make、make install命令)</p></blockquote><blockquote><p>软件包安装：有的人把软件编译好，做成软件包(就像Windows下的应用)</p></blockquote><p>在这里提一下，<strong>软件包和软件包管理器的关系就像APP和应用商店的关系</strong></p><p><strong>yum的使用</strong></p><ul><li><p>yum需要联网状态才能正常工作</p></li><li><p>安装或卸载程序需要sudo命令来权限提升</p><p>sudo yum 文件名//文件安装</p><p>sudo yum remove 文件名 //文件卸载</p></li><li><p>yum list可以罗列出所有的软件包，可以用grep筛选</p></li></ul><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Linux，免不了和开发工具打交道，开发工具都有哪些呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.bingoxin.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的权限</title>
    <link href="http://www.bingoxin.top/2018/09/03/Linux%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90/"/>
    <id>http://www.bingoxin.top/2018/09/03/Linux中的权限/</id>
    <published>2018-09-03T11:59:51.000Z</published>
    <updated>2018-12-15T12:00:47.033Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux下的用户"><a href="#Linux下的用户" class="headerlink" title="Linux下的用户"></a>Linux下的用户</h3><ul><li>超级用户—#</li></ul><p>可以在Linux系统下做任何事情</p><ul><li>普通用户—$</li></ul><p>在Linux下做有限的事情</p><a id="more"></a><h3 id="用户切换命令—su"><a href="#用户切换命令—su" class="headerlink" title="用户切换命令—su"></a>用户切换命令—su</h3><ul><li><code>su (root)</code></li></ul><p>由普通用户切换到root用户</p><ul><li><code>su user</code></li></ul><p>由root用户切换到普通用户</p><h3 id="文件类型区分"><a href="#文件类型区分" class="headerlink" title="文件类型区分"></a>文件类型区分</h3><p>在Windows下，文件类型的区分是由文件的后缀决定的，而在Linux下文件的后缀并不起决定性作用</p><p>输入<code>ll</code>，可以得到文件的属性，而第一列就是文件的类型</p><ul><li><p>以-开头为普通文件</p></li><li><p>以d开头为目录文件</p></li><li><p>以p开头为管道文件</p></li><li><p>以l开头为链接文件</p></li></ul><h3 id="Linux权限管理"><a href="#Linux权限管理" class="headerlink" title="Linux权限管理"></a>Linux权限管理</h3><ul><li>文件访问者</li></ul><blockquote><p>a.u—文件和目录的拥有者</p><p>b.g—文件和目录的所有者所在组的用户</p><p>c.o—其他用户</p></blockquote><p>输入<code>ll</code>命令后，除了第一列，其他九列三列为一组，代表拥有者、所属组和other的权限</p><blockquote><p>r–读</p><p>w–写</p><p>x–执行</p></blockquote><p>将权限看做一列，第三列是文件的拥有者，第四列是文件的所属组</p><ul><li>权限修改</li></ul><p><strong>单个权限修改</strong></p><p><code>chmod 访问者 +/- 权限 文件名</code>将文件的访问者某访问权限增加或取消</p><p><strong>多个权限修改</strong></p><p><code>chmod 访问者1 +/- 权限,访问者2 +/- 权限 文件名</code>将文件的多个访问者某访问权限增加或取消</p><p>或者将用二进制来表示访问者的权限，权限共有r/w/x，则r—4，w—2，x—1</p><p>例如：</p><p><code>chmod 777 文件名</code>给所有的访问者赋予所有权限</p><ul><li>修改文件的拥有者和所属组</li></ul><p><code>chown 访问者 文件名</code>将文件的拥有者或所属组进行修改，将普通用户转换为root用户时，需在命令前加sudo关键字</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linux下的用户&quot;&gt;&lt;a href=&quot;#Linux下的用户&quot; class=&quot;headerlink&quot; title=&quot;Linux下的用户&quot;&gt;&lt;/a&gt;Linux下的用户&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;超级用户—#&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以在Linux系统下做任何事情&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通用户—$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Linux下做有限的事情&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.bingoxin.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>STL的底层与应用</title>
    <link href="http://www.bingoxin.top/2018/08/28/STL%E7%9A%84%E5%BA%95%E5%B1%82%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>http://www.bingoxin.top/2018/08/28/STL的底层与应用/</id>
    <published>2018-08-28T11:06:53.000Z</published>
    <updated>2018-12-26T11:10:46.364Z</updated>
    
    <content type="html"><![CDATA[<p>STL是惠普实现的，其有多个版本，但都是在HP版本的基础上完成的</p><p>STL是C++的标准模板库，包括数据结构和算法的软件框架<a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>STL将常用的数据结构封装起来，在封装过程中使用了算法，使用方便</p><p>其具有通用、高效的特点 </p><h3 id="STL的六大组件"><a href="#STL的六大组件" class="headerlink" title="STL的六大组件"></a>STL的六大组件</h3><p>容器、适配器、迭代器、空间配置器、仿函数、算法</p><p>接下来我会从组件功能、组件实例和实例的底层实现等方面来对各组件进行讲解</p><h3 id="容器-vector、slist、array、deque等"><a href="#容器-vector、slist、array、deque等" class="headerlink" title="容器(vector、slist、array、deque等)"></a>容器(vector、slist、array、deque等)</h3><p>容器中数据的区间都是左闭右开的</p><p>容器分两种：线性和特殊线性结构</p><p>线性结构有：array、vector、slist、deque、string等</p><font color="red" size="3">vector</font><p>vector的底层是动态顺序表，底层结构：</p><div align="center"><br>    <img src="/images/posts/STL/vector.png" height="300" width="500"><br></div><p>由于vector是一段连续的空间，其迭代器被设计成一个原生态指针</p><p>在使用vector时要注意：包含其头文件<vector>并引入标准命名空间std</vector></p><p>其具体功能如下：</p><div align="center"><br>    <img src="/images/posts/STL/vector功能.png" height="500" width="500"><br></div><font color="red" size="3">list</font><p>list的底层是一个带头结点的双向单链表，底层结构：</p><div align="center"><br>    <img src="/images/posts/STL/单链表底层.png" height="300" width="500"><br></div><p>当集合需要大量的插入和删除时，考虑用list</p><p>list的迭代器需要其实现者自己提供</p><p>其具体功能如下：</p><div align="center"><br>    <img src="/images/posts/STL/list功能.png" height="500" width="500"><br></div><font color="red" size="3">deque</font><p>deque是一段假想的连续空间，是一个双端序列，可以实现动态的二维数组</p><p>deque的两端都可以进行插入和删除，其结构如下：</p><div align="center"><br>    <img src="/images/posts/STL/deque.png" height="400" width="600"><br></div><p>deque是分段连续空间，维护其连续的假象的是迭代器</p><p>若迭代器中的cur到了last的位置，即表示已到当前队列的边缘</p><p>在deque的底层，有中控器(map)记录每个队列的迭代器地址(node)，迭代器中有队列的初始位置(first)、末尾位置(last)以及当前指向位置(pur)</p><p>若创建的队列过多，中控器空间不足，则扩容中控器，新的中控器从中间开始存储迭代器(node)的地址</p><p>则deque底层实现如下：</p><div align="center"><br>    <img src="/images/posts/STL/deque底层实现.png" height="300" width="500"><br></div><p>deque的操作如下：</p><div align="center"><br>    <img src="/images/posts/STL/deque功能.png" height="300" width="500"><br></div><p>array的底层实现是静态顺序表</p><p>string也是静态顺序表，他是用来存放字符串的，而array是用来存放各种数据的</p><p>slist是带头结点的单链表</p><p>这些就不做详细讲解了</p><h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><p>仿函数是一个函数对象，即将一个类像函数一样使用</p><pre><code>class people{   public:      返回值类型 operator()(参数列表);   成员变量}；</code></pre><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>适配器是设计模式的一种，该模式的作用是将一个类的接口转换成用户希望的另一个接口</p><p>STL中适配器有三种：应用于容器的适配器、应用于迭代器的适配器、应用于仿函数的适配器</p><h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h4><p>stack和queue都是一种特殊的线性数据结构，其只能在固定端插入和删除</p><p>stack无法遍历，无begin(),end()</p><p>由于deque是双开口序列，则将其稍作改装就可以实现stack和queue</p><p>在使用priority_queue时，用户可以以任意次序将数据放进去，但是取出时，会以优先级高低取出</p><p>其以vector为底层结构，加上堆算法重新封装</p><h4 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h4><p>关联式容器是用键值对(&lt;key,value&gt;)来实现的</p><font color="red" size="3">键值对</font><p>键值对实际是一个结构体，该结构体具有两个字段，两个字段有着一一对应的关系</p><p>在其应用时</p><pre><code>pair&lt;key,value&gt;(key,value);make_pair(key,value);</code></pre><p>这两种形式都可以创建键值对，第一种是对模板类的实例化，第二种返回键值对</p><h5 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h5><p>序列式容器在查找数据时，时间复杂度为O(n)</p><p>而关联式容器map/multimap底层是由红黑树构成的</p><p>这就使得其在查找数据时时间复杂度变成了O(1)，提高了查找效率</p><font color="red" size="3">数据存储方式：</font><p>由于其底层是由红黑树构成的，则在插入变量时，会与key进行比较，则对红黑树进行中序遍历，会得到一个有序序列</p><h4 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h4><p>其底层实现也是红黑树</p><p>其与map的相同之处在于：底层结构都是红黑树</p><p>不同之处是：map中存放的是一个真正的键值对，而set中key与value相同</p><p>map与multimap,set与multiset之间的区别是map/set不可以存储重复的变量，可以去重，而multimap/multiset可以存放相同变量，只是单纯的排序</p><h4 id="unordered-map-unordered-multimap-unordered-set-unordered-multiset"><a href="#unordered-map-unordered-multimap-unordered-set-unordered-multiset" class="headerlink" title="unordered_map/unordered_multimap  unordered_set/unordered_multiset"></a>unordered_map/unordered_multimap  unordered_set/unordered_multiset</h4><p>unordered_map/unordered_multimap放置的内容是一个正常的键值对</p><p>而unordered_set/unordered_multiset放置的内容是key与value相同的键值对</p><p>其底层是由哈希桶实现的，则其的数据存放方式是无序的</p><font color="blue" size="3">map与unordered_map的区别：</font><blockquote><p>1.底层：map的底层是红黑树，unordered_map的底层是哈希桶</p></blockquote><blockquote><p>2.查找方式：map的查找效率高，为O(log2n)，而unordered_map的查找效率为O(n)</p></blockquote><blockquote><p>3.map是有序存放的，而unordered_map是无序放的</p></blockquote><blockquote><p>4.两者的应用场景不同</p></blockquote><blockquote><p>5.迭代器方式不同：map可以正向和反向遍历，而unordered_map只可以正向遍历</p></blockquote><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法有两种：与数据结构有关的算法(绑定在容器上的算法)和与数据结构无关的算法(通用算法)</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是一种设计模式，其实际上是一种行为类似于指针的对象，因此指针的功能迭代器都有</p><p>迭代器的实现只要在类中将指针的功能重载即可</p><p>迭代器的提供者就是容器的实现者</p><h3 id="空间管理"><a href="#空间管理" class="headerlink" title="空间管理"></a>空间管理</h3><h4 id="普通存放数据的原理"><a href="#普通存放数据的原理" class="headerlink" title="普通存放数据的原理"></a>普通存放数据的原理</h4><p>需要空间–&gt;new/new[]–&gt;申请空间、构造对象</p><p>new是将malloc重新封装的，使用一次malloc，在内存中除了会开辟所需空间外，还会额外开辟36个字节</p><p>结构如下图：</p><div align="center"><br>    <img src="/images/posts/STL/malloc.png" height="300" width="500"><br></div><p>通过这种形式管理空间可以防止越界访问</p><h4 id="普通方式存放数据的缺陷"><a href="#普通方式存放数据的缺陷" class="headerlink" title="普通方式存放数据的缺陷"></a>普通方式存放数据的缺陷</h4><blockquote><p>1.频繁的向系统索要小的内存块，会产生内存碎片</p></blockquote><blockquote><p>2.频繁的向系统索要小的内存块，产生额外开销，效率低</p></blockquote><blockquote><p>3.没有及时的释放空间，造成内存泄漏</p></blockquote><blockquote><p>4.空间不足时，无法获取空间</p></blockquote><h4 id="标准空间配置器"><a href="#标准空间配置器" class="headerlink" title="标准空间配置器"></a>标准空间配置器</h4><p>标准空间配置器只是将new,delete进行简单的封装，与我们平常使用的new和delete没太大区别</p><h4 id="重新设计空间配置器"><a href="#重新设计空间配置器" class="headerlink" title="重新设计空间配置器"></a>重新设计空间配置器</h4><p>重新设计空间配置器有一级空间配置器和二级空间配置器两种</p><p>重新设计空间配置器会根据用户索要空间的大小来选择空间配置器</p><font color="blue" size="3">一级空间配置器</font><p>当用户索要空间大于128个字节时，会使用一级空间配置器</p><p>一级空间配置器将malloc和free进行简单的封装</p><pre><code>void* allocate(字节数):malloc若空间充足，开辟空间成功，直接返回若空间不充足，开辟空间失败，启动空间不足应对措施(函数指针)allocate_OOM (字节数){   检测空间不足应对措施是否设置   是：malloc  //重新开辟空间   否:throw bad_alloc  //抛异常}//将空间归还系统void deallocate(void* p,size_t size){   free(p);}</code></pre><font color="blue" size="3">二级空间配置器</font><p>当用户索取空间小于128个字节时，会使用二级空间配置器</p><p>为了减少多次开辟空间造成的额外消耗，二级空间配置器会开辟一个很大空间作为内存池</p><p>同时会构造一个哈希表，其中会有128/8=16个结点，每个结点下面会挂(n+1)*8字节的内存块，构成哈希桶，以此来管理小的内存块</p><p>结构如下：</p><div align="center"><br>    <img src="/images/posts/STL/空间配置器.png" height="300" width="500"><br></div><p>空间管理如下：</p><pre><code>void* allocate(size_t size){   if(size&gt;128)       一级空间配置器   else   {       1.找size对应的哈希桶       2.检测该哈希桶有没有结点        有：将第一块内存给用户        没有：refill(size向上取整到8的整数倍，向当前链表中补充空间)   }}void* refill(size_t size){   1.通过chunk_alloc(objs,size)索要nobjs(20)个size个字节的内存块   2.nobjs = 1---&gt;返回----&gt;将一块内存返回给用户     20 &gt;= objs &gt; 1 ---&gt;将剩余的内存块挂在链表中}void* chunk_alloc(size_t&amp; nobjs,size_t size){   从内存池中索要空间     &gt;1.计算总共需要的字节数  totalBytes = nobjs*size     &gt;2.计算内存池中剩余的字节数  leftBytes =_endFree-_startFree;   if(leftByte&gt;=totalBytes)   {       提供20个内存块   }   else if (leftBytes&gt;=size)   {       nobjs=leftBytes/size;   }   else   {       0.把内存池剩余的元素处理掉(挂到对应的哈希桶中)       1.向系统索要空间补充内存池---&gt;成功---&gt;_startFree接受malloc的返回值---&gt;递归chunk_alloc()       2.如果1失败，从当前链表往后去找是否还有更大的内存块---&gt;找到了---&gt;补充到内存池---&gt;递归chunk_alloc()       3.使用一级空间配置器(内存不足应对措施)---&gt;递归chunk_alloc()   }}</code></pre><p>这种处理内存碎片的方式虽然解决了外部存在大量的内存碎片的问题，但是还是会有在哈希桶上挂的小碎片<br>​<br>可能有的地方叙述的不是很清楚，欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;STL是惠普实现的，其有多个版本，但都是在HP版本的基础上完成的&lt;/p&gt;
&lt;p&gt;STL是C++的标准模板库，包括数据结构和算法的软件框架
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.bingoxin.top/tags/C-C/"/>
    
  </entry>
  
</feed>
