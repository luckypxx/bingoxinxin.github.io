<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bingoxin&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.bingoxin.top/"/>
  <updated>2018-12-22T03:58:54.693Z</updated>
  <id>http://www.bingoxin.top/</id>
  
  <author>
    <name>bingoxin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面向对象or面向过程</title>
    <link href="http://www.bingoxin.top/2018/12/22/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1or%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"/>
    <id>http://www.bingoxin.top/2018/12/22/面向对象or面向过程/</id>
    <published>2018-12-22T03:58:54.000Z</published>
    <updated>2018-12-22T03:58:54.693Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java中的类集</title>
    <link href="http://www.bingoxin.top/2018/12/21/Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E9%9B%86/"/>
    <id>http://www.bingoxin.top/2018/12/21/Java中的类集/</id>
    <published>2018-12-21T14:44:51.000Z</published>
    <updated>2018-12-21T14:45:14.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java类集"><a href="#Java类集" class="headerlink" title="Java类集"></a>Java类集</h1><p>Java类集就是动态数组，类集的使用比较容易操作，但是类集的底层需要用到数据结构和多线程</p><p>所有的类集都在java.util包下<a id="more"></a></p><h3 id="Java类集的产生"><a href="#Java类集的产生" class="headerlink" title="Java类集的产生"></a>Java类集的产生</h3><p>Java类集是从JDK1.2开始应用的，用于解决数组定长问题</p><ul><li>Collection接口—<strong>单个对象</strong>保存的最顶层父接口</li></ul><p>Collection接口以及其子接口，在每次进行数据操作时只能对单个对象进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Iterable&lt;E&gt;</code>:迭代器接口（用于遍历集合）</p><p><code>Interface&lt;E&gt; iterator()</code>：取得集合的迭代器，JDK1.5之前没有泛型，则迭代器直接写在Collection接口中</p><ul><li>Collection接口中提供的核心方法</li></ul><p><strong>向类集中添加元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>取得接口的迭代器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Collection 接口只定义了存储数据的标准，但是无法区分存储类型。因此在实际中我们往往是由两个子接口List（允许数据重复）、Set（不允许数据重复）一般不直接使用Collection接口</p><h2 id="List接口—允许数据重复"><a href="#List接口—允许数据重复" class="headerlink" title="List接口—允许数据重复"></a>List接口—允许数据重复</h2><p>在进行单个集合处理时，优先考虑List接口</p><p>在List接口中，拓展了两个重要方法（List独有）</p><ul><li>根据索引取得下标数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>根据索引下标更改数据，返回原来的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br></pre></td></tr></table></figure><p>List接口有三个重要子类：ArrayList、Vector、LinkedList</p><p>List接口要想保存自定义类的对象，该类必须覆写<code>equals()</code>来使用<code>contains()</code>、<code>remove()</code></p><h3 id="ArrayList-Vector-LinkedList的区别"><a href="#ArrayList-Vector-LinkedList的区别" class="headerlink" title="ArrayList/Vector/LinkedList的区别"></a>ArrayList/Vector/LinkedList的区别</h3><ul><li>ArrayList与Vector的区别</li></ul><p>1、<strong>出现版本：</strong>ArrayList 在JDK1.2版本才出现，Vector在JDK1.0版本就已经出现</p><p>2、<strong>调用无参构造的区别：</strong>Vector在无参构造执行后将对象数组大小初始化为10，ArrayList采用懒加载策略，在构造方法阶段并不初始化数组，在第一次添加元素时才会初始化数组，大小为10</p><p>3、<strong>扩容策略：</strong>ArrayList在扩容时，会扩容到原来长度的1.5倍；Vector在扩容时，会扩容到原来的两倍</p><p>4、<strong>线程的安全性：</strong>ArrayList采用异步处理，线程不安全，效率较高；Vector采用在方法上加锁，线程安全，效率更低。（即便要使用线程安全的List也不使用Vector）</p><p>5、<strong>遍历：</strong>Vector支持较老的迭代器；ArrayList不支持</p><ul><li>ArrayList与Vector的共同点</li></ul><p>底层都使用数组实现，且都是List的子类</p><ul><li>ArrayList与LinkedList的区别</li></ul><p>LinkedList底层是双向链表，ArrayList的底层是数组</p><h2 id="Set接口—不允许数据重复"><a href="#Set接口—不允许数据重复" class="headerlink" title="Set接口—不允许数据重复"></a>Set接口—不允许数据重复</h2><p>Set接口没有扩充方法，常用子类有<code>HashSet</code>(无序存储)和<code>TreeSet</code>(有序存储)</p><h3 id="Comparable接口与Compartor接口"><a href="#Comparable接口与Compartor接口" class="headerlink" title="Comparable接口与Compartor接口"></a>Comparable接口与Compartor接口</h3><p>在Java中，若实现自定义类的比较，提供了一下两个接口：</p><p>java.lang.Comparable接口（内部比较器）:若一个类实现了Comparable接口，就表示该类可以进行比较并排序的。存放该类的Conllection或数组，可以直接通过<code>Collection.sort()</code>或Array.sort进行排序</p><p>实现了Comparable接口的类可以直接存放在TreeSet或TreeMap中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>返回值三种情况：</p><p>返回正数：当前对象大于目标对象</p><p>返回负数：当前对象小于目标对象</p><p>返回0：当前对象等于目标对象</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>底层是由哈希表和红黑树，允许存放null，无序储存</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>底层使用红黑树，不允许空值出现，允许储存</p><p>保存自定义类需实现Comparable接口或者传入比较器（compartor接口）</p><h3 id="HashSet和TreeSet的区别"><a href="#HashSet和TreeSet的区别" class="headerlink" title="HashSet和TreeSet的区别"></a>HashSet和TreeSet的区别</h3><p>1、<strong>底层实现不同：</strong>HashSet底层是由哈希表和红黑树，允许存放null，无序储存；TreeSet底层使用红黑树，不允许空值出现，允许储存</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java类集&quot;&gt;&lt;a href=&quot;#Java类集&quot; class=&quot;headerlink&quot; title=&quot;Java类集&quot;&gt;&lt;/a&gt;Java类集&lt;/h1&gt;&lt;p&gt;Java类集就是动态数组，类集的使用比较容易操作，但是类集的底层需要用到数据结构和多线程&lt;/p&gt;
&lt;p&gt;所有的类集都在java.util包下
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>叩开C++的大门</title>
    <link href="http://www.bingoxin.top/2018/06/05/%E5%8F%A9%E5%BC%80C-%E7%9A%84%E5%A4%A7%E9%97%A8/"/>
    <id>http://www.bingoxin.top/2018/06/05/叩开C-的大门/</id>
    <published>2018-06-05T03:57:30.000Z</published>
    <updated>2018-12-22T03:58:20.514Z</updated>
    
    <content type="html"><![CDATA[<h4 id="缺省函数"><a href="#缺省函数" class="headerlink" title="缺省函数"></a>缺省函数</h4><p>如果非要把缺省函数比作一个事物，它更像是一个备胎。</p><p>如果函数传参，就会将传过来的值赋值给形参</p><p>如果没有传参，则就会将缺省值传递给函数</p><p>关于缺省参数要注意以下几点：</p><blockquote><p>a.带缺省值的参数必须放在参数列表的最后面<br>b.缺省参数不能同时在函数声明和定义中出现，只能二者去一<br>c.缺省值必须是常量或者是全局变量<br>d.C语言不支持</p></blockquote><p>####函数重载</p><p>函数重载，即在同一作用域里，声明几个功能相同的函数，形参列表不同或返回值类型不同(参数列表中，参数个数和顺序相同)，即可构成函数重载</p><p>若只是返回值类型不同，不可构成函数重载，在这里也要注意：返回值不属于函数，参数属于函数</p><p>在C语言中，不会构成函数重载，只是由于C语言和C++的编译风格不同</p><p>在C语言中，编译完成后会在函数名前加上“_”，</p><p>在C++中，编译完成后会被修饰成由函数名，函数参数列表和返回值构成的一串特定的字符串，用于区分函数名相同的各个函数</p><p>####引用</p><p>引用，就相当于为一个变量取一个别名</p><p> int a=10;<br> int&amp; ra=a;<br>这就是引用的用法，ra和a的地址相同，变量存放的内容也相同</p><p>引用站在应用层，编译器不为其开辟空间</p><p>在使用引用时要注意：</p><blockquote><p>a.引用在定义时必须有初始化<br>b.一个变量可以有多个引用<br>c.引用一旦引用一个实体，再不能引用其他实体</p></blockquote><p>若初始变量被const修饰，其引用在定义时也要被const修饰，而初始变量就相当于常数</p><p>接下来再来说一下数组引用的代码格式：</p><p> int (&amp;array)[3]={0}; //注意符号优先级</p><p>引用可以作为函数的参数和返回值</p><p>在函数传参时，从底层来看，传引用和传指针效率相差不多</p><p>但是引用和指针还是有区别的，如下：</p><blockquote><p>引用在定义时必须初始化，而指针没有要求<br>指针可以为空，而引用不可以<br>引用一旦有所指向就不能更改，而指针指向一个变量后，还可以更改指向另一个类型相同的变量<br>在sizeof中含义不同：引用的结果为引用类型的大小，但指针始终为4(在Win10，vs2013的环境下)<br>引用自加改变的是变量的大小，指针自加改变的是指针的指向<br>有多级指针，没有多级引用<br>指针需要手动寻址，引用可以通过编译器寻址<br>使用引用更为安全</p></blockquote><p>那么引用相当于void* const类型的指针(可以改变其内容，不可改变其指向)</p><p>####命名空间</p><p>命名空间可以将标识符本地化，避免命名冲突或名字污染</p><p>首先我们先来了解一下命名空间的定义方式：</p><p> namespace N</p><p>关于命名空间和作用域，不得不再多说几句： </p><blockquote><p>a.若一个命名空间为N，“N::”表示其空间作用域，“::”为作用限定符<br>b.相同作用域定义的命名空间名称可以相同，编译器会自动将其合成<br>c.命名空间可以嵌套(“NN1::”)</p></blockquote><p>仅仅学了这几个概念，就觉得C++功能的实现比C语言简单许多</p><p>终于敲开C++的大门啦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;缺省函数&quot;&gt;&lt;a href=&quot;#缺省函数&quot; class=&quot;headerlink&quot; title=&quot;缺省函数&quot;&gt;&lt;/a&gt;缺省函数&lt;/h4&gt;&lt;p&gt;如果非要把缺省函数比作一个事物，它更像是一个备胎。&lt;/p&gt;
&lt;p&gt;如果函数传参，就会将传过来的值赋值给形参&lt;/p&gt;
&lt;p&gt;如
      
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.bingoxin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>函数调用约定</title>
    <link href="http://www.bingoxin.top/2018/06/05/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    <id>http://www.bingoxin.top/2018/06/05/函数调用约定/</id>
    <published>2018-06-05T03:55:09.000Z</published>
    <updated>2018-12-22T03:56:33.993Z</updated>
    
    <content type="html"><![CDATA[<p>在学习C语言的时候，总是碰到__cdecl，一直都只是知道他是一种函数调用约定，</p><p>今天来总结一下函数的调用约定~</p><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><h3 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h3><p>当一个函数被调用时，函数的参数会被传递给调用的函数和返回值会被返回给调用函数。函数调用约定就是描述参数是怎么传递和由谁平衡堆栈的，当然还有返回值。<br>​<br>1.<font color="red" size="3">__cdecl</font><br>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.参数是从右向左传递的，也是从右向左放在堆栈中的</span><br><span class="line"></span><br><span class="line">2.堆栈平衡是由调用函数来执行的</span><br><span class="line"></span><br><span class="line">3.函数的前面会加一个前缀_(_Test)</span><br></pre></td></tr></table></figure><p>2.<font color="red" size="3">__stdcall</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.参数是从右向左传递的，也是从右向左放在堆栈中的</span><br><span class="line"></span><br><span class="line">2.堆栈平衡是由被调用函数来执行的</span><br><span class="line"></span><br><span class="line">3.在函数名前加下划线修饰，在函数名的后面由@来修饰并、加上栈需要的字节数的空间(_Test@8)</span><br></pre></td></tr></table></figure><p>3.<font color="red" size="3">__fastcall</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.参数放在寄存器中，而不是栈中</span><br><span class="line"></span><br><span class="line">2.最左边的两个不大于4个字节的参数分别放在ecx和edx寄存器。当寄存器用完的时候，其余参数仍然从右往左的顺序压栈。</span><br></pre></td></tr></table></figure><p>4.<font color="red" size="3">__thiscall</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.C++成员函数的默认调用约定，用于限制成员函数</span><br><span class="line"></span><br><span class="line">2.参数从右向左被推入堆栈</span><br><span class="line"></span><br><span class="line">3.通过ecx寄存器来传递this指针，将其传递到X86结构上，而不是堆栈上</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习C语言的时候，总是碰到__cdecl，一直都只是知道他是一种函数调用约定，&lt;/p&gt;
&lt;p&gt;今天来总结一下函数的调用约定~&lt;/p&gt;
&lt;h2 id=&quot;正文：&quot;&gt;&lt;a href=&quot;#正文：&quot; class=&quot;headerlink&quot; title=&quot;正文：&quot;&gt;&lt;/a&gt;正文：&lt;/h
      
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.bingoxin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>数据库基本操作</title>
    <link href="http://www.bingoxin.top/2018/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.bingoxin.top/2018/06/03/数据库基本操作/</id>
    <published>2018-06-03T03:50:34.000Z</published>
    <updated>2018-12-22T03:54:18.195Z</updated>
    
    <content type="html"><![CDATA[<p>刚刚接触数据库，安装了MYSQL5.7，大概需要二十分钟</p><p>接下来，就来说一下关于数据库的一些知识吧~</p><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><blockquote><h2 id="为什么要有数据库？"><a href="#为什么要有数据库？" class="headerlink" title="为什么要有数据库？"></a>为什么要有数据库？</h2></blockquote><p>我们都知道，文件就可以存储数据库</p><p>但是文件存储存在以下几个弊端：</p><blockquote><p>1.文件的安全性</p><p>2.文件不利查询以及对数据进行管理</p><p>3.文件不适合存放海量数据</p><p>4.文件在程序中控制不方便</p></blockquote><p>文件一般存储于内存和磁盘中，内存存储数据的优点是速度快，缺点是一旦断电数据就会消失</p><p>在学习数据库操作语句之前我们应该先搞清楚数据库和表的关系：</p><p>举个栗子：数据库就像图书馆的不同类别的馆，像是通信类、计算机类、自然科学类等等，</p><p>而表就像每个馆里放的书架，不知道这样来说够不够形象 0.0</p><p>接下来，就来说一下</p><h4 id="SQL的分类"><a href="#SQL的分类" class="headerlink" title="SQL的分类:"></a>SQL的分类:</h4><blockquote><p>DDL 数据定义：create,drop,alter</p><p>DML 数据操纵：insert,delete,update</p><p>DML中单独分出来的DQL：select（数据查询）</p><p>DCL 数据控制：grant,revoke,commit</p></blockquote><ul><li><p>创建数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名;</span><br></pre></td></tr></table></figure></li><li><p>进入数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> 数据库名;</span><br></pre></td></tr></table></figure></li><li><p>显示所有数据库：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;show databases;&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;create table 表名 (表里存放的内容);&gt;</span><br><span class="line">&lt;例如：create table student (id int,name varchar(32));&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是：表中内容的定义方式与C语言存在差别，数据类型放在数据名的后面，字符型数组在定义时使用()而不是[]。</p></li><li><p>显示数据库中的表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;show tables;&gt;</span><br></pre></td></tr></table></figure></li><li><p>描绘表中的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;desc 表名;&gt;</span><br></pre></td></tr></table></figure></li><li><p>在表中插入数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert into 表名(表中内容的定义的变量名) values (变量的具体内容);&gt;</span><br><span class="line"></span><br><span class="line">&lt;例如：insert into student (id,name) values (1,&apos;ht&apos;)；&gt;</span><br></pre></td></tr></table></figure></li><li><p>在表中查询数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;select * from 表名;&gt;</span><br></pre></td></tr></table></figure></li><li><p>查看警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;show warnings;&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="每条指令输入完成都要以-“-”-结尾，否则计算机会认为输入的语句并未结束"><a href="#每条指令输入完成都要以-“-”-结尾，否则计算机会认为输入的语句并未结束" class="headerlink" title="每条指令输入完成都要以 “;” 结尾，否则计算机会认为输入的语句并未结束"></a>每条指令输入完成都要以 “;” 结尾，否则计算机会认为输入的语句并未结束</h5><p>以上部分指令操作的操作界面如下 ：</p><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/database/data1.png" height="300" width="500"><br></div><br><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/database/data2.png" height="150" width="250"><br></div><ul><li>字符集(出现乱码首先考虑字符集的问题)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名 <span class="keyword">charset</span>=utf8;</span><br></pre></td></tr></table></figure><p>使用语句<code>show create database 库名</code>来查看创建库的语句，会出现以下句子：</p><p><code>CREATE DATABASE db1 /*!40100 DEFAULT CHARACTER SET utf8 */</code></p><p>40100是版本号</p><ul><li>校验规则</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名 <span class="keyword">charset</span>=utf8 <span class="keyword">collate</span> utf8_general_ci;</span><br></pre></td></tr></table></figure><h3 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h3><ul><li>备份</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -P3306 -u root -p 密码 -B 数据库名;</span><br></pre></td></tr></table></figure><ul><li>恢复</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source D:/mysql-5.7.22/mytest.sql;</span><br></pre></td></tr></table></figure><h3 id="查看连接情况"><a href="#查看连接情况" class="headerlink" title="查看连接情况"></a>查看连接情况</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span>;</span><br></pre></td></tr></table></figure><h3 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h3><ul><li>创建表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名&#123;</span><br><span class="line">列名<span class="number">1</span> 类型，</span><br><span class="line">列名<span class="number">2</span> 类型，</span><br><span class="line">...</span><br><span class="line">&#125;<span class="built_in">character</span> <span class="keyword">set</span> 字符集 <span class="keyword">collate</span> 校验规则 <span class="keyword">engine</span> 存储引擎;</span><br></pre></td></tr></table></figure><ul><li>描述表的结构</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">des 表名;</span><br></pre></td></tr></table></figure><ul><li>修改表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span>(<span class="keyword">column</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚刚接触数据库，安装了MYSQL5.7，大概需要二十分钟&lt;/p&gt;
&lt;p&gt;接下来，就来说一下关于数据库的一些知识吧~&lt;/p&gt;
&lt;h2 id=&quot;正文：&quot;&gt;&lt;a href=&quot;#正文：&quot; class=&quot;headerlink&quot; title=&quot;正文：&quot;&gt;&lt;/a&gt;正文：&lt;/h2&gt;&lt;blo
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://www.bingoxin.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>判断两个无头结点的单链表是否相交</title>
    <link href="http://www.bingoxin.top/2018/04/01/%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%97%A0%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/"/>
    <id>http://www.bingoxin.top/2018/04/01/判断两个无头结点的单链表是否相交/</id>
    <published>2018-04-01T14:51:08.000Z</published>
    <updated>2018-12-22T03:49:06.071Z</updated>
    
    <content type="html"><![CDATA[<p>在笔试和面试中，常常会出现关于数据结构中的单链表的考题，<br>今天就来说一下关于判断两个无头结点的单链表是否相交的代码</p><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><p>无头结点的单链表自身分为两种情况，带环和不带环，</p><p>l1,l2分别代表两条链表，</p><p>用真值表来表示，1表示带环，0表示不带环</p><p>l1 0 0 1 1<br>l2 0 1 0 1</p><p>首先我们来讨论一下较为简单的不带环的情况：</p><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/data-structure/List1.gif" height="300" width="500"><br></div><p>如图所示，共有两种情况，即相交和不相交。</p><p>相交分为三种情况（可以视为一条链表的尾部分别和另一条链表的不同部分相交）：即头部、中间和尾部。</p><p>由图我们可以看出，若两条链表相交，他们的尾结点一定相同。</p><p>这可以作为我们判断两结点是否相交的判断点。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 判断两个单链表是否相交---链表不带环 </span><br><span class="line">int IsCrossWithoutCircle(PNode pHead1, PNode pHead2)//pHead1代表链表1，pHead2代表链表2</span><br><span class="line">&#123;</span><br><span class="line">PNode pTail1 = pHead1;//定义链表1的尾结点，并让其指向链表1的头结点</span><br><span class="line">PNode pTail2 = pHead2;//定义链表2的尾结点，并让其指向链表2的头结点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//两链表只要有一个为空即不相交</span><br><span class="line">if (NULL == pTail1 || NULL == pTail2)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">//遍历链表1，找到尾结点</span><br><span class="line">while (pTail1-&gt;_pNext)</span><br><span class="line">&#123;</span><br><span class="line">pTail1 = pTail1-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//遍历链表2，找到尾结点</span><br><span class="line">while (pTail2-&gt;_pNext)</span><br><span class="line">&#123;</span><br><span class="line">pTail2 = pTail2-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//判断两条链表的尾结点是否相等</span><br><span class="line">if (pTail1 == pTail2)</span><br><span class="line">&#123;</span><br><span class="line">return 1;//相等即相交，返回1</span><br><span class="line">&#125;</span><br><span class="line">return 0;//不相等即不相交，返回0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建的两条链表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//构建两条链表</span><br><span class="line">PNode pHead1;</span><br><span class="line">PNode pHead2;</span><br><span class="line"></span><br><span class="line">SListInit(&amp;pHead1);//链表初始化</span><br><span class="line">SListPushBack(&amp;pHead1, 1);//链表尾插</span><br><span class="line">SListPushBack(&amp;pHead1, 2);</span><br><span class="line">SListPushBack(&amp;pHead1, 3);</span><br><span class="line"></span><br><span class="line">SListInit(&amp;pHead2);</span><br><span class="line">SListPushBack(&amp;pHead2, 1);</span><br><span class="line">SListPushBack(&amp;pHead2, 2);</span><br><span class="line">SListPushBack(&amp;pHead2, 3);</span><br><span class="line"></span><br><span class="line">while (pHead1-&gt;_pNext)</span><br><span class="line">&#123;</span><br><span class="line">pHead1 = pHead1-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line">pHead1-&gt;_pNext = pHead2;</span><br></pre></td></tr></table></figure><p>该种情况为相交的第三种情况，测试结果如下:</p><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/data-structure/List2.gif" height="300" width="500"><br></div><p>输出1，则其相交，其他情况不再一一描述。</p><p>带环的情况也比较多，不过经过分析也不会那么复杂。</p><p>接下来我们来画图进行分析</p><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/data-structure/List3.gif" height="300" width="500"><br></div><p>在画图过程中，我们可以发现：不会出现其中一条链表带环，且两条链表相交的情况。<br>由图我们可以得知，两个带环的链表相交分为，环内相交和环外相交两种。</p><p>在判断两链表是否相交的过程中，我们还需要实现判断链表是否带环，</p><p>判断链表是否带环：</p><p>1、定义两个指针，一个一次走两个结点（pFast），一个一次走一个结点(pSlow)</p><p>2、若有环，pFast会与pSlow相遇，此时返回两指针的地址；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若无环，如果pFast==NULL，即可证明其无环，返回空指针</span><br></pre></td></tr></table></figure><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PNode IsListwithCircle(PNode pHead)</span><br><span class="line">&#123;</span><br><span class="line">PNode pFast = pHead;</span><br><span class="line">PNode pSlow = pHead;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (NULL == pHead)</span><br><span class="line">&#123;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while (pFast-&gt;_pNext)</span><br><span class="line">&#123;</span><br><span class="line">pFast = pFast-&gt;_pNext-&gt;_pNext;</span><br><span class="line">pSlow = pSlow-&gt;_pNext;</span><br><span class="line">if (pFast == pSlow)</span><br><span class="line">return pFast;</span><br><span class="line">&#125;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着判断两个链表是否相交：</p><p>大概思路就是：让两个链表的相遇点一个保持不动，一个往后走（每次走一步），若两个相遇点相遇，即可说明两条链表相交。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int IsCrossWithCircle(PNode pHead1, PNode pHead2)</span><br><span class="line">&#123;</span><br><span class="line">PNode pMeetNode1 = NULL;</span><br><span class="line">PNode pMeetNode2 = NULL;</span><br><span class="line">PNode pCur = NULL;</span><br><span class="line"></span><br><span class="line">if (NULL == pHead1 || NULL == pHead2)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pMeetNode1 = IsListwithCircle(pHead1);</span><br><span class="line">pMeetNode2 = IsListwithCircle(pHead2);</span><br><span class="line">pCur = pMeetNode1;</span><br><span class="line"></span><br><span class="line">//其中一个链表带环或两条链表均不带环</span><br><span class="line">if (NULL == pMeetNode1 || NULL == pMeetNode2)</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">//两条链表均带环</span><br><span class="line">while (pMeetNode1 != pMeetNode2)</span><br><span class="line">&#123;</span><br><span class="line">pCur = pCur-&gt;_pNext;</span><br><span class="line">if (pCur == pMeetNode1)</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于测试结果就不在展示了</p><h2 id="寄语"><a href="#寄语" class="headerlink" title="寄语"></a>寄语</h2><p>　　判断两条链表是否相交经常会出现在面试题中，如果把图画出来写程序会更有思路。</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在笔试和面试中，常常会出现关于数据结构中的单链表的考题，&lt;br&gt;今天就来说一下关于判断两个无头结点的单链表是否相交的代码&lt;/p&gt;
&lt;h2 id=&quot;正文：&quot;&gt;&lt;a href=&quot;#正文：&quot; class=&quot;headerlink&quot; title=&quot;正文：&quot;&gt;&lt;/a&gt;正文：&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="面试题分析" scheme="http://www.bingoxin.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>自定义类型</title>
    <link href="http://www.bingoxin.top/2018/03/05/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/"/>
    <id>http://www.bingoxin.top/2018/03/05/自定义类型/</id>
    <published>2018-03-05T14:49:02.000Z</published>
    <updated>2018-12-21T14:50:00.715Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么存在内存对齐"><a href="#为什么存在内存对齐" class="headerlink" title="为什么存在内存对齐"></a>为什么存在内存对齐</h3><blockquote><p>1.<strong>平台原因：</strong>不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常</p></blockquote><blockquote><p>2.<strong>性能原因：</strong>数据结构(尤其是栈)应该尽可能地在自然边界上对齐<br>–&gt;若访问未对齐的内存，处理器需要做两次内存访问；而对齐的内存访问仅需要访问一次就可以拿到数据</p></blockquote><h3 id="结构体内存对齐规则"><a href="#结构体内存对齐规则" class="headerlink" title="结构体内存对齐规则"></a>结构体内存对齐规则</h3><p>Linux中，默认对齐数是4</p><p>Windows下的vs，默认对齐数是8</p><blockquote><p>1.第一个成员在与结构体变量偏移量为0的地址处</p><p>2.其他成员变量要对齐到某个数字(对齐数)的整数倍的地址处—&gt;对齐数=编译器默认的一个对齐数与该成员大小的较小值</p><p>3.结构体总大小为最大对齐数的整数倍</p><p>4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数的整数倍</p></blockquote><p>可以说，内存对齐是用时间来弥补空间</p><h3 id="结构体传参"><a href="#结构体传参" class="headerlink" title="结构体传参"></a>结构体传参</h3><p>结构体传参时，考虑变量可能过大，不要传结构体变量，要传结构体指针</p><h3 id="位段"><a href="#位段" class="headerlink" title="位段"></a>位段</h3><p>位段的声明和结构是类似的，有两个不同点：</p><blockquote><p>1.位段的成员必须是int、unsigned int 或 signed int</p><p>2.位段的成员后边有一个冒号和一个数字</p></blockquote><p>位段成员后面的数字表示bit位，位段可以节省空间</p><p><strong>开辟空间方式</strong></p><p>由于位段里变量为int类型，因此在开辟空间时，一次开辟4个字节的空间，即32个bit位。</p><p>需要注意的是：<strong>位段是不可以跨平台的、位段不存在对齐</strong></p><h3 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h3><p>枚举，即一一列举</p><p>枚举列举的是枚举常量，第一个常量为0，之后的常量大小依次+1</p><p><strong>枚举的优点</strong></p><ul><li>增加代码的可读性和可维护性</li><li>和#define定义的标识符比较，枚举有类型检查，更加严谨</li><li>防止命名污染</li><li>便于调试</li><li>使用方便，一次可以定义多个常量</li></ul><h3 id="联合-共用体"><a href="#联合-共用体" class="headerlink" title="联合(共用体)"></a>联合(共用体)</h3><p>在共用体中定义的变量共用一块内存</p><p><strong>空间计算</strong></p><ul><li>联合的大小至少是最大成员的大小</li><li>当最大成员不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍</li></ul><h3 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h3><p>小端：低字节放低地址处，高字节放高地址处</p><p>大端：低字节放高地址，高字节放低地址</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址是由点分十进制的方式处理的</p><p>IP地址实际是整型的十进制数字，将十进制数字的每个字节转化成转化成十进制，再用.连接，就是IP地址</p><p>代码实现：<br>​    #include &lt;stdio.h&gt;<br>​    #include &lt;Windows.h&gt;<br>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">union un</span><br><span class="line">&#123;</span><br><span class="line">unsigned int num;</span><br><span class="line">struct </span><br><span class="line">&#123;</span><br><span class="line">unsigned char a;</span><br><span class="line">unsigned char b;</span><br><span class="line">unsigned char c;</span><br><span class="line">unsigned char d;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">union un myip;</span><br><span class="line">myip.num = 716872929;</span><br><span class="line">printf(&quot;%d.%d.%d.%d&quot;, myip.d, myip.c, myip.b, myip.a);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎交流~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;为什么存在内存对齐&quot;&gt;&lt;a href=&quot;#为什么存在内存对齐&quot; class=&quot;headerlink&quot; title=&quot;为什么存在内存对齐&quot;&gt;&lt;/a&gt;为什么存在内存对齐&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;1.&lt;strong&gt;平台原因：&lt;/strong&gt;不是所有的
      
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.bingoxin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>函数栈桢</title>
    <link href="http://www.bingoxin.top/2017/12/13/%E5%87%BD%E6%95%B0%E6%A0%88%E6%A1%A2/"/>
    <id>http://www.bingoxin.top/2017/12/13/函数栈桢/</id>
    <published>2017-12-13T14:36:59.000Z</published>
    <updated>2018-12-21T15:07:49.944Z</updated>
    
    <content type="html"><![CDATA[<p>在做面试题的时候，我遇到了这样一道题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">int tmp=10;</span><br><span class="line">int* p=(int*)(*(&amp;tmp+1));</span><br><span class="line">*(p-1)=20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a=0;</span><br><span class="line">fun();</span><br><span class="line">printf(&quot;%d&quot;,a);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一眼看去，a的值好像并未发生改变。但是实际上并不是我们看到的这么简单哦~<a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在解这道题时，我们需要搞懂函数调用是怎么实现的？？？</p><p>接下来我就来一步一步讲解</p><h3 id="函数栈桢地址使用"><a href="#函数栈桢地址使用" class="headerlink" title="函数栈桢地址使用"></a>函数栈桢地址使用</h3><p>函数栈桢的使用是由高地址向低地址使用的</p><h3 id="函数压栈"><a href="#函数压栈" class="headerlink" title="函数压栈"></a>函数压栈</h3><p>函数压栈：在栈顶处不断放入数据</p><h3 id="函数调用时使用的寄存器"><a href="#函数调用时使用的寄存器" class="headerlink" title="函数调用时使用的寄存器"></a>函数调用时使用的寄存器</h3><ul><li>esp：函数栈顶的地址，随着压栈的进行，esp会向低地址处移动</li><li>ebp：函数栈底的地址</li></ul><h3 id="在调用main函数之前，还调用了一个函数叫做mainCRTStart"><a href="#在调用main函数之前，还调用了一个函数叫做mainCRTStart" class="headerlink" title="在调用main函数之前，还调用了一个函数叫做mainCRTStart()"></a>在调用main函数之前，还调用了一个函数叫做mainCRTStart()</h3><p>mainCRTStart是用来调用main函数的一个函数</p><p>接下来，我将以下面的代码为例，来讲解函数调用过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int Add(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">int z = 0;</span><br><span class="line">z = x + y;</span><br><span class="line">return z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">int ret = 0;</span><br><span class="line">ret = Add(a,b);</span><br><span class="line">printf(&quot;%d&quot;,ret);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h2 id="调用mainCRTStart"><a href="#调用mainCRTStart" class="headerlink" title="调用mainCRTStart()"></a>调用mainCRTStart()</h2><p>以调用mainCRTStart()来调用main函数，此时ebp在栈底，esp在栈顶。</p><h2 id="用汇编代码来看"><a href="#用汇编代码来看" class="headerlink" title="用汇编代码来看"></a>用汇编代码来看</h2><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/%E5%87%BD%E6%95%B0%E6%A0%88%E6%A1%A2/%E6%8D%95%E8%8E%B75.PNG" height="500" width="500"><br></div><p>注意：函数栈桢图中的序号与步骤号对应，汇编代码前的红色数字与步骤号也是对应的，一个步骤可能执行多条语句</p><p><strong>第一步</strong></p><p>将ebp的值压在栈顶上(红色方框)，esp由esp1移到esp2的位置</p><p><strong>第二步</strong></p><p>将esp的值赋给ebp，即ebp由ebp1的位置移到ebp2的位置</p><p><strong>第三步</strong></p><p>esp-4Ch:esp由esp2的位置移到esp3的位置，此时为esp与ebp维护的空间是为main函数开辟了空间</p><p><strong>第四步</strong></p><p>将ebx、esi、edi依次压入栈中，esp随着每次压栈向低地址处移动，则esp由esp3的位置移到esp4的位置</p><p><strong>第五步</strong></p><blockquote><p>将edi放到ebp-4Ch的位置上，即将edi移动到edi1的位置，</p></blockquote><blockquote><p>将eax的内容拷贝ecx存放内容次，放到edi向下的内容中去。将为main函数开辟的空间全部初始化成随机值</p></blockquote><p><strong>第六步</strong></p><p>为ebp-4地址处赋值，为10(a)</p><p><strong>第七步</strong></p><p>为ebp-8地址处赋值，为20(b)</p><p><strong>第八步</strong></p><p>为ebp-12地址处赋值，为0(ret)</p><p><strong>第九步</strong></p><blockquote><p>将ebp-8地址处的值赋给寄存器eax，并将eax压入栈中(_b)</p></blockquote><blockquote><p>将ebp-4地址处的值赋给寄存器ecx，并将ecx压入栈中(_a)</p></blockquote><blockquote><p>将call指令下一条指令的地址压入栈中</p></blockquote><blockquote><p>该过程进行完，esp由esp4的位置移动到esp5的位置</p></blockquote><p><strong>第十步</strong></p><p>进入Add函数中，将main函数的ebp位置压入栈中，esp由esp5位置移到esp5的位置</p><p><strong>第十一步</strong></p><p>将ebp移动到esp的位置，即将ebp由ebp2的位置移到ebp3的位置</p><p><strong>第十二步</strong></p><p>esp-44h：为Add函数开辟空间</p><p><strong>第十三步</strong></p><p>依次将ebx、esi、edi压入栈中，则esp由esp7的位置移到esp8的位置</p><p><strong>第十四步</strong></p><p>将edi移动到edi1的位置(橙色)，并将Add函数开辟的空间初始化为随机值</p><p><strong>第十五步</strong></p><p>将ebp3-4的位置初始化成0（z）</p><p><strong>第十六步</strong></p><blockquote><p>将ebp+8的位置的值(a)放入eax寄存器中</p></blockquote><blockquote><p>将eax(x)中的值加ebp+0Ch(y)，将结果放在eax寄存器中</p></blockquote><blockquote><p>将eax中的值，赋给ebp-4(z)</p></blockquote><p><strong>第十七步</strong></p><p>将ebp-4(z)中的值放入eax寄存器中</p><p><strong>第十八步</strong></p><p>将edi、esi、ebx弹出栈，将esp由eap8的位置移动到esp7的位置</p><p><strong>第十九步</strong></p><p>将esp放在ebp的位置，即esp由esp7的位置移动到esp9的位置</p><p><strong>第二十步</strong></p><p>将ebp弹出，ebp移动至main函数的栈底位置，即esp2的位置</p><p><strong>第二十一步</strong></p><p>将寄存器eax中存放的值，赋给ebp-0Ch(ret)</p><h3 id="面试题解答"><a href="#面试题解答" class="headerlink" title="面试题解答"></a>面试题解答</h3><p>其实a的值是在调用函数fun时，通过指针赋值发生的改变</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做面试题的时候，我遇到了这样一道题：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void fun()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int tmp=10;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int* p=(int*)(*(&amp;amp;tmp+1));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	*(p-1)=20;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int a=0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fun();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	printf(&amp;quot;%d&amp;quot;,a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一眼看去，a的值好像并未发生改变。但是实际上并不是我们看到的这么简单哦~
    
    </summary>
    
    
      <category term="C语言" scheme="http://www.bingoxin.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言-操作符</title>
    <link href="http://www.bingoxin.top/2017/11/12/C%E8%AF%AD%E8%A8%80-%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://www.bingoxin.top/2017/11/12/C语言-操作符/</id>
    <published>2017-11-12T10:08:58.000Z</published>
    <updated>2018-12-09T10:13:52.314Z</updated>
    
    <content type="html"><![CDATA[<p>对于刚接触C语言的人来说，一提到操作符，可能也只有==、+、-、*等等。今天就来了解一下操作符的知识。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>操作符包括算术操作符、移位操作符、位操作符、赋值、单目操作符。关系操作符、逻辑操作符、条件操作符。逗号操作符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">算术操作符有：加（+）、减（-）、乘（*）、除（/）、取模（%）。</span><br></pre></td></tr></table></figure><p>在这些操作符中，需要注意的是除（/）和取模（%）的使用：</p><a id="more"></a><p>1、 浮点数相除是浮点数，整数相除是整数，浮点数除以整数为浮点数。</p><p>2、 取模（%）两边都应为整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">移位操作符有：左移（&lt;&lt;）和右移（&gt;&gt;）。</span><br></pre></td></tr></table></figure><p>在说这些之前，我们应该了解什么是源码、反码和补码。</p><p>电脑一般都是32位的，则在编程软件中，数字的二进制也是32位。正数在电脑中以源码保存，负数在电脑中以补码保存。正数的源码最高位是0，负数的源码最高位是1。正数的源码、反码、补码都相同。负数的反码是在符号位不变的基础上，其他位取反。其补码为反码+1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例如：1源码为0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">      1反码为0000 00000000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">      1补码为0000 00000000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">     -1源码为1000 00000000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">     -1反码为1111 11111111 1111 1111 1111 1111 1110</span><br><span class="line"></span><br><span class="line">     -1补码是1111 11111111 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure><p>接下来再说左移（&lt;&lt;），末位补0，最高位溢出。</p><p>例如：a=1,a&lt;&lt;2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a：00000000 0000 0000 0000 0000 0000 000100</span><br><span class="line"></span><br><span class="line">  溢出                                    补0</span><br><span class="line"></span><br><span class="line">则a&lt;&lt;2：0000 0000 0000 0000 0000 0000 0000 0100</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  int a = 1;</span><br><span class="line"></span><br><span class="line">  printf(&quot;a=%d\n&quot;,a);</span><br><span class="line"></span><br><span class="line">  a = a &lt;&lt; 2;</span><br><span class="line"></span><br><span class="line">  printf(&quot;a&lt;&lt;2=%d\n&quot;,a);</span><br><span class="line"></span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右移（&gt;&gt;）分为逻辑右移和算术右移。逻辑右移是左边补0，右边舍弃。算术右移是最高位补符号位，右边舍弃。经常使用的是算术右移。</p><p>例如：a=1，a&gt;&gt;2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a: 000000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">补符号位                                   舍弃</span><br><span class="line"></span><br><span class="line">a&lt;&lt;2: 0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  int a = 1;</span><br><span class="line"></span><br><span class="line">  printf(&quot;a=%d\n&quot;,a);</span><br><span class="line"></span><br><span class="line">  a = a &gt;&gt; 2;</span><br><span class="line"></span><br><span class="line">  printf(&quot;a&gt;&gt;2=%d\n&quot;,a);</span><br><span class="line"></span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">位操作符有三种，分别是：与（&amp;）、或（|），异或（^）的原则进行计算。</span><br></pre></td></tr></table></figure><p>与（&amp;）就是两个数的补码，每位进行比较，按照有0则为0，同为1则是1的原则进行计算。</p><p>异或（^）就是两个数的补码，每位进行比较，按照相同为0，不同为1的原则进行计算。</p><p>先看下面这段例程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int a = 3;</span><br><span class="line"></span><br><span class="line">    int b = 5;</span><br><span class="line"></span><br><span class="line">    printf(&quot;a&amp;b=%d\n&quot;,a&amp;b);</span><br><span class="line"></span><br><span class="line">    printf(&quot;a|b=%d\n&quot;,a|b);</span><br><span class="line"></span><br><span class="line">    printf(&quot;a^b=%d\n&quot;,a^b);</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a的补码是:0000 0000 0000 00000000 0000 0000 0011</p><p>b的补码是:0000 0000 0000 0000 0000 0000 0000 0101</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">则    a&amp;b=0000 0000 0000 0000 0000 0000 00000001=1</span><br><span class="line"></span><br><span class="line">      a|b=0000 0000 0000 0000 0000 0000 0000 0111=7</span><br><span class="line"></span><br><span class="line">      a^b=0000 0000 0000 0000 0000 0000 0000 0110=6</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">赋值中包括就是我们常见的=，还包括复合赋值操作符有+=、-=、*=、/=、%=、&lt;&lt;=、&gt;&gt;=、&amp;=、^=、|=。</span><br></pre></td></tr></table></figure><p>a+=2表示a=a+2，即操作符两边的数先进行计算再将计算结果赋值到操作数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关系操作符有!=、&lt;=、&gt;=、==、&lt;、&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单目操作符有！、-、+、&amp;、sizeof、~、++、--、*。</span><br></pre></td></tr></table></figure><p>！表示非，例如！（2=2），2=2为真，则！（2=2）为假。</p><p>-表示操作数的负值，-1也就是我们所说的负数。</p><p>+表示操作数的正值，一般被省略。</p><p>&amp;表示操作数的地址，例如：</p><p>int a = 10;</p><p>int* b = &a;</p><p>sizeof用于计算该操作数或表达式的字节数，初学者会认为这是一个函数，这是一个误区。</p><p>~用于整型求补操作，即将该操作数的二进制进行转换，1变为0,0变为1。</p><p>++用于操作数的自加，每次加1，++a表示先自加在使用该操作数，a++表示先使用该操作数再进行自加。</p><p><em>表示间接访问操作符，在指针中使用。</em>a表示访问a指向的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑操作符有&amp;&amp;（和）和||（或）</span><br></pre></td></tr></table></figure><p>在这里需要注意的是要和位操作符进行区分：</p><p>和即所有条件为真且为真，一个条件为假就是假</p><p>或即一个为真即为真，全部为假才是假。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件操作符包括三个部分：a？b : c</span><br></pre></td></tr></table></figure><p>a为一个判断条件，若a为真则执行b语句，若a为假则执行c语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逗号操作符使用很频繁，逗号操作符把多个表达式分隔开，表达式从左往右依次计算。</span><br></pre></td></tr></table></figure><h2 id="寄语"><a href="#寄语" class="headerlink" title="寄语"></a>寄语</h2><p>　　可能关于操作符的叙述不是很详细，欢迎交流！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于刚接触C语言的人来说，一提到操作符，可能也只有==、+、-、*等等。今天就来了解一下操作符的知识。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;p&gt;操作符包括算术操作符、移位操作符、位操作符、赋值、单目操作符。关系操作符、逻辑操作符、条件操作符。逗号操作符。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;算术操作符有：加（+）、减（-）、乘（*）、除（/）、取模（%）。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这些操作符中，需要注意的是除（/）和取模（%）的使用：&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.bingoxin.top/tags/C-C/"/>
    
  </entry>
  
</feed>
