<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bingoxin&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.bingoxin.top/"/>
  <updated>2018-12-13T11:35:30.458Z</updated>
  <id>http://www.bingoxin.top/</id>
  
  <author>
    <name>bingoxin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊天室项目</title>
    <link href="http://www.bingoxin.top/2019/01/04/%E8%81%8A%E5%A4%A9%E5%AE%A4%E9%A1%B9%E7%9B%AE/"/>
    <id>http://www.bingoxin.top/2019/01/04/聊天室项目/</id>
    <published>2019-01-04T07:27:52.000Z</published>
    <updated>2018-12-13T11:35:30.458Z</updated>
    
    <content type="html"><![CDATA[<p>socket需要有服务器端和客户端</p><p>客户端在连接服务器时，需要指定服务器的IP（标识电脑）和端口号（标识电脑上的具体某个应用）</p><p>通信的前提是：要创建基站，并与基站建立连接。 </p><a id="more"></a><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p><strong>Scoket类</strong></p><ul><li>绑定指定域名、端口号的服务器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Socket</span><span class="params">(String host, <span class="keyword">int</span> port, InetAddress localAddr,<span class="keyword">int</span> localPort)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>获取客户端输入流，读取服务器发来的消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>获取客户端输出流，向服务器发送消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> OutputStream <span class="title">getOutputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><h4 id="基站类—ServerSocket"><a href="#基站类—ServerSocket" class="headerlink" title="基站类—ServerSocket"></a>基站类—ServerSocket</h4><ul><li>默认绑定本地IP：127.0.0.1，以及指定端口号。在本机根据指定端口号创建服务器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>等待客户端连接，线程阻塞，当有客户连接时，返回客户端socket。侦听并接受连接到本服务的客户端连接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Socket <span class="title">accept</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>当服务器与客户端建立起连接后，通过输入输出流（客户端的Scoket）来通信</p><ul><li>获取服务器端输入流，读取客户端发来的消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>获取服务器端输出流，向客户端发送消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> OutputStream <span class="title">getOutputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="简单版的单线程聊天"><a href="#简单版的单线程聊天" class="headerlink" title="简单版的单线程聊天"></a>简单版的单线程聊天</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;socket需要有服务器端和客户端&lt;/p&gt;
&lt;p&gt;客户端在连接服务器时，需要指定服务器的IP（标识电脑）和端口号（标识电脑上的具体某个应用）&lt;/p&gt;
&lt;p&gt;通信的前提是：要创建基站，并与基站建立连接。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="项目" scheme="http://www.bingoxin.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://www.bingoxin.top/2019/01/03/JVM/"/>
    <id>http://www.bingoxin.top/2019/01/03/JVM/</id>
    <published>2019-01-03T13:10:46.000Z</published>
    <updated>2019-01-09T13:06:11.019Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机是通过软件模拟的具有完整硬件功能，运行在完全隔离环境中的计算机系统。</p><p>使用最多的是VMWare和Virtual Box。</p><p>JVM是通过软件<strong>模拟Java字节码指令集</strong>，JVM只保留了PC寄存器，而普遍的虚拟机有很多寄存器。</p><p>做JVM的公司有很多家，从<strong>JDK1.3</strong>开始，HotSpot为默认JVM。</p><p>JVM上<strong>不止可以运行Java的代码</strong></p><a id="more"></a><h3 id="JVM内存区域划分"><a href="#JVM内存区域划分" class="headerlink" title="JVM内存区域划分"></a>JVM内存区域划分</h3><p>Java内存区共分为6块内存</p><h4 id="线程私有内存"><a href="#线程私有内存" class="headerlink" title="线程私有内存"></a>线程私有内存</h4><p>每个线程都有，并且彼此之间相互隔离</p><ul><li>程序计数器</li></ul><p>程序计数器是比较小的内存空间，记录当前线程所执行的字节码的行号指示器。</p><p><strong>程序计数器记录的两种情况：</strong></p><p>1、若当前的线程执行的是Java方法，程序计数器记录的是正在执行的JVM字节码指令地址</p><p>2、若当前的执行线程执行的是Native方法，计数器值为空（监测不到C语言）</p><p>程序计数器是<strong>唯一一块不会产生OOM异常</strong>的区域</p><ul><li>虚拟机栈</li></ul><p>虚拟机栈描述Java<strong>方法</strong>执行的<strong>内存</strong>模型。</p><p>每个方法执行的同时，都会创建一个栈桢来存储<strong>局部变量表、操作数栈、方法出口</strong>等信息。每个方法从调用直到执行完毕的过程，对应一个栈桢在虚拟机栈的入栈和出栈过程。</p><p><strong>局部变量表存放内容：</strong>8种基本数据类型和对象引用（4个字节），因此每次开辟虚拟机栈桢的大小是确定的。</p><p>生命周期与线程相同：在创建线程时，同时创建线程的虚拟机栈。在线程执行完毕时，虚拟机栈也被一同回收。</p><p><strong>此区域一共会产生两种异常：</strong></p><p>1、若线程请求的栈深度大于JVM允许的深度（-Xss设置栈容量），抛出<code>StackOverFlowError</code>异常。常见于单线程</p><p>2、虚拟机在进行栈的动态扩展时，若无法申请到足够内存，抛出OOM（<code>OutOfMemoryError</code>）异常。常见于多线程</p><ul><li>本地方法栈</li></ul><p>本地方法（<code>Native</code>方法）执行的内存模型</p><p>在<strong>HotSpot虚拟机</strong>中，本地方法栈与虚拟机栈是同一块内存区域。</p><h4 id="线程共享内存"><a href="#线程共享内存" class="headerlink" title="线程共享内存"></a>线程共享内存</h4><p>所有线程共享此内存空间，并且此内存空间<strong>对所有线程可见</strong></p><ul><li>堆（GC堆）</li></ul><p>Java堆是JVM管理的最大内存区域。当JVM启动时创建。所有线程共享此内存，此内存中存放的都是数组和对象实例。</p><p>Java堆是垃圾回收器管理的最主要内存区域。Java堆可以处于物理上不连续的内存空间。-Xmx设置堆最大值，-Xms设置堆最小值</p><p><strong>异常：</strong>若在堆中没有足够的内存完成对象实例分配并且堆无法再次扩展时，抛出OOM异常</p><ul><li>方法区</li></ul><p>用于存储已被JVM加载的类信息、常量、静态变量等数据。JDK8以前，方法区也叫永久代。JDK8以后叫做元空间（Meta Space）</p><p>方法区无法满足内存分配需求时，抛出OOM</p><ul><li>运行时常量池</li></ul><p>运行时常量池是方法区的一部分，存放字面量与符号引用</p><p><strong>字面量：</strong>字符串常量（JDK7中移入堆中）、final常量、基本数据类型的值</p><p><strong>符号引用：</strong>类、字段、方法的完全限定名、名称、描述符</p><p>JVM内存区域划分-&gt;判断对象是否存活-&gt;垃圾回收算法-&gt;</p><h4 id="对象产生的过程"><a href="#对象产生的过程" class="headerlink" title="对象产生的过程"></a>对象产生的过程</h4><p>符号引用-&gt;类-&gt;具体引用 </p><p>根据符号引用去JVM方法区拿到该类的信息，然后再去堆中开辟空间</p><h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><p>OOM共有两种：内存溢出和内存泄漏</p><p><strong>内存泄漏：</strong>无用对象无法被垃圾回收，无法解决</p><p><strong>内存溢出：</strong></p><h3 id="垃圾回收器与内存分配策略"><a href="#垃圾回收器与内存分配策略" class="headerlink" title="垃圾回收器与内存分配策略"></a>垃圾回收器与内存分配策略</h3><h4 id="判断对象是否已死"><a href="#判断对象是否已死" class="headerlink" title="判断对象是否已死"></a>判断对象是否已死</h4><ul><li>引用计数法</li></ul><p>给每个对象附加一个引用计数器，每当有一个地方引用此对象时，计数器+1；每当有一个引用失效时，计数器-1；在任意时刻，只要计数器值为0的对象就是不能再被使用，即对象已死。</p><p>引用计数法实现简单，判定效率较高，但是无法解决循环引用问题。JVM并未采用此算法</p><p><code>-XX:+printGC</code>:查看垃圾处理装置</p><ul><li>可达性分析算法</li></ul><p>Java采用可达性分析算法来判断对象是否存活（C#也适用该算法）</p><p><strong>核心思想:</strong>通过一系列<code>GC Roots</code>的对象作为起点，从这些节点开始向下搜索对象，搜索走过的路径，称为“引用链”，当一个对象到任意一个GC Roots对象没有任何的引用链相连时（从GC Roots到对象不可达），证明此对象已死。</p><p><strong>Java中能作为GC Roots的对象包含以下四种：</strong></p><p>1、虚拟机栈中的引用对象</p><p>2、类静态变量引用的对象</p><p>3、本地方法栈中引用的对象</p><p>4、常量引用的对象</p><p><strong>JDK1.2之后对于引用的概念做了扩充：</strong></p><ul><li>强引用-StrongReference</li></ul><p>强引用指的是代码中普遍存在的，类似于Object obj = new Object();</p><p>在JVM中只要强引用还在，垃圾回收器永远不会回收此类对象的空间</p><ul><li>软引用-SoftReference</li></ul><p>软引用用来描述一些有用但不必须的对象，对于仅被软引用指向的对象，在系统将要发生内存溢出之前，会将<strong>所有软引用对象</strong>进行垃圾回收。若内存够用，这些对象仍然保留。在JDK1.2之后，提供了Soft Reference来实现软引用。</p><ul><li>弱引用-WeakReference</li></ul><p>弱引用用来描述一些有用但不必须的对象，但弱引用比软引用更差一点。仅被弱引用关联的对象最多只能生存到下一次GC开始之前。当垃圾回收器开始工作时，<strong>无论当前内存是否够用</strong>，都会回收掉仅被弱引用关联的对象。JDK1.2以后，使用WeakReference来实现弱引用</p><ul><li>虚引用-PhantomReference</li></ul><p>虚引用也称为幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在完全不会对其生存时间有影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是在这个对象被GC之前，收到一个系统通知。JDK1.2之后，提供PhantomReference来描述虚引用。</p><p><strong>为什么要有虚引用：</strong></p><p>在一个虚引用被垃圾回收之前，会收到一个通知来告诉JVM该虚引用对象将被销毁</p><h4 id="对象的自我拯救-finalize"><a href="#对象的自我拯救-finalize" class="headerlink" title="对象的自我拯救-finalize"></a>对象的自我拯救-finalize</h4><p>在可达性分析算法中不可达对象，也并非“非死不可”，所有不可达的对象处于缓刑阶段。要宣告一个对象的彻底死亡，需要经历两次标记过程：</p><p>若对象在进行可达性分析之后，发现到GC Roots不可达，此对象会进行一次筛选过程。</p><p><strong>筛选的条件</strong>是此对象是否有必要执行<code>finalize()</code>。当对象没有覆写<code>finalize()</code>或<code>finalize()</code>已被调用过，JVM会将此对象彻底宣判死亡。若筛选成功（对象覆写了<code>finalize()</code>，并且未被执行过），会将此对象放到F-Queue中</p><p>如果对象在finalize方法中成功自救（此对象与任意一个GC Roots建立联系），则对象在第二次标记时被移除回收集合，成功存活；若对象在finalize中仍然与GC Roots不可达，宣告死亡。</p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>方法区的回收主要回收两部分内容：废弃常量和无用的类</p><p><strong>判断常量是否被废弃的条件：</strong></p><p>常量未被引用</p><p><strong>判断一个类是无用类的条件：</strong></p><p>1、该类的所有实例都已经被回收，也就是在堆中不存在该类的任何实例。</p><p>2、加载该类的类加载器都被回收</p><p>3、该类的Class对象没有在任何其他地方被引用，也无法通过反射访问该类的所有内容</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><ul><li>算法核心思想：</li></ul><p>整个算法分为<strong>标记清除</strong>两个阶段：标记阶段标记出此次垃圾回收需要回收的对象，清除阶段一次性清除所有带标记对象。</p><p>如图所示：</p><p><img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.PNG"></p><ul><li>弊端</li></ul><p>1.效率上：标记与清除两个阶段的效率都不高</p><p>2.空间问题：标记清除算法会产生大量的不连续空间，若程序中需要分配较大连续对象时，由于空间碎片较多因此无法找到连续内存而不得不再次出发GC</p><h4 id="复制算法-新生代垃圾回收算法"><a href="#复制算法-新生代垃圾回收算法" class="headerlink" title="复制算法-新生代垃圾回收算法"></a>复制算法-新生代垃圾回收算法</h4><ul><li>核心思想</li></ul><p>将内存块按容量划分为大小相等的两块，每次只使用其中一块内存。当使用的内存需要垃圾回收时，会将此区域的所有存活对象一次性复制到保留区域，然后将使用的内存块一次清理掉。</p><p><img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.PNG"></p><ul><li>弊端</li></ul><p>复制算法最大的问题在于内存利用率太低，商用JVM都对复制算法做了改进</p><h4 id="JVM改进后的算法"><a href="#JVM改进后的算法" class="headerlink" title="JVM改进后的算法"></a>JVM改进后的算法</h4><p>新生代中98%的对象都是“朝生夕死”（存活时间短），所以并不需要按照1:1来划分内存空间。将内存（新生代内存）分为一块较大的Eden（伊甸园）和两块较小的Survivor（幸存者空间，大小一样，一块称为From区，一块称为To区）空间。每次只使用Eden和其中一块Survivor区域。（默认比例8:1:1）</p><ul><li>HotSpot复制算法流程</li></ul><p>1.当Eden区满的时候，会触发一次垃圾垃圾回收，将所有的存活对象拷贝到From区域中，然后一次性清除Eden区；当Eden区再次触发Minor GC，会扫描Eden区的From区，将这两块空间中的存活对象拷贝到To区，而后一次性清除Eden区的From区的不存活对象</p><p>2.当后续Eden区再次发生Minor GC时，会对Eden和To区进行回收，存活对象移动到From区，后续流程类似，只是将From和To区来回作为保留区域</p><p>3.部分对象会在From与To区域中来回复制，如此交换15次（MaxTenuringThreshold,默认为15）最终会存入老年代</p><p><img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/%E5%8D%87%E7%BA%A7%E7%89%88.png"></p><p>Survivor区域若无法放下所有存活对象，需要依赖其他内存（肉老年代）</p><h4 id="标记整理算法—老年代GC算法"><a href="#标记整理算法—老年代GC算法" class="headerlink" title="标记整理算法—老年代GC算法"></a>标记整理算法—老年代GC算法</h4><p>老年代中对象存活率很高，因此不适用复制算法（需要大量进行对象的复制过程，效率很低）</p><ul><li>算法思想</li></ul><p>算法分为标记与整理两个阶段。标记过程与标记清除过程一致，整理过程需要让所有存活对象向一端移动，而后直接清理掉存活对象边界以外的内存</p><h4 id="分代回收算法"><a href="#分代回收算法" class="headerlink" title="分代回收算法"></a>分代回收算法</h4><ul><li>算法核心思想</li></ul><p>根据对象的存活周期将内存分为以下两块</p><p>新生代：每次GC都有大批对象死去，只有少量存活，因此采用复制算法</p><p>老年代：对象存活率较高，没有额外空间对其分配担保，采用标记整理算法</p><h4 id="Minor-FullGC"><a href="#Minor-FullGC" class="headerlink" title="Minor FullGC"></a>Minor FullGC</h4><p>1.MinorGC称为新生代GC：指的是发生在新生代的垃圾回收。由于新生代对象大多存活周期较短，因此MinorGC发生频率非常频繁，一般回收速度较高</p><p>2.Full GC称为老年代GC或Major GC</p><p>GC：指的是发生在老年代的垃圾回收，出现了Major</p><p>GC通常会伴随至少一次的Minor GC（并非绝对）。一般Full GC比Minor GC慢10倍以上，发生频率较低</p><h3 id="垃圾收集器（垃圾回收算法的具体实现）-JDK8"><a href="#垃圾收集器（垃圾回收算法的具体实现）-JDK8" class="headerlink" title="垃圾收集器（垃圾回收算法的具体实现）-JDK8"></a>垃圾收集器（垃圾回收算法的具体实现）-JDK8</h3><ul><li>串行</li></ul><p>垃圾回收线程与用户线程在JVM中顺序执行</p><ul><li>并行</li></ul><p>垃圾回收线程一起执行，用户线程仍处于等待状态</p><ul><li>并发</li></ul><p>垃圾回收线程与用户线程一起执行</p><ul><li>STW</li></ul><p>当垃圾回收线程工作时，用户线程处于等待状态</p><p><strong>新生代垃圾回收器：</strong></p><p>Serial（串行收集器）、ParNew（并行）、parallel Scavenge（并行）</p><p><strong>老年代垃圾回收器：</strong></p><p>CMS（并发）、Serial Old（串行）、Parallel Old（并行）</p><p>全区域垃圾回收器：G1（并发）</p><h3 id="对象分配策略"><a href="#对象分配策略" class="headerlink" title="对象分配策略"></a>对象分配策略</h3><h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>大多数情况下，对象在新生代Eden区分配。当Eden区没有足够的空间分配时，JVM发生一次Minor GC</p><p><code>-Xmn</code>:新生代内存大小</p><p><code>-XX:SurvivorRatio = 8</code>:改变分配比例</p><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p><code>-XX:PretenureSizeThreshold = 字节大小</code>对象超过规定大小就将对象放入老年代</p><h4 id="长期存活对象进入老年代"><a href="#长期存活对象进入老年代" class="headerlink" title="长期存活对象进入老年代"></a>长期存活对象进入老年代</h4><p>JVM给每个对象定义了一个对象年龄的计数器，若对象在Eden去出生并且经历一次Minor GC后，仍然存活并且能被Survivor容纳，将此对象的年龄置为1，此后对象每再Survivor区域中经历一次Minor GC，年龄就增加一岁。当其年龄增加到一定程度（默认为15），此对象晋升到老年代</p><p><code>-XX:MaxTenuringThreshold = 15</code>设置晋升到老年代的大小</p><h4 id="动态年龄判定"><a href="#动态年龄判定" class="headerlink" title="动态年龄判定"></a>动态年龄判定</h4><p>JVM并不是永远要求对象的年龄必须达到MaxTenuringThreshold规定的值，才能晋升老年代。若Survivor空间中相同年龄的所有对象大小的总和和大于Survivor空间的一半，此时年龄大于等于该年龄的所有对象直接进入老年代，无须等到MaxTenuringThreshold要求的年龄</p><h3 id="JDK命令行工具"><a href="#JDK命令行工具" class="headerlink" title="JDK命令行工具"></a>JDK命令行工具</h3><ul><li>jps***</li></ul><p><strong>JVM进程状态工具</strong></p><p>列出正在运行的JVM进程，并返回进程ID</p><p>常用参数：<code>-l</code> 输出主类的全名称，返回进程ID</p><ul><li>jstat</li></ul><p>JVM统计信息监视工具，显示本地或远程JVM中类装载、内存、垃圾回收等数据</p><p><code>jstat -gcutil PID</code>:显示垃圾回收信息</p><ul><li>jinfo</li></ul><p>JVM配置信息查看工具</p><p><code>jinfo -flags PID</code></p><ul><li>jmap***</li></ul><p>内存映像工具</p><p>jmap用于生成堆转储快照（堆得快照）</p><p><code>jmap -heap PID</code>：显示JVM堆具体信息</p><p><code>jmap -histo PID</code>:显示JVM中对象的统计信息</p><ul><li>jhat</li></ul><p>heap文件的分析工具</p><p><code>jhat heap文件路径</code></p><ul><li>jstack***</li></ul><p>Java栈跟踪工具</p><p>jstack生成当前JVM线程的快照。</p><p>可用于定位线程出现长时间停顿的原因</p><h3 id="Java内存模型—JMM"><a href="#Java内存模型—JMM" class="headerlink" title="Java内存模型—JMM"></a>Java内存模型—JMM</h3><p>Java内存模型是基于线程的，JMM定义的主要目标是为了定义程序中各个变量的访问规则（JVM中如何将变量从内存中取出以及如何将变量再写回内存的细节）。此处的变量包括实例字段、静态字段与数组元素</p><h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><p>主内存是所有线程共享的，而工作内存指的是每个线程独有的</p><p>JMM规定<strong>所有变量必须存储在主内存</strong>中。每条线程都有自己的工作内存，工作内存中保存了该线程使用到的变量的主内存副本。线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，不能直接读写主内存中的变量。不同线程之间也无法直接访问彼此的工作内存变量，线程间变量值的传递均需要通过主内存来完成。</p><h4 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h4><p><strong>JMM内存三大特性：</strong></p><ul><li>原子性</li></ul><p>基本数据类型的访问读写是具有原子性，如若需要更大范围的原子性，需要内键锁或lock体系的支持（i++、i–等操作）</p><ul><li>可见性</li></ul><p>当一个线程修改了共享变量的值，其他线程能够立即得知此修改。volatile、final、synchronized可以实现可见性</p><ul><li>有序性</li></ul><p>如果在本线程内观察，所有操作都是有序的；若在线程之外观察另外一个线程，所有操作都是无序的</p><p>JMM具备先天的有序性，即无须通过任何手段就能保证的有序性。称为JMM的happens-before原则。若两个操作的次序无法从happens-before中推导出来，则无法保证其有序性，JVM可以随意对其重排序。</p><p>要想并发程序正确执行，必须同时保证原子性、可见性以及有序性。只要有任意一个没有被保证，就有可能导致程序运行不正确</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</p><ul><li>保证此变量对所有线程的可见性</li></ul><p>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。普通变量无法做到可见性。</p><p>volatile变量在各个线程中是一致的，但是volatile变量的运算在并发下一样是不安全的。Java中运算操作并非原子性操作，必须结合内键锁或lock体系来约束。</p><ul><li>由于volatile变量只保证可见性，在不符合一下两条规则的场景下，仍然需要使用加锁来保证原子性：</li></ul><p>1.运算结果不依赖当前变量的值，或者能够确保只有单一的线程修改变量值</p><p>2.变量不需要与其他的状态变量共同参与不变约束</p><ul><li>并发场景下对于类似i++操作如何保证程序的正确结果：</li></ul><p>1、加锁</p><p>2、使用原子类（java.util.concurrent.atomic包下的所有类-内部使用CAS保证原子性）</p><ul><li>禁止指令重排（内存屏障）</li></ul><p>1.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作更改肯定全部已经执行完毕且结果已经对后面的操作可见，在其后面的操作肯定还没有执行</p><p>2.在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能提前执行</p><h4 id="懒汉式单例的线程安全问题"><a href="#懒汉式单例的线程安全问题" class="headerlink" title="懒汉式单例的线程安全问题"></a>懒汉式单例的线程安全问题</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虚拟机是通过软件模拟的具有完整硬件功能，运行在完全隔离环境中的计算机系统。&lt;/p&gt;
&lt;p&gt;使用最多的是VMWare和Virtual Box。&lt;/p&gt;
&lt;p&gt;JVM是通过软件&lt;strong&gt;模拟Java字节码指令集&lt;/strong&gt;，JVM只保留了PC寄存器，而普遍的虚拟机有很多寄存器。&lt;/p&gt;
&lt;p&gt;做JVM的公司有很多家，从&lt;strong&gt;JDK1.3&lt;/strong&gt;开始，HotSpot为默认JVM。&lt;/p&gt;
&lt;p&gt;JVM上&lt;strong&gt;不止可以运行Java的代码&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
      <category term="JVM" scheme="http://www.bingoxin.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深浅拷贝</title>
    <link href="http://www.bingoxin.top/2019/01/03/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://www.bingoxin.top/2019/01/03/深浅拷贝/</id>
    <published>2019-01-03T10:37:30.000Z</published>
    <updated>2019-01-03T14:13:59.364Z</updated>
    
    <content type="html"><![CDATA[<h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><p>拷贝的执行函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><p>并不是所有的类都可以被拷贝，需实现<code>Cloneable</code>接口，并且在类中自定义<code>clone()</code>调用Object类提供的继承权限<code>clone()</code></p><p>若不实现Cloneable接口，在调用<code>clone()</code>时，会抛出CloneNotSupportedException异常。</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>对于浅拷贝而言，拷贝出来的对象仍然保留原对象的所有引用。</p><p>只要拷贝对象和原对象中引用的属性发生改变，其所有的该引用属性都会发生改变</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>对于深拷贝而言，拷贝出来的对象会产生新的对象。</p><p>对于拷贝的原对象和拷贝出来的对象来说，改变一个引用的属性，互不影响</p><p>对象中包含的引用只是自定义引用</p><h3 id="如何实现深拷贝"><a href="#如何实现深拷贝" class="headerlink" title="如何实现深拷贝"></a>如何实现深拷贝</h3><p>1.包含的其他类继续实现Cloneable接口，并且调用<code>clone()</code></p><p>2*.实现序列化</p><h4 id="调用clone"><a href="#调用clone" class="headerlink" title="调用clone()"></a>调用<code>clone()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baby</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Baby&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Baby <span class="title">clone</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        Baby baby = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            baby =(Baby) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Baby</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line">    <span class="keyword">public</span> Baby baby;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Monkey</span><span class="params">(String name, Integer age, Baby baby)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.baby = baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Monkey&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", baby="</span> + baby +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Baby <span class="title">getBaby</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBaby</span><span class="params">(Baby baby)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baby = baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Monkey <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Monkey monkey = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            monkey = (Monkey) <span class="keyword">super</span>.clone();</span><br><span class="line">            monkey.baby = <span class="keyword">this</span>.baby.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> monkey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Baby baby = <span class="keyword">new</span> Baby(<span class="string">"zxh"</span>,<span class="number">3</span>);</span><br><span class="line">        Monkey monkey = <span class="keyword">new</span> Monkey(<span class="string">"zh"</span>,<span class="number">88</span>,baby);</span><br><span class="line"></span><br><span class="line">        Monkey monkey1 = monkey.clone();</span><br><span class="line">        System.out.println(monkey1);</span><br><span class="line">System.out.println(monkey.baby == monkey1.baby);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><ul><li>概念</li></ul><p>将内存中保存的对象变为二进制流，进行输出或保存在文本中，即将对象变为二进制流。<br>若类要实现序列化，必须实现<code>Serializable</code>接口</p><p>Serializable接口为标识接口，只有实现了Serializable接口的类，才具备对象序列化的功能。</p><p>但要具体实现序列化和反序列化需要使用IO包中提供的两个处理类：ObjectOutputStream（序列化）、ObjectInputStream（反序列化）</p><ul><li>ObjectOutputStream（序列化）</li></ul><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectOutputStream</span><span class="params">(OutputStream out)</span></span>;</span><br></pre></td></tr></table></figure><p>将文件转化为二进制流输出到终端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writeObject(Object obj);</span><br></pre></td></tr></table></figure><p>例程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Monkey</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Monkey&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\pxx\\Desktop"</span> + <span class="string">"\\1.txt"</span>);</span><br><span class="line">        Monkey monkey = <span class="keyword">new</span> Monkey(<span class="string">"zh"</span>,<span class="number">99</span>);</span><br><span class="line">        OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(outputStream);</span><br><span class="line">        oos.writeObject(monkey);</span><br><span class="line">        oos.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>transient</code>关键字</p><p>若希望类中的若干属性不被序列化，可以在属性前添加该关键字</p></li><li><p>ObjectInputStream(反序列化)</p></li></ul><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectInputStream</span><span class="params">(InputStream in)</span></span>;</span><br></pre></td></tr></table></figure><p>将文件中的二进制流输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readObject(Object obj);</span><br></pre></td></tr></table></figure><h4 id="使用序列化实现深拷贝"><a href="#使用序列化实现深拷贝" class="headerlink" title="使用序列化实现深拷贝"></a>使用序列化实现深拷贝</h4><p>使用序列化进行深拷贝时，无须实现Cloneable接口，而需要实现Serializable接口</p><p>用序列化实现上一例程的拷贝Monkey对象的功能，代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public Monkey ObjectClone()&#123;</span><br><span class="line"></span><br><span class="line">        OutputStream outputStream = new ByteOutputStream();</span><br><span class="line">        Monkey monkey = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(outputStream);</span><br><span class="line"></span><br><span class="line">            oos.writeObject(this);</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            InputStream bis = new ByteInputStream(((ByteOutputStream) outputStream).getBytes(),((ByteOutputStream) outputStream).size());</span><br><span class="line">            ObjectInputStream ois = new ObjectInputStream(bis);</span><br><span class="line"></span><br><span class="line">            monkey = (Monkey) ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line">            bis.close();</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return monkey;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;深浅拷贝&quot;&gt;&lt;a href=&quot;#深浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;深浅拷贝&quot;&gt;&lt;/a&gt;深浅拷贝&lt;/h3&gt;&lt;p&gt;拷贝的执行函数&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>网络基础概念理解</title>
    <link href="http://www.bingoxin.top/2018/12/25/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
    <id>http://www.bingoxin.top/2018/12/25/网络基础概念理解/</id>
    <published>2018-12-25T09:20:25.000Z</published>
    <updated>2019-01-02T13:50:37.345Z</updated>
    
    <content type="html"><![CDATA[<p>总是听到身边的人说局域网，那么局域网到底是什么呢？</p><p>如何将一个数据发送到另一台主机呢？</p><p>操作系统是如何知道网卡中有数据发来呢？</p><p>请接下这篇博客<a id="more"></a></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="局域网与公网"><a href="#局域网与公网" class="headerlink" title="局域网与公网"></a>局域网与公网</h3><ul><li><p>局域网概念—LAN</p><p>局域网指在某一区域内由多台计算机互联成的计算机组，应用在局部范围内，例如我们家里或者学校使用的无线网</p></li></ul><p>我们使用的WIFI也叫WLAN，即无线局域网。</p><p>在同一局域网内，两台主机可以直接通信</p><ul><li><p>广域网—WAN</p><p>广域网是连接不同地区局域网或城域网计算机通信的远程网，通常跨接很大的物理范围，例如我们使用的阿里云服务器</p></li></ul><p>公网接入方式：上网的计算机得到的IP地址是Internet上的非保留地址，公网的计算机和Internet上的其他计算机可随意互相访问。</p><p>任何一台在局域网上的主机，在不欠费的情况下，是可以访问公网上的服务器的</p><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>协议就像是一种约定，而网络协议也可以被理解为是在网络上的一种约定</p><ul><li>协议分层</li></ul><p>例如，两个人在打电话，这个通信过程可以将其分为两部分：通信工具和人。</p><p>当中国人和中国人打电话时，两人均使用汉语进行沟通，当其中一人使用电话进行通话时，两人依然可以正常沟通。再或者，其中一个中国人给一个英国人打电话时，两人还是可以用英语进行交流。</p><p>这也可以说明了分层的<strong>好处</strong>：其中一层发生改变整体不受影响，即分层可以更好的解耦</p><p>在分层这里要注意：同层之间才可以通信</p><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总是听到身边的人说局域网，那么局域网到底是什么呢？&lt;/p&gt;
&lt;p&gt;如何将一个数据发送到另一台主机呢？&lt;/p&gt;
&lt;p&gt;操作系统是如何知道网卡中有数据发来呢？&lt;/p&gt;
&lt;p&gt;请接下这篇博客
    
    </summary>
    
    
      <category term="操作系统和网络" scheme="http://www.bingoxin.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java中的抽象类与接口</title>
    <link href="http://www.bingoxin.top/2018/12/24/java%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
    <id>http://www.bingoxin.top/2018/12/24/java中的抽象类与接口/</id>
    <published>2018-12-24T12:13:33.000Z</published>
    <updated>2018-12-24T12:14:11.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抽象类的定义"><a href="#抽象类的定义" class="headerlink" title="抽象类的定义"></a>抽象类的定义</h3><p>抽象类只是比普通类多了一些抽象方法</p><ul><li>抽象方法</li></ul><p>只声明而未实现的方法（没有方法体），抽象方法必须使用abstract关键字类定义。并且抽象方法所在的类也一定要使用abstract来定义</p><a id="more"></a><ul><li>抽象类使用原则</li></ul><blockquote><p>a.所有抽象类必须有子类（final与abstract不能同时使用）</p><p>b.抽象类的子类必须覆写抽象类的所有抽象方法（private与abstract不能同时使用）</p><p>c.抽象类无法直接创建实例化对象，需要通过子类向上转型为其实例化</p></blockquote><ul><li>抽象类相关约定</li></ul><blockquote><p>a.抽象类一定存在构造方法，子类也一定遵循对象实例化流程。先调用父类构造再调用子类构造</p><p>b.抽象类可以没有任何抽象方法，但此时仍然不能直接创建实例化对象</p><p>c.private与abstract不能同时使用</p><p>d.final与abstract不能同时使用</p><p>e.关于内部抽象类：子类只需要覆写外部抽象类中的直接抽象方法即可。内部抽象类的抽象方法可不覆写，若要覆写内部类的抽象方法，需在子类中写一个内部类来继承父类中的内部类，再对父类内部类进行覆写</p></blockquote><h3 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h3><ul><li>设计模式</li></ul><p>解耦，引入一个第三方来解耦（高内聚，低耦合）</p><ul><li>开闭原则（OCP）</li></ul><p>一个软件实体如类、模块或函数应该对扩展开放，对修改关闭</p><ul><li>模板设计模式—基于抽象类</li></ul><p>在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板设计模式可以使得子类在不改变算法的前提下，重新定义算法中的某些步骤</p><p>请看下面的程序：</p><p>制作一杯茶和制作一杯咖啡从步骤上来看是很像的</p><p><strong>制作一杯茶</strong></p><blockquote><p>1.烧开水</p><p>2.把茶包浸泡在水中</p><p>3.把茶水导入杯子里</p><p>4.加入柠檬</p></blockquote><p><strong>制作一杯咖啡</strong></p><blockquote><p>1.烧开水</p><p>2.冲泡咖啡</p><p>3.把咖啡导入杯子里</p><p>4.加入牛奶和糖</p></blockquote><p>我们可以发现制作两种饮品时第一步和第三步是相同的，茶和咖啡可以统称为咖啡因饮品。因此可以定义一个基类成员方法包括以上四种，这四种可以统称为准备饮品，则定义一个方法依次调用四个步骤为准备饮品。让咖啡喝茶继承基类，并对第二步和第四步进行覆写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">//导入输入类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CaffeineBeverage</span></span>&#123;</span><br><span class="line">    <span class="comment">//准备饮料</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareRecipe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        boilWater();<span class="comment">//烧开水</span></span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="keyword">if</span>(customerWantsCondiments())&#123;</span><br><span class="line">            addCondiments();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在烧水"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pourInCup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"把饮料倒进杯子里"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">customerWantsCondiments</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        CaffeineBeverage caff = <span class="keyword">new</span> Coffee();</span><br><span class="line">        caff.prepareRecipe();</span><br><span class="line">        CaffeineBeverage caff1 = <span class="keyword">new</span> Tea();</span><br><span class="line">        caff1.prepareRecipe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">CaffeineBeverage</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"冲泡咖啡"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"加入牛奶和糖"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">customerWantsCondiments</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"是否要加东西？y/n"</span>);</span><br><span class="line">        String answer = <span class="keyword">null</span>;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        answer = scanner.nextLine();</span><br><span class="line">        <span class="keyword">if</span>(answer.equals(<span class="string">"y"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">extends</span> <span class="title">CaffeineBeverage</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"浸泡茶包"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加入柠檬"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;抽象类的定义&quot;&gt;&lt;a href=&quot;#抽象类的定义&quot; class=&quot;headerlink&quot; title=&quot;抽象类的定义&quot;&gt;&lt;/a&gt;抽象类的定义&lt;/h3&gt;&lt;p&gt;抽象类只是比普通类多了一些抽象方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只声明而未实现的方法（没有方法体），抽象方法必须使用abstract关键字类定义。并且抽象方法所在的类也一定要使用abstract来定义&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的类集</title>
    <link href="http://www.bingoxin.top/2018/12/21/Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E9%9B%86/"/>
    <id>http://www.bingoxin.top/2018/12/21/Java中的类集/</id>
    <published>2018-12-21T14:44:51.000Z</published>
    <updated>2019-01-08T13:53:41.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java类集"><a href="#Java类集" class="headerlink" title="Java类集"></a>Java类集</h1><p>Java类集就是动态数组，类集的使用比较容易操作，但是类集的底层需要用到数据结构和多线程</p><p>所有的类集都在java.util包下<a id="more"></a></p><h3 id="Java类集的产生"><a href="#Java类集的产生" class="headerlink" title="Java类集的产生"></a>Java类集的产生</h3><p>Java类集是从JDK1.2开始应用的，用于解决数组定长问题</p><ul><li>Collection接口—<strong>单个对象</strong>保存的最顶层父接口</li></ul><p>Collection接口以及其子接口，在每次进行数据操作时只能对单个对象进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Iterable&lt;E&gt;</code>:迭代器接口（用于遍历集合）</p><p><code>Interface&lt;E&gt; iterator()</code>：取得集合的迭代器，JDK1.5之前没有泛型，则迭代器直接写在Collection接口中</p><ul><li>Collection接口中提供的核心方法</li></ul><p><strong>向类集中添加元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>取得接口的迭代器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Collection 接口只定义了存储数据的标准，但是无法区分存储类型。因此在实际中我们往往是由两个子接口List（允许数据重复）、Set（不允许数据重复）一般不直接使用Collection接口</p><h2 id="List接口—允许数据重复"><a href="#List接口—允许数据重复" class="headerlink" title="List接口—允许数据重复"></a>List接口—允许数据重复</h2><p>在进行单个集合处理时，优先考虑List接口</p><p>在List接口中，拓展了两个重要方法（List独有）</p><ul><li>根据索引取得下标数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>根据索引下标更改数据，返回原来的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br></pre></td></tr></table></figure><p>List接口有三个重要子类：ArrayList、Vector、LinkedList</p><p>List接口要想保存自定义类的对象，该类必须覆写<code>equals()</code>来使用<code>contains()</code>、<code>remove()</code></p><h3 id="ArrayList-Vector-LinkedList的区别"><a href="#ArrayList-Vector-LinkedList的区别" class="headerlink" title="ArrayList/Vector/LinkedList的区别"></a>ArrayList/Vector/LinkedList的区别</h3><ul><li>ArrayList与Vector的区别</li></ul><p>1、<strong>出现版本：</strong>ArrayList 在JDK1.2版本才出现，Vector在JDK1.0版本就已经出现</p><p>2、<strong>调用无参构造的区别：</strong>Vector在无参构造执行后将对象数组大小初始化为10，ArrayList采用懒加载策略，在构造方法阶段并不初始化数组，在第一次添加元素时才会初始化数组，大小为10</p><p>3、<strong>扩容策略：</strong>ArrayList在扩容时，会扩容到原来长度的1.5倍；Vector在扩容时，会扩容到原来的两倍</p><p>4、<strong>线程的安全性：</strong>ArrayList采用异步处理，线程不安全，效率较高；Vector采用在方法上加锁，线程安全，效率更低。（即便要使用线程安全的List也不使用Vector）</p><p>5、<strong>遍历：</strong>Vector支持较老的迭代器；ArrayList不支持</p><ul><li>ArrayList与Vector的共同点</li></ul><p>底层都使用数组实现，且都是List的子类</p><ul><li>ArrayList与LinkedList的区别</li></ul><p>LinkedList底层是双向链表，ArrayList的底层是数组</p><h2 id="Set接口—不允许数据重复"><a href="#Set接口—不允许数据重复" class="headerlink" title="Set接口—不允许数据重复"></a>Set接口—不允许数据重复</h2><p>Set接口没有扩充方法，常用子类有<code>HashSet</code>(无序存储)和<code>TreeSet</code>(有序存储)</p><p>Set接口本质上就是Map接口，Set就是value值都为PRESENT的Map</p><h3 id="Comparable接口与Comparator接口"><a href="#Comparable接口与Comparator接口" class="headerlink" title="Comparable接口与Comparator接口"></a>Comparable接口与Comparator接口</h3><ul><li>Comparable接口</li></ul><p>在Java中，若实现自定义类的比较，提供了一下两个接口：</p><p>java.lang.Comparable接口（内部比较器）:若一个类实现了Comparable接口，就表示该类可以进行比较并排序的。存放该类的Conllection或数组，可以直接通过<code>Collection.sort()</code>或Array.sort进行排序</p><p>实现了Comparable接口的类可以直接存放在TreeSet或TreeMap中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>返回值三种情况：</p><p>返回正数：当前对象大于目标对象</p><p>返回负数：当前对象小于目标对象</p><p>返回0：当前对象等于目标对象</p><ul><li>Comparator接口</li></ul><p>Comparator是外部排序接口</p><p>若要控制某个自定义类的顺序，而该类本身不支持排序—实现Comparator接口，覆写compareTo方法或实现一个比较器传入TreeSet或TreeMap中进行比较即可。</p><p>实现了Comparator接口的类作为比较器，通过该比较器来进行类排序，具有两个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1,T o2)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值与compareTo返回值完全一样</p><p>返回正数，o1&gt;o2</p><p>返回负数，o1&lt;o2</p><p>返回0，o1=o2</p><p>实现<code>Comparator</code>接口进行第三方排序—策略模式，此方法更加灵活，可以轻松改变策略进行第三方的排序方法</p><ul><li>Comparable接口与Comparator接口的关系</li></ul><p>Comparable是排序接口，若一个类实现了Comparable接口，意味着该类支持排序，是一个内部比较器（自己去和别人比）</p><p>Comparator接口是比较器接口，类本身不支持排序，专门有若干个第三方的比较器（实现了Comparator接口的类）来进行类排序，是一个外部比较器</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>底层是由哈希表和红黑树，允许存放null，无序储存</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>底层使用红黑树，不允许空值出现，允许储存</p><p>保存自定义类需实现Comparable接口或者传入比较器（compartor接口）</p><h3 id="HashSet和TreeSet的区别"><a href="#HashSet和TreeSet的区别" class="headerlink" title="HashSet和TreeSet的区别"></a>HashSet和TreeSet的区别</h3><p>1、<strong>底层实现不同：</strong>HashSet底层是由哈希表和红黑树，允许存放null，无序储存；TreeSet底层使用红黑树，不允许空值出现，允许储存</p><h3 id="重复元素比较"><a href="#重复元素比较" class="headerlink" title="重复元素比较"></a>重复元素比较</h3><p>TreeSet与TreeMap依靠Comparator或Comparable接口来区别重复元素</p><p>HashMap和HashSet不依赖比较接口，可以通过同时覆写其<code>equals()</code>和<code>HashCode()</code>方法来区分</p><p><strong>元素比较步骤：</strong></p><p>1、调用<code>hashCode()</code>计算出对象hash码决定存放的hash桶</p><p>2、使用<code>equals()</code>方法来判定两个元素内容是否相等，若相等，则不放置元素，若不相等，则在相同桶之后将元素链起来</p><p>object类内置的<code>hashCode()</code>是默认比较对象的地址转为hash码</p><p>两个对象<code>equals()</code>方法返回true，他们的hashCode必然保持相等，</p><p>两个对象的hashCode相等，不能保证他们的<code>equals()</code>一定相等，当且仅当hashCode和equals都返回true是，才说明两个对象都相等</p><ul><li>覆写<code>equals()</code>方法原则</li></ul><blockquote><p>自反性：对于任何非空引用值x，<code>x.equals(x)</code>都返回true</p><p>对称性：对于任何非空的x,y,当且仅当<code>x.equals(y)</code>返回true，<code>y.equals(x)</code>返回true</p><p>传递性：对于任何非空的x,y,z,当<code>x.equals(y)</code>返回true，<code>y.equals(z)</code>返回true,才有<code>x.equals(z)</code>返回true</p><p>一致性：对于任何非空的x,y,若x与y中属性没有变，则多次调用<code>equals()</code>方法，都返回true或false</p><p>非空性：对于任何非空引用值x，<code>x.equlas(null)</code>，返回false</p></blockquote><h3 id="集合输出—迭代器Iterator输出"><a href="#集合输出—迭代器Iterator输出" class="headerlink" title="集合输出—迭代器Iterator输出"></a>集合输出—迭代器Iterator输出</h3><ul><li>迭代输出—Collection接口支持</li></ul><p><strong>Iterator的两个核心方法</strong></p><p>判断是否还有元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>取得下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>单向迭代输出</strong></p><p>调用Collection集合子类的Iterator方法取得内置的迭代器，使用一下输出格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双向迭代输出</strong>–ListIterator</p><p>除了<code>hasNext</code>与<code>next</code>方法外还有：</p><p>判断是否有上一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasPrevious();</span><br></pre></td></tr></table></figure><p>取得上一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">previous();</span><br></pre></td></tr></table></figure><p>要想从后向前遍历，首先至少要从前向后遍历一次才可使用</p><ul><li>Enumeration枚举输出—Vector类支持</li></ul><p>判断是否有下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasMoreElements();</span><br></pre></td></tr></table></figure><p>取得下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextElement();</span><br></pre></td></tr></table></figure><ul><li>for-each输出</li></ul><p>能使用for-each的本质是各个集合类都内置了迭代器</p><ul><li>fail-fast机制</li></ul><p>ConcurrentModificationException发生在Collection集合使用迭代器遍历时，使用了集合类提供的修改集合内容方法报错。而如果使用Iterator迭代器的<code>remove()</code>不会出现此类错误</p><p>Collection集合中的modCount表示当前集合修改的次数</p><p>exceptedModCount是迭代器中记录当前集合的修改次数</p><p>当取得集合迭代器时，调用<code>new Itr()</code>会执行expectedModCount = ModCount，换言之，迭代器就是当前集合的一个副本</p><p>快速失败策略保证了所有用户在进行迭代遍历集合时，拿到的数据一定是最新的数据（避免脏读产生）</p><ul><li>fail-safe</li></ul><p>不产生ConcurrentModificationException异常，juc包下的所有线程安全集合（CopyOnWriteArrayList）</p><p><strong>以后再迭代器遍历时，不要修改集合的内容</strong></p><h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><p>Map接口是Java中保存二元偶对象的最顶层接口</p><p>Map中key值唯一，即通过可以值就可以找到对应的value值</p><ul><li>核心方法</li></ul><p>向Map中添加数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key,V value)</span></span>;</span><br></pre></td></tr></table></figure><p>根据指定的key值取得相应的value值，若没有key值，返回null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>;</span><br></pre></td></tr></table></figure><p>将Map集合变为Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure><p>返回所有key值集合，key不能重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>返回所有value值，value可以重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Map接口常用子类：HashMap、TreeMap、Hashtable、ConcurrentHashMap</p><ul><li>类比HashMap与Hashtable</li></ul><p>1、<strong>key和value的取值：</strong>HashMap的key值和value值可以取null，而Hashtable中key和value均不能取value值</p><p>2、<strong>出现的版本不同：</strong>JDK1.2产生了HashMap，JDK1.0就产生了Hashtable</p><p>3、<strong>线程安全问题：</strong>HashMap采用异步处理，线程不安全但是效率高，Hashtable采用同步处理，线程安全，效率低</p><p>4、<strong>底层实现：</strong>HashMap的底层是用哈希表和红黑树实现的，Hashtable的底层是用哈希表实现的</p><h4 id="Map集合使用迭代器输出"><a href="#Map集合使用迭代器输出" class="headerlink" title="Map集合使用迭代器输出"></a>Map集合使用迭代器输出</h4><ul><li>将Map集合转为Set集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure><h4 id="Collection与Map的储存方式"><a href="#Collection与Map的储存方式" class="headerlink" title="Collection与Map的储存方式"></a>Collection与Map的储存方式</h4><p>两者都是以对象为单位进行储存的</p><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><ul><li>栈—先入后出</li></ul><p>函数栈桢，浏览器标签页的后退，安卓Activity的后腿，编辑器撤销</p><p><strong>面试题：自己实现一个html识别器</strong></p><ul><li>队列—先入先出</li></ul><p>消息队列：kafka，RobitMQ</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>Queue接口：</p><p>入队列：<code>add()</code></p><p>出队列：<code>poll()</code></p><p>返回队列头元素，不出队：<code>peek()</code></p><h3 id="属性文件操作—资源（Properties）文件操作"><a href="#属性文件操作—资源（Properties）文件操作" class="headerlink" title="属性文件操作—资源（Properties）文件操作"></a>属性文件操作—资源（Properties）文件操作</h3><p>Java中有一种特殊的文件是以<code>.properties</code>为后缀的文件，资源文件的内容都是K,V模式的，并且K和Value都是String类型</p><ul><li>设置属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">setProperty</span><span class="params">(String key,String Value)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>取得属性,若没有指定key值，返回null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>若没有指定key值，返回默认值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getProperty(String key,String defaultValue);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java类集&quot;&gt;&lt;a href=&quot;#Java类集&quot; class=&quot;headerlink&quot; title=&quot;Java类集&quot;&gt;&lt;/a&gt;Java类集&lt;/h1&gt;&lt;p&gt;Java类集就是动态数组，类集的使用比较容易操作，但是类集的底层需要用到数据结构和多线程&lt;/p&gt;
&lt;p&gt;所有的类集都在java.util包下
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDBC</title>
    <link href="http://www.bingoxin.top/2018/12/20/JDBC/"/>
    <id>http://www.bingoxin.top/2018/12/20/JDBC/</id>
    <published>2018-12-20T06:20:21.000Z</published>
    <updated>2019-01-02T12:58:41.473Z</updated>
    
    <content type="html"><![CDATA[<p>现在的应用系统大多都离不开数据库，而Java程序访问数据库的基本方式是通过JDBC。</p><p>Java Database Connectivity，Java数据库连接。</p><p>用于执行SQL语句的Java API</p><p>JDBC使用流程如下：</p><p><img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JDBC/%E6%8D%95%E8%8E%B7.PNG"></p><a id="more"></a><h3 id="JDBC的使用"><a href="#JDBC的使用" class="headerlink" title="JDBC的使用"></a>JDBC的使用</h3><ul><li>加载JDBC驱动程序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br></pre></td></tr></table></figure><ul><li>建立数据库连接</li></ul><p>代码格式：jdbc:{数据库的名称}://host:port/databaseName?param1=value&amp;param2=value2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/memo? user=root&amp;password=root&amp;useUnicode=true&amp;characterEncoding=UTF-8"</span>);</span><br></pre></td></tr></table></figure><ul><li>创建操作命令（statement）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement statement = connection.createStatement();</span><br></pre></td></tr></table></figure><ul><li>执行SQL语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">            ResultSet resultSet = statement.executeQuery(sql);</span><br></pre></td></tr></table></figure><ul><li>处理结果集</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">                String title = resultSet.getString(<span class="string">"ename"</span>);</span><br><span class="line">                System.out.println(id == resultSet.getInt(<span class="string">"empno"</span>));</span><br><span class="line">                System.out.println(String.format(<span class="string">"id = %d,title = %s"</span>, id, title));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ul><li>释放资源（关闭结果集，命令，连接）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭结果集</span></span><br><span class="line"><span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        resultSet.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; &#125; </span><br><span class="line"><span class="comment">//关闭命令</span></span><br><span class="line"><span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        statement.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; &#125;</span><br><span class="line"><span class="comment">//关闭连接命令</span></span><br><span class="line"><span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();    </span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="Statement对象"><a href="#Statement对象" class="headerlink" title="Statement对象"></a>Statement对象</h3><p>用于将SQL语句发送到数据库中，JDBC API中主要提供了三种Statement对象</p><ul><li>Statement</li></ul><p>用于执行不带参数的简单SQL语句</p><p>SQL语句通过拼接字符串来实现，该方式效率比较低，系统会自动将该字符串定义为StringBuilder，拼接时调用<code>append()</code>方法</p><ul><li>PreparedStatement</li></ul><p>用于执行带或者不带参数的SQL语句</p><p>SQL语句会预编译在数据库系统</p><p>执行速度快于Statement对象</p><ul><li>CallableStatement</li></ul><p>用于执行数据库存储过程的调用</p><p>实际开发中最常用的是PreparedStatement，其具有以下优点：</p><blockquote><p>1、性能比Statement高（拼接字符串效率较低）</p><p>2、参数化SQL查询</p><p>3、占位符不能使用多值，占位符下标从1开始</p><p>4、SQL预编译</p><p>5、阻止常用SQL注入攻击</p></blockquote><p><strong>SQL两种执行方法：</strong></p><p>方法执行后返回单个结果集的，通常用于select语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executeQuery()</span><br></pre></td></tr></table></figure><p>方法返回值是一个整数，指示受影响的行数，通常用于update、insert、delete</p><h3 id="ResultSet对象"><a href="#ResultSet对象" class="headerlink" title="ResultSet对象"></a>ResultSet对象</h3><p>ResultSet对象被称为结果集，表示符合SQL语句执行结果的所有行，并且提供了一套<code>getXXX()</code>方法提供了对这些行中数据的访问。ResultSet就像一个迭代器，其所指的数据行叫做当前数据行。</p><p>取得某一条记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet.next()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在的应用系统大多都离不开数据库，而Java程序访问数据库的基本方式是通过JDBC。&lt;/p&gt;
&lt;p&gt;Java Database Connectivity，Java数据库连接。&lt;/p&gt;
&lt;p&gt;用于执行SQL语句的Java API&lt;/p&gt;
&lt;p&gt;JDBC使用流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JDBC/%E6%8D%95%E8%8E%B7.PNG&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://www.bingoxin.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="http://www.bingoxin.top/2018/12/16/%E8%BF%9B%E7%A8%8B/"/>
    <id>http://www.bingoxin.top/2018/12/16/进程/</id>
    <published>2018-12-16T12:03:24.000Z</published>
    <updated>2018-12-17T12:04:18.854Z</updated>
    
    <content type="html"><![CDATA[<h3 id="冯诺依曼体系结构"><a href="#冯诺依曼体系结构" class="headerlink" title="冯诺依曼体系结构"></a>冯诺依曼体系结构</h3><ul><li>组成</li></ul><p>包括输入单元、输入设备、存储器、运算器、控制器、输出单元、输出设备</p><p>存储器更多指的是内存</p><ul><li>关于冯诺依曼</li></ul><p>a.CPU只能对内存进行读写，不能访问外设</p><p>b.外设要读入或输出数据，只能写入内存或者从内存中读取，即所有外设只能和内存打交道</p><a id="more"></a><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li>概念</li></ul><p>操作系统包括：内核(进程管理、内存管理、文件管理、驱动管理)和其他程序(函数库、shell程序等)</p><ul><li>设计操作系统的目的</li></ul><p>a.与硬件交互，管理所有的软件和硬件</p><p>b.为用户提供一个良好的执行环境</p><ul><li>管理的概念</li></ul><p>即先将被管理对象描述起来，再将被管理对象组织起来</p><p>假如硬盘中存着一个程序，对程序进行编译后会生成一个可执行文件，而这个可执行文件就会加载到内存中供操作系统读取，但在内存中的仅仅是代码和数据。一个程序会生成一个进程，那么在操作系统中就会维护一个结构体(PCB)，结构体中该程序的属性。操作系统中不只有一个进程，那么就会产生多个结构体，为了方便管理，使用链表来将这些结构体连接起来，这是操作系统只需要知道该链表的头结点。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程之间是互相<strong>独立</strong>的，虽然代码有可能相同，但是各个进程都在维护各自的数据，因此进程之间是互不干扰的</p><ul><li>进程的控制块—PCB</li></ul><p>PCB包含一些字段，字段中包含程序的数据</p><ul><li>进程的字段</li></ul><p>pid（唯一标识符）、优先级、状态、</p><ul><li>进程的状态</li></ul><p>在不同的操作系统中，进程的状态是不同的</p><blockquote><ul><li><p><strong>R</strong>(unning)—可执行状态</p></li><li><p><strong>S</strong>(leep)—休眠状态</p></li><li><p><strong>T</strong>(stop)—停止状态</p></li><li><p><strong>D</strong>(isk sleep)—深度睡眠，不会被杀死</p></li><li><p><strong>X</strong>(dead)—死亡状态</p></li><li><p><strong>Z</strong>(zombie)—僵尸状态(进程已经退出，但仍保留该进程的信息，僵尸进程过多会导致内存泄漏问题)</p></li></ul></blockquote><ul><li>进程并发—进程间切换</li></ul><p>在一段时间内，多个进程在同一个CPU下采用进程切换的方式进行，让多个进程都得以推进</p><ul><li>进程并行</li></ul><p>同一时刻，多个进程在多个CPU下分别进行</p><ul><li>硬件上下文</li></ul><p>进程在运行期间在CPU寄存器上产生的数据</p><p>切换的时候将数据保存，返回时被恢复</p><p>硬件上下文被保存在PCB中</p><ul><li>查看进程的两种方式</li></ul><p>1.ps axj</p><p>2.查看proc目录</p><ul><li>获取pid的方法</li></ul><p>有pid就能实现进程调度</p><p><strong>获取当前进程pid：</strong> <code>getpid()</code></p><p><strong>获取父进程pid：</strong> <code>getppid()</code></p><ul><li>外壳程序</li></ul><p>操作系统通过外壳向用户传输数据，用户通过外壳向操作系统输入数据</p><blockquote><p>Windows系统的外壳是：窗口界面</p><p>Linux系统的外壳是：终端命令行</p></blockquote><p>shell：外壳程序的统称</p><p>bash（命令行解释器）：本身就是进程，为Linux系统下的父进程，可以创建子进程</p><ul><li>创建子进程</li></ul><p>关键字：fork（系统调用）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> id = fork();  <span class="comment">//当id = 0时，表示创建子进程成功，当id &gt; 0时，表示正在进行父进程，id为子进程的pid</span></span><br></pre></td></tr></table></figure><p>fork之后创建的子进程的代码是从父进程继承来的，即代码时共享的，但数据时各自私有的（写时拷贝）。因为代码是相同的，子进程的PCB中的内容大部分是和父进程PCB中的内容是一样的</p><ul><li>孤儿进程</li></ul><p>父进程提前退出，而子进程还在，子进程就会被1号进程领养，即子进程的ppid = 1</p><ul><li>修改进程</li></ul><p>关键字：kill</p><p>查看kill手册：<code>kill -l</code></p><h3 id="进程的优先级（PRI）"><a href="#进程的优先级（PRI）" class="headerlink" title="进程的优先级（PRI）"></a>进程的优先级（PRI）</h3><ul><li>取值范围：60~99</li></ul><p><strong>优先级值越小越早被执行，值越小进程优先级越高</strong></p><ul><li><strong>查看优先级命令：</strong>ps -l</li></ul><p>操作系统会在链表中找优先级最高的进程，只要该程序的状态是非r状态，操作系统将其对应的代码块放在CPU上执行</p><p>由于可能同时进行多个进程，若挨个查找链表中的结构体会浪费太多时间，则操作系统会有两条链表，一条用于存放r状态的进程（可执行队列），一条用于存放非r状态的进程</p><ul><li><strong>修正值nice</strong></li></ul><p>取值范围：-20~19</p><p>PRI（new） =PRI（OLD）+nice(修正值)</p><ul><li><strong>renice</strong>—修改nice的值</li></ul><p><code>sudo renice 修改值 -p pid</code> </p><ul><li><strong>nice</strong>—在进程开始进行时，指明优先级</li></ul><p><code>sudo nice -n 修改值</code></p><ul><li><strong>top</strong></li></ul><p>输入top-&gt;按 r-&gt;输入进程pid-&gt;输入nice值</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul><li>概念</li></ul><p>在操作系统中，用来指定操作系统运行环境的一些参数</p><ul><li>常见环境变量</li></ul><blockquote><p>PATH:命令搜索路径</p><p>HOME:指定用户的主工作目录</p><p>HISTSIZE:保存历史命令记录的条数</p><p>SHELL:当前shell，通常是bash</p></blockquote><p>ls是一个环境变量，它是一个二进制可执行程序，之所以它可以在任何路径下都可以使用，是因为它是被放在PATH下，PATH是什么呢？这是你可以在操作系统中输入<code>echo $PATH</code>你会得到一串路径，也就是说，当你把可执行文件放在这一串路径中的其中一个里，这个可执行文件就可以在任何路径下执行。</p><ul><li>如何让一个可执行文件可以在任何路径下都可以执行呢</li></ul><p>a.把可执行文件放在PATH中的一个路径下</p><p>b.将可执行文件的路径放在PATH中，使用命令<code>PATH=$PATH:可执行文件所在路径</code></p><h3 id="程序的地址空间"><a href="#程序的地址空间" class="headerlink" title="程序的地址空间"></a>程序的地址空间</h3><ul><li>虚拟地址空间</li></ul><p>每个进程都会创建一个PCB，每个PCB都会指向一个虚拟地址空间</p><ul><li>物理内存</li></ul><p>进程的代码和数据最终被写在物理内存中</p><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>目前所接触到创建进程的方式有两种：使用fork()函数、执行一个程序</p><p>当一个进程被创建时，操作系统会为该进程维护一个结构体（PCB），PCB中有该进程的属性。而每个PCB都会指向一个虚拟地址空间，虚拟地址空间中保存着进程的代码和数据。当一个进程和其子进程同时开始运行时，操作系统会为这两个进程维护一个数据结构—叫做页表，页表的功能是：将虚拟地址空间里的内容映射到物理内存中去。而此时，物理内存中就会有进程的代码和数据由于两个进程的代码是共享的，因此在物理内存中两个进程的代码映射区相同，而其数据不同。这也就是<strong>写时拷贝</strong>。</p><h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><p>退出的情况共有三种：代码运行完毕且结果正确，代码执行完毕但结果不对，代码异常终止</p><ul><li>判断结果是否正确</li></ul><p>使用<code>echo $?</code>，查看进程退出码</p><p>可以使用的方法:<code>_exit()</code>、<code>exit()</code>、return</p><ul><li><code>_exit()</code></li></ul><p><code>void _exit(int status)</code>status定义了进程终止状态，父进程可以通过<code>wait()</code>来获取该值（status只有低八位可以被父进程使用）</p><ul><li><code>exit()</code></li></ul><p>也可以结束进程，与<code>_exit()</code>的区别是：<code>exit()</code>会关闭流和刷新缓冲区，<code>_exit()</code>直接将进程关闭</p><p>进程终止时，释放数据结构，保留PCB中的数据，那么此时进程的状态就为僵尸进程</p><h3 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h3><p>若父进程不管理子进程，子进程若编程僵尸进程，这是父进程就没办法将该进程kill掉，从而造成内存泄漏。父进程需要知道子进程是否正常退出，而进程的退出有三种，又该如何判断呢？</p><ul><li><code>wait()</code></li></ul><p><code>pid_t wait(int* status)</code></p><p>若该进程成功结束，则返回该进程的pid，否则返回-1</p><p>参数为子进程退出状态</p><ul><li><code>waitpid()</code></li></ul><p><code>pid-t waitpid(pid_t pid,int* status,int options)</code></p><p>正常返回时，返回子进程的pid</p><ul><li><p>status</p><p>status的低八位为进程的退出码，第七位为该进程的结束信号，当退出信号为0，说明代码执行完但结果不对</p></li></ul><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><ul><li>概念</li></ul><p>守护进程是在后台运行的一种特殊进程，独立于控制终端且周期性的执行任务或等待处理任务，则守护进程不受用户登录注销的影响。</p><ul><li>守护进程经常采用以d结尾的名字</li><li>TPGID一栏写着-1的都是守护进程</li></ul><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;冯诺依曼体系结构&quot;&gt;&lt;a href=&quot;#冯诺依曼体系结构&quot; class=&quot;headerlink&quot; title=&quot;冯诺依曼体系结构&quot;&gt;&lt;/a&gt;冯诺依曼体系结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;组成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;包括输入单元、输入设备、存储器、运算器、控制器、输出单元、输出设备&lt;/p&gt;
&lt;p&gt;存储器更多指的是内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于冯诺依曼&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;a.CPU只能对内存进行读写，不能访问外设&lt;/p&gt;
&lt;p&gt;b.外设要读入或输出数据，只能写入内存或者从内存中读取，即所有外设只能和内存打交道&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.bingoxin.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java中的IO</title>
    <link href="http://www.bingoxin.top/2018/12/07/Java%E4%B8%AD%E7%9A%84IO/"/>
    <id>http://www.bingoxin.top/2018/12/07/Java中的IO/</id>
    <published>2018-12-07T12:42:10.000Z</published>
    <updated>2019-01-08T12:43:08.026Z</updated>
    
    <content type="html"><![CDATA[<p>用到IO时，需要使用Java开发的java.io。</p><p>BIO是阻塞式IO，基于抽象类</p><a id="more"></a><h3 id="核心掌握五个类"><a href="#核心掌握五个类" class="headerlink" title="核心掌握五个类"></a>核心掌握五个类</h3><p>这五个类包括：File、OutputStream、InputStream、Reader、Writer</p><p>还要掌握一个接口：Serializable</p><ul><li>File文件操作类</li></ul><p>File类是唯一一个与文件本身操作（创建、删除、取得信息）有关的程序类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String pathname)</span></span>;<span class="comment">//根据文件的绝对路径来产生file对象</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(URI uri)</span></span>;<span class="comment">//根据网络产生file对象</span></span><br></pre></td></tr></table></figure><p><strong>常用操作方法：</strong></p><ul><li>创建新文件：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>;</span><br></pre></td></tr></table></figure><ul><li>判断文件是否存在:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span> </span>;</span><br></pre></td></tr></table></figure><ul><li>删除文件：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>文件分隔符：File.separator</p><p><strong>目录操作：</strong></p><p>File不止可以描述文件，还可以描述文件夹</p><ul><li>取得父路径的File对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getParentFile</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>取得父路径的目录</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getParent</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>创建多级父路径（一次性创建多级不存在的父路径）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>取得文件信息：</strong></p><ul><li>判断File对象是否是文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> </span>;</span><br></pre></td></tr></table></figure><ul><li>判断File对象是否是文件夹</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>取得文件大小—以字节为单位</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">length</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>取得上次修改时间—返回一个时间戳</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>列出一个目录的全部组成</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> File[] listFiles();</span><br></pre></td></tr></table></figure><p>小练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"C:"</span>+File.separator+<span class="string">"Users"</span>+File.separator+</span><br><span class="line">                            <span class="string">"pxx"</span>+File.separator+<span class="string">"Desktop"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            listAllFile(file);</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"共花费"</span>+(end-start)+<span class="string">"毫秒"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        System.out.println(<span class="string">"主线程完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAllFile</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(file.exists() &amp;&amp; file.isFile())&#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(file.exists() &amp;&amp; file.isDirectory())&#123;</span><br><span class="line">            File[] files = file.listFiles();</span><br><span class="line">            <span class="keyword">for</span>(File file1:files)&#123;</span><br><span class="line">                listAllFile(file1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字节与字符流"><a href="#字节与字符流" class="headerlink" title="字节与字符流"></a>字节与字符流</h3><p>java.io包流分为两类：输入流与输出流</p><ul><li>字节（byte）流—可以处理文本文件、图像、音乐、视频等资源</li></ul><p>原生操作、无需转换</p><p>InputStream、OutputStream</p><ul><li>字符（char）流—只用于处理文本</li></ul><p>经过处理后的操作</p><p>Reader、Writer</p><p><strong>字节输出流OutputStream：</strong></p><p>1.取得终端对象</p><p>2.根据终端对象取得输入输出流</p><p>3.根据输入输出流，进行数据的读取与写入</p><p>4.关闭流</p><p>IO操作属于资源处理，所有的资源处理（IO操作、数据库操作、网络操作）</p><p>在使用后一定要关闭</p><ul><li>强制刷新缓冲区</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>;</span><br></pre></td></tr></table></figure><ul><li>关闭输出流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>将字节数组内容全部输出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>将字节数组中的部分内容输出—从偏移量为off开始的len个字节</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>输出单个字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>使用OutputStream输出数据时，<strong>若指定的文件不存在，FileOutputStream会自动创建文件</strong>（不包含创建目录）</p><p>默认是将文件内容覆盖，若要进行文件内容的追加，使用如下构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(String name, <span class="keyword">boolean</span> append)</span></span>;</span><br></pre></td></tr></table></figure><p>JDK1.7追加了AutoCloseable自动关闭接口，要使用此接口，必须使用try-catch代码块，推荐显式关闭</p><p><strong>字节输入流—InputStream：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span></span>;</span><br></pre></td></tr></table></figure><ul><li>将读取的内容放入字节数组中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>返回值有三种情况：</p><blockquote><p>1.返回b.length:未读取数据&gt;存放的缓冲区大小，返回字节数组大小</p><p>2.返回大于0的整数，此整数小于b.length</p><p>未读取的数据&lt;存放的缓冲区大小，返回剩余数据大小</p><p>3.返回-1</p><p>此时数据已经读取完毕</p></blockquote><p><strong>文件复制练习：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.bingoxin.practice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String sourceFilePath = <span class="string">"C:\\Users\\pxx\\Desktop\\IMG_7708.JPG"</span>;</span><br><span class="line">        String destFilePath=<span class="string">"C:\\Users\\pxx\\Desktop\\IMG.JPG"</span>;</span><br><span class="line">        copyFile(sourceFilePath,destFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(String sourceFilePath,String destFilePath)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        File sourceFile = <span class="keyword">new</span> File(sourceFilePath);</span><br><span class="line">        File destFile = <span class="keyword">new</span> File(destFilePath);</span><br><span class="line"></span><br><span class="line">        InputStream in = <span class="keyword">new</span> FileInputStream(sourceFile);</span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(destFilePath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>((len = in.read(data)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(data,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"已完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存流"><a href="#内存流" class="headerlink" title="内存流"></a>内存流</h3><p>内存流，顾名思义，其终端在内存</p><h4 id="字节内存流"><a href="#字节内存流" class="headerlink" title="字节内存流"></a>字节内存流</h4><p>ByteArrayInputStream，ByteArrayOutputStream</p><ul><li>将指定的字节数组内容存放到内存中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayInputStream</span><span class="params">(<span class="keyword">byte</span> buf[])</span></span>;</span><br></pre></td></tr></table></figure><ul><li>内存输出流的构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayOutputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="字符内存流"><a href="#字符内存流" class="headerlink" title="字符内存流"></a>字符内存流</h4><p>CharArrayReader,CharArrayWriter</p><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>打印流是针对输出流的强化版本，采用装饰设计模式—基于抽象类</p><ul><li>装饰模式</li></ul><p><strong>特点：</strong></p><p>核心依然是某个类（OutputStream提供的write（））的功能，但是为了得到更好的操作效果，让其支持的功能更多一些，使用装饰类（PrintStream）</p><p><strong>优点：</strong></p><p>很容易更换装饰类来达到不同的操作效果</p><p><strong>缺点：</strong></p><p>由于装饰设计的引入，造成结构复杂</p><ul><li>字节打印流</li></ul><p>PrintStream</p><ul><li>字符打印流</li></ul><p>PrintWriter</p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><ul><li>GBK、GB2312</li></ul><p>GBK包括简体中文和繁体中文，GB2312只包括简体中文</p><ul><li>UNICODE</li></ul><p>java提供的16进制编码，可以描述世界上任意一种语言，但是编码进制数太高，编码体积较大</p><ul><li>ISO-8859-1</li></ul><p>国际通用编码，不支持中文，浏览器默认编码</p><ul><li>UTF-8</li></ul><p>结合UNICODE与ISO-8859-1，最常使用的是UTF-8</p><p><strong>乱码产生的原因（95%）：</strong>编解码不一致</p><p><strong>乱码产生的原因（5%）：</strong>由于数据丢失造成的乱码</p><h3 id="System类对IO的支持"><a href="#System类对IO的支持" class="headerlink" title="System类对IO的支持"></a>System类对IO的支持</h3><p>共有三种：</p><blockquote><p>1.标准输出—System.out</p><p>2.标准输入—System.in</p><p>3.错误输出—System.err</p></blockquote><ul><li>系统输出</li></ul><p>系统提供的out（输出到显示器颜色为黑色）、err（输出到显示器颜色为红色）对象均是PrintStream的对象</p><p>输出采用日志（Log）—格式化输出</p><ul><li>系统输入</li></ul><p>系统提供的System.in是InputStream的直接对象</p><ul><li>两种输入流</li></ul><p><strong>BufferedReader//BufferedInputStream:</strong></p><p><code>readline()</code> 直接读取一行输入，默认以回车换行</p><p><strong>java.util.Scanner:</strong></p><p>支持正则表达式</p><ul><li>判断是否有指定类型的数据输入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasNextXX();<span class="comment">//Scanner类默认碰到空格、换行、Tab都是分隔符</span></span><br></pre></td></tr></table></figure><ul><li>获取指定数据类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextXX();</span><br></pre></td></tr></table></figure><ul><li>指定分隔符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useDelimiter(<span class="string">"指定分隔符"</span>);<span class="comment">//无论如何定义分隔符，换行表示本次输入完毕</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用到IO时，需要使用Java开发的java.io。&lt;/p&gt;
&lt;p&gt;BIO是阻塞式IO，基于抽象类&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的反射</title>
    <link href="http://www.bingoxin.top/2018/12/02/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84/"/>
    <id>http://www.bingoxin.top/2018/12/02/Java中的反射/</id>
    <published>2018-12-02T12:40:53.000Z</published>
    <updated>2019-01-06T12:41:20.948Z</updated>
    
    <content type="html"><![CDATA[<p>反射指的是对象的反向处理，根据对象倒推类的组成</p><h3 id="反射的核心类—class类"><a href="#反射的核心类—class类" class="headerlink" title="反射的核心类—class类"></a>反射的核心类—class类</h3><p>反射的核心类是专门描述其他类的组成</p><p>Object类中取得对象的class对象，class对象是用来描述接口与类的组成的，由JVM在第一次加载类时产生，并且全局唯一。</p><a id="more"></a><h4 id="取得任意类Class对象方法"><a href="#取得任意类Class对象方法" class="headerlink" title="取得任意类Class对象方法"></a>取得任意类Class对象方法</h4><ul><li><code>调用对象.getClass()</code>取得Class对象</li><li><code>类名称.class</code>取得Class对象</li><li><code>Class.forName(类全称-&gt;包名.类名)</code>取得类对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过反射实例化类对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li>类加载的定义</li></ul><p>通过一个类的全名称来获取此类的二进制字节流</p><ul><li>类加载器</li></ul><p>实现类加载功能的代码模块</p><h3 id="JDK内置的三大类加载器"><a href="#JDK内置的三大类加载器" class="headerlink" title="JDK内置的三大类加载器"></a>JDK内置的三大类加载器</h3><ul><li>启动类加载器—BootStrap</li></ul><p>1.使用C++语言实现，是JVM自身的一部分，独立于JVM外部，并且无法被Java程序直接引用</p><p>2.负责将存放于JAVA_HOME\lib目录下的能被JVM识别的所有类库加载到JVM中</p><p>例如：rt.jar是Java的基础类库</p><ul><li>扩展类加载器—ExtClassLoader</li></ul><p>1.使用Java语言实现，可以被Java程序直接引用</p><p>2.负责将存放于JAVA_HOME\lib\ext(xml文件解析类、界面框架类)目录下的所有能被JVM识别的类库</p><ul><li>应用程序类加载器—AppClassLoader</li></ul><p>1.使用Java程序实现，如果用户没有自定义类加载器，则APPClassLoader就是程序中默认的类加载器</p><p>2.负责加载用户classPath指定的类库</p><h3 id="类加载器的双亲委派模型"><a href="#类加载器的双亲委派模型" class="headerlink" title="类加载器的双亲委派模型"></a>类加载器的双亲委派模型</h3><ul><li>定义</li></ul><p>四种类加载器的层次关系称为类加载器双亲委派模型</p><ul><li>工作流程</li></ul><p>如果一个类加载器收到了类加载的请求，首先不会自己尝试自己加载此类，而是将类加载器请求委托给父类加载器完成，每一层的类加载器都是如此。只有当父加载器无法加载此类时，子加载器才会尝试自己去加载。</p><ul><li>存在意义</li></ul><p>双亲委派模型对于保证Java程序的稳定运行十分重要。</p><p>例如：Java.lang.Object，它存放在rt.jar中，由于双亲委派模型的存在，无论哪一类类加载器要加载此类，最终都是委派给处于顶端的启动类加载器进行加载的。因此，Object类在程序的各种类加载器环境中都是同一个类。</p><p><strong>比较两个类是否相同的前提条件：</strong>这两个类是由同一个类加载器加载的。</p><p>否则即使两个类来源同一个Class文件，被同一个JVM加载，只有加载这两个类的类加载器不是同一个，这两个类就不说同一个类</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>代理类不再实现某一具体接口，而要实现InvocationHandler接口</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反射指的是对象的反向处理，根据对象倒推类的组成&lt;/p&gt;
&lt;h3 id=&quot;反射的核心类—class类&quot;&gt;&lt;a href=&quot;#反射的核心类—class类&quot; class=&quot;headerlink&quot; title=&quot;反射的核心类—class类&quot;&gt;&lt;/a&gt;反射的核心类—class类&lt;/h3&gt;&lt;p&gt;反射的核心类是专门描述其他类的组成&lt;/p&gt;
&lt;p&gt;Object类中取得对象的class对象，class对象是用来描述接口与类的组成的，由JVM在第一次加载类时产生，并且全局唯一。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的线程池</title>
    <link href="http://www.bingoxin.top/2018/11/30/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://www.bingoxin.top/2018/11/30/Java中的线程池/</id>
    <published>2018-11-30T12:38:24.000Z</published>
    <updated>2019-01-06T12:39:54.318Z</updated>
    
    <content type="html"><![CDATA[<p>线程池有三大优点：降低资源消耗、提高响应速度、提高线程的可管理性</p><h3 id="线程池的继承关系"><a href="#线程池的继承关系" class="headerlink" title="线程池的继承关系"></a>线程池的继承关系</h3><h4 id="ExecutorService（普通调度池核心接口）"><a href="#ExecutorService（普通调度池核心接口）" class="headerlink" title="ExecutorService（普通调度池核心接口）"></a>ExecutorService（普通调度池核心接口）</h4><p>扩展了一个方法：submit()方法可以接受Callable和Runnable对象，并且都有返回值(接收Runnable接口对象也有返回值是因为Runnable对象在其内部会转换成为Callable对象)</p><a id="more"></a><h4 id="ScheduledExecutorService（定时调度池核心接口）"><a href="#ScheduledExecutorService（定时调度池核心接口）" class="headerlink" title="ScheduledExecutorService（定时调度池核心接口）"></a>ScheduledExecutorService（定时调度池核心接口）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延迟delay个时间单位后开始执行</span></span><br><span class="line">schedule(Runnable|Callable command,<span class="keyword">long</span> delay,TimeUnit unit);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延迟initialDelay个时间单位后开始执行，并且每隔period个时间单位就执行一次</span></span><br><span class="line">scheduleAtFixedRate(Runnable command,<span class="keyword">long</span> initialDelay,<span class="keyword">long</span> period,TimeUnit unit);</span><br></pre></td></tr></table></figure><ul><li>ThreadPoolExector：普通调度池核心类</li><li>ScheduledThreadPoolExector：定时调度池核心类</li><li>Executors：线程池工具类(内置四大线程池)</li></ul><h3 id="线程池执行流程"><a href="#线程池执行流程" class="headerlink" title="线程池执行流程"></a>线程池执行流程</h3><h4 id="第一步—创建线程需要获得全局锁"><a href="#第一步—创建线程需要获得全局锁" class="headerlink" title="第一步—创建线程需要获得全局锁"></a>第一步—创建线程需要获得全局锁</h4><p>判断核心线程是否已满，如果未满，创建一个新的线程来执行任务。如果已满，判断是否有空闲线程，有的话将任务分配给空闲线程，否则，执行步骤2。</p><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>判断工作队列（阻塞队列BlockingQueue）是否已满。如果工作队列未满，将任务储存在工作队列中等待空闲线程调度。如果工作队列已满，执行步骤3。</p><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>判断当前线程池线程数量是否已达到最大值，如果没有达到最大值，则创建新的线程来执行任务。否则，执行步骤4。</p><h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>调用饱和策略来处理此任务</p><h3 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3><h4 id="通过new一个ThreadPool"><a href="#通过new一个ThreadPool" class="headerlink" title="通过new一个ThreadPool"></a>通过new一个ThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.corePoolSize（核心线程池大小）</p><p>当提交一个任务到线程池时，只要核心线程池未达到corePoolSize，创建新线程来执行任务。调用<code>preStartAllCoreThreads()</code>，线程池会提前创建并启动所有核心线程。</p><p>2.<code>BlockingQueue&lt;Runnable&gt; workQueue</code>(保存等待执行任务的阻塞队列)</p><p>ArrayBlockingQueue：基于数组的</p><p>maximumPoolSize</p><p>线程池的最大数量</p><p>keepAliveTime</p><p>线程保持存活的时间，如果任务比较多，并且每个人物的执行时间比较短，我们可以调大此参数</p><p>RejectedExecutionHandler handler</p><p>饱和策略，默认采用AbortPolicy：无法处理新任务抛出异常</p><p>CallerRunsPolicy：使用调用者所在线程来处理任务</p><p>DisCardOldestPolicy：丢弃队列中最近的一个任务并执行当前任务</p><p>DisCardPolicy：不处理任务，丢弃任务，也不报异常</p><p>调用Future接口的get方法会阻塞其他线程，直到取得当前线程执行完毕后的返回值</p><p>FutureTask中的任务只会被执行一次。</p><h4 id="关闭线程池方法"><a href="#关闭线程池方法" class="headerlink" title="关闭线程池方法"></a>关闭线程池方法</h4><p><code>executorService.shutdown();</code></p><h3 id="内置四大线程池"><a href="#内置四大线程池" class="headerlink" title="内置四大线程池"></a>内置四大线程池</h3><h4 id="固定大小线程池"><a href="#固定大小线程池" class="headerlink" title="固定大小线程池"></a>固定大小线程池</h4><ul><li>底层实现</li><li>应用场景</li></ul><p>固定大小线程池适用于为了满足资源管理需求，而需要限制当前线程数量的应用。适用于负载较重的服务器。</p><h4 id="单线程池SingleThreadExecutor"><a href="#单线程池SingleThreadExecutor" class="headerlink" title="单线程池SingleThreadExecutor"></a>单线程池SingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>应用场景</li></ul><p>适用于需要保证顺序执行各个任务；并且在任意时间，不会有多个线程</p><h4 id="缓存线程池CachedThreadPool"><a href="#缓存线程池CachedThreadPool" class="headerlink" title="缓存线程池CachedThreadPool"></a>缓存线程池CachedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据需要创建新线程</p><ul><li>应用场景</li></ul><p>当提交任务速度快于执行任务速度，缓存线程池会不断创建新线程。</p><p>大小无界线程池，适用于执行很多的短期异步小程序，</p><p>当执行速度比提交速度快，会只有一个线程。当提交速度比执行速度快，会有最大个数线程</p><h4 id="定时调度池ScheduledThreadPool"><a href="#定时调度池ScheduledThreadPool" class="headerlink" title="定时调度池ScheduledThreadPool"></a>定时调度池ScheduledThreadPool</h4><p>需要定时执行任务的应用场景</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线程池有三大优点：降低资源消耗、提高响应速度、提高线程的可管理性&lt;/p&gt;
&lt;h3 id=&quot;线程池的继承关系&quot;&gt;&lt;a href=&quot;#线程池的继承关系&quot; class=&quot;headerlink&quot; title=&quot;线程池的继承关系&quot;&gt;&lt;/a&gt;线程池的继承关系&lt;/h3&gt;&lt;h4 id=&quot;ExecutorService（普通调度池核心接口）&quot;&gt;&lt;a href=&quot;#ExecutorService（普通调度池核心接口）&quot; class=&quot;headerlink&quot; title=&quot;ExecutorService（普通调度池核心接口）&quot;&gt;&lt;/a&gt;ExecutorService（普通调度池核心接口）&lt;/h4&gt;&lt;p&gt;扩展了一个方法：submit()方法可以接受Callable和Runnable对象，并且都有返回值(接收Runnable接口对象也有返回值是因为Runnable对象在其内部会转换成为Callable对象)&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE之Lock体系</title>
    <link href="http://www.bingoxin.top/2018/11/19/JavaSE%E4%B9%8BLock%E4%BD%93%E7%B3%BB/"/>
    <id>http://www.bingoxin.top/2018/11/19/JavaSE之Lock体系/</id>
    <published>2018-11-19T12:35:20.000Z</published>
    <updated>2019-01-09T12:36:05.301Z</updated>
    
    <content type="html"><![CDATA[<p>lock锁与内键锁最大的区别是：需要手动的加锁和解锁</p><p>JDK1.5之后增加java.util.concurrent.locks提供了与内键锁完全不同的实现多线程共享资源访问机制。失去了内键锁隐式的加锁与解锁过程，增加了可中断的获取锁以及超时获取锁以及共享锁等内键锁不具备的特性。</p><a id="more"></a><h3 id="lock锁的标准使用形式"><a href="#lock锁的标准使用形式" class="headerlink" title="lock锁的标准使用形式"></a>lock锁的标准使用形式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock()</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="comment">//同步块</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lock接口API"><a href="#Lock接口API" class="headerlink" title="Lock接口API"></a>Lock接口API</h3><p>1.<code>void lock();</code>//获取锁</p><p>2.<code>void lockInterruptibly() throws InterruptedException;</code>//获取锁的过程能够响应中断（lock独有）</p><p>3.<code>boolean tryLock();</code>//获取锁返回true，反之返回false，可以响应中断</p><p>4.<code>boolean tryLock(long time,TimeUnit unit);</code>//在3的基础上增加了超时等待机制，规定时间内未获取到锁，线程直接返回（lock独有）</p><p>5.<code>void unlock()</code>//解锁</p><h3 id="Lock体系核心存在—AbstractQueuedSynchronizer-AQS同步器"><a href="#Lock体系核心存在—AbstractQueuedSynchronizer-AQS同步器" class="headerlink" title="Lock体系核心存在—AbstractQueuedSynchronizer(AQS同步器)"></a>Lock体系核心存在—AbstractQueuedSynchronizer(AQS同步器)</h3><ul><li>同步器的作用</li></ul><p>同步器是用来构建锁与其他同步组件的基础框架。它的组成有两部分：FIFO队列（同步队列）、int成员变量（同步状态）</p><p>要使用AQS，推荐使用静态内部类继承AQS，覆写AQS中的protected用来改变同步状态的方法，其他方法主要是实现排队与堵塞机制。状态更新使用<code>getState()</code>、<code>setState()</code>、<code>compareAndSetState()</code></p><p>Lock面向使用者，定义了使用者与锁交互的接口，隐藏了实现细节：</p><p>AQS面向锁的实现者，简化了锁的实现方式，屏蔽同步状态的管理、线程排队、线程等待与唤醒等底层操作</p><h3 id="AQS提供的模板方法"><a href="#AQS提供的模板方法" class="headerlink" title="AQS提供的模板方法"></a>AQS提供的模板方法</h3><p>AQS分为两类：独占锁和共享锁</p><ul><li>独占锁</li></ul><p>1、<code>void acquire(int arg)</code></p><p>独占式获取同步状态，如果获取失败则将当前线程插入同步队列进行等待</p><p>2、<code>void acquireTnterruptibly(int arg)</code></p><p>在1的基础上增加响应中断</p><p>3、<code>boolean tryAcquireNanos(int arg,long nanosTimeOut)</code></p><p>在2的基础上增加超时等待，在规定时间内未获取到同步状态返回false</p><p>4、<code>boolean tryAcquire(int arg)</code></p><p>获取状态成功返回true，否则返回false</p><p>5、<code>boolean release(int arg)</code></p><p>释放同步状态，该方法或唤醒在同步队列中的下一个节点</p><ul><li>共享锁</li></ul><p>AQS中的同步队列是一个带有头尾节点的双向链表，节点的组成为</p><p><code>Node prev</code></p><p><code>Node next</code></p><p><code>Thread thread</code></p><p>将线程封装为Node节点后进行入队与出队处理</p><h3 id="深入理解AQS"><a href="#深入理解AQS" class="headerlink" title="深入理解AQS"></a>深入理解AQS</h3><ul><li>独占式锁的获取—acquire</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用lock()方法的实质是调用sync.lock();</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用CAS将锁的同步状态置为1</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">//若成功将当前线程置为持有锁线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//调用acquire()方法，尝试获取锁</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//再次使用CAS尝试获取同步状态，若获取同步状态成功则直接返回，反之会先调用addWaiter()方法</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先使用addWaiter()方法，将封装的结点尾插到同步队列中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//将当前进程封装成结点</span></span><br><span class="line">            Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">            <span class="comment">// 获取同步队列的尾结点</span></span><br><span class="line">            Node pred = tail;</span><br><span class="line">            <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//若尾结点不为空，将封装的结点尾插到同步队列中</span></span><br><span class="line">                node.prev = pred;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                    pred.next = node;</span><br><span class="line">                    <span class="keyword">return</span> node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//尾结点为空，若同步队列没有进行初始化，将队列先进行初始化，然后将结点尾插到同步队列中</span></span><br><span class="line">            <span class="comment">//若同步队列已经初始化，将结点尾插到同步队列，返回</span></span><br><span class="line">            enq(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用acquireQueued()方法，从尾到头</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//中断状态</span></span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//记录同步队列尾结点的前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">//若p为头结点，及使用CAS获取同步状态成功</span></span><br><span class="line">                <span class="comment">//将node结点设为头结点，删去原来的头结点</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">//将node结点设为头结点</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    <span class="comment">//将原来的头结点弹出</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从尾开始将每个结点状态为取消的移出同步队列，状态为其他的结点状态设为阻塞</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">//判断当前线程是否被中断</span></span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将前驱节点的状态和当前节点的状态设置为阻塞状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//将同步队列中的状态为取消的结点去除</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//将其他状态的结点状态设为阻塞态</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="独占式锁的释放-release"><a href="#独占式锁的释放-release" class="headerlink" title="独占式锁的释放-release()"></a>独占式锁的释放-release()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unlock()实际上调用的是sync的release()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先调用tryRelease(arg)方法，判断锁的同步状态是否为1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">//获取到同步队列的头结点</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="独占式锁特性学习"><a href="#独占式锁特性学习" class="headerlink" title="独占式锁特性学习"></a>独占式锁特性学习</h3><ul><li>可中断式获取锁</li></ul><p>调用<code>void lockInterruptibly() throws InterruptedException</code></p><p>最终会调用AQS<code>acquireInterruptibly(int arg)</code>模板方法</p><p>1.先判断线程是否处于中断状态，若中断状态被改变，抛出中断异常后方法直接退出</p><ul><li>超时等待获取锁</li></ul><p>在中断式获取锁的基础上，增加了超时功能</p><p>带方法本质调用AQS的模板方法<code>tryAcquireNano(int arg,long nanosTimeout)</code></p><p>在超时时间范围内，若还没被唤醒，则线程退出</p><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>reentrantLock（Lock中使用频率最高的类）-可重入锁</p><p>内键锁隐式支持重入性</p><ul><li>重入性实现原理</li></ul><p><strong>特点：</strong></p><p>1.线程获取锁的时候，如果已经获取锁的线程是当前线程直接再次获取</p><p>2.由于锁会被获取N次，因此锁只有被释放N次之后才算真正释放</p><p>拿到当前线程，获取当前同步状态，当前同步状态还未被获取，当前线程使用CAS尝试获取同步状态；</p><p>此时当前线程的同步状态为1 ，判断所持线程是否为当前线程，若是，nextu++;</p><p>返回false</p><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>公平锁：锁的获取顺序一定满足时间上的绝对顺序</p><p>reentrantLock默认使用非公平锁，其还有一个有参构造，传入的是一个Boolean值，来觉得创建的是公平锁还是非公平锁</p><p>在公平锁中，增加了一个hasQueuedPrecessors()方法，用来看当前同步队列中是否存在非空节点，若存在不会再使用CAS。</p><p><strong>公平锁与非公平锁的对比：</strong></p><p>公平锁保证每次获取锁均为同步队列的第一个非空节点，保证了请求资源上的时间绝对顺序，但是效率低，需要频繁的进行上下文切换</p><p>非公平锁会降低性能开销，降低一定要进行上下文切换，但是可能导致其他线程永远无法获取到锁，造成线程的饥饿现象</p><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>读写模型：</p><p>读写锁允许同一时刻被多个读线程访问，但是在写线程访问时，所有的读线程以及其他的写线程均会被阻塞</p><ul><li>如何区分读状态和写状态</li></ul><p>同步状态的高16位表示读锁获取次数，低16位表示写锁获取次数</p><h3 id="读锁—共享锁（一般与读写锁一起使用来实现读写模型）"><a href="#读锁—共享锁（一般与读写锁一起使用来实现读写模型）" class="headerlink" title="读锁—共享锁（一般与读写锁一起使用来实现读写模型）"></a>读锁—共享锁（一般与读写锁一起使用来实现读写模型）</h3><ul><li>读锁获取：</li></ul><p>只有当前没有写线程获取到写锁并且读锁的获取次数不超过最大值，读锁就能获取成功</p><ul><li>读写锁应用场景</li></ul><p>缓存的实现</p><h3 id="Condition的await与signal"><a href="#Condition的await与signal" class="headerlink" title="Condition的await与signal"></a>Condition的await与signal</h3><p>Object的wait与notify是与内键锁（对象监视器）搭配使用，完成线程的等待与通知机制</p><p>Condition的await、signal是与Lock体系配合实现线程的等待与通知，Java语言层面实现，具有更高的控制与扩展性</p><p>await():</p><p>1.无参构造   同wait()</p><p>2.<code>awaitUminterruptibly()</code>特性是等待过程不响应中断</p><p>3.<code>boolean await(long time,TimeUnit unit)</code>在1的基础上增加了超时等待功能，可以自定义时间单位</p><p>4.<code>boolean awaitUntil(Date deadline)</code>特性：支持设置截止时间</p><p>signal，signalAll()</p><ul><li>Condition支持多个等待队列</li></ul><p>Condition队列与AQS中的同步队列共享结点（Node）数据结构</p><p>带有头尾指针的单向队列</p><p>每当调用<code>lock.newCondition()</code>就会在绑定的lock锁上新增一个等待队列</p><ul><li>应用场景</li></ul><p>使用Condition实现有界队列</p><h3 id="LockSupport工具类"><a href="#LockSupport工具类" class="headerlink" title="LockSupport工具类"></a>LockSupport工具类</h3><ul><li>与内键锁的阻塞区别</li></ul><p>内键锁阻塞进入BLOCKED</p><p><code>LockSupport.park()</code>进入WAIT</p><ul><li>唤醒</li></ul><p>内键锁由JVM随机挑选一个线程唤醒</p><p><code>LockSupport.unPark(Thread thread)</code>唤醒指定线程</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁产生原因：对共享资源的上锁成环</p><p>AQS源码：</p><p>1.独占锁的获得与释放</p><p>2.响应中断和超时等待</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;lock锁与内键锁最大的区别是：需要手动的加锁和解锁&lt;/p&gt;
&lt;p&gt;JDK1.5之后增加java.util.concurrent.locks提供了与内键锁完全不同的实现多线程共享资源访问机制。失去了内键锁隐式的加锁与解锁过程，增加了可中断的获取锁以及超时获取锁以及共享锁等内键锁不具备的特性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>post</title>
    <link href="http://www.bingoxin.top/2018/11/16/%E4%B9%90%E8%A7%82%E9%94%81CAS%E6%93%8D%E4%BD%9C---compare-Swap/"/>
    <id>http://www.bingoxin.top/2018/11/16/乐观锁CAS操作---compare-Swap/</id>
    <published>2018-11-16T12:31:44.000Z</published>
    <updated>2019-01-08T12:33:48.449Z</updated>
    
    <content type="html"><![CDATA[<h3 id="悲观锁概念—JDK1-6之前"><a href="#悲观锁概念—JDK1-6之前" class="headerlink" title="悲观锁概念—JDK1.6之前"></a>悲观锁概念—JDK1.6之前</h3><p>假设每一次执行同步代码块均会产生冲突，所以当线程获取锁成功，会阻塞其他尝试该锁的线程</p><h3 id="乐观锁概念"><a href="#乐观锁概念" class="headerlink" title="乐观锁概念"></a>乐观锁概念</h3><p>假设所有线程访问共享资源时不会出现冲突，既然不会出现冲突自然就不会阻塞其他线程。线程就不会出现阻塞状态</p><p>CAS是无锁操作，使用CAS叫做比较交换来判断是否出现冲突，出现冲突就重试直到不冲突为止</p><a id="more"></a><h3 id="CAS的操作过程"><a href="#CAS的操作过程" class="headerlink" title="CAS的操作过程"></a>CAS的操作过程</h3><p>CAS的交换过程有三个值：V（内存中地址存放的实际值）、O（内存中地址存放的预期值）、N（内存中地址存放的更新后的值）</p><ul><li>当执行CAS后</li></ul><p>如果V==O，即旧值与内存中的实际值相等，表示上次修改该值后没有任何线程再次修改此值，因此可以将N替换到内存中；</p><p>如果V！=O，表示该内存中的值已经被其他线程做了修改，所以无法将N替换，返回最新的值V</p><p>当多个线程使用CAS操作同一个变量时，只有一个线程会成功，并成功更新变量值，其余线程均会失败。失败线程会重新尝试或将线程挂起（阻塞）</p><p>synchronized最主要的问题：当存在线程竞争的情况下，会出现线程阻塞以及唤醒带来的性能问题，对应互斥同步（阻塞同步），效率很低</p><p>而CAS并不是武断的将线程挂起，会尝试若干次CAS操作，并非进行耗时的挂起与唤醒操作，因此非阻塞式同步</p><h3 id="CAS产生的问题"><a href="#CAS产生的问题" class="headerlink" title="CAS产生的问题"></a>CAS产生的问题</h3><ul><li>ABA问题</li></ul><p>ABA问题指的是，当线程1 拿到这把锁后将N值改为线程1的值，当线程1执行完该代码块的内容后，去执行了另一段同步代码块的内容。这时线程2要来执行这段代码块，这是V的值与O的值相等，那么线程2也就拿到了这把锁，在他执行完这段代码后，此时N的值和之前的值相同。而当线程1再次来哪这把锁时，仍然满足V == O，如何解决？</p><p>解决思路：沿用数据库的乐观锁机制，添加版本号1A-2B-3A</p><p>JDK1.5提供atomic包下AtomicStampedReference类来解决CAS的ABA问题</p><ul><li>自旋会浪费大量的处理器资源</li></ul><p>自旋即当进程遇到V！=O时，进程会不断地尝试。与线程阻塞相比，自旋会浪费大量的CPU资源，因为此时线程仍处于运行状态，只不过跑的是无用指令，期望在执行无用指令时，锁能被释放出来</p><p><strong>解决思路：</strong>根据以往自旋等待时能否获取到锁，来动态调整自旋的时间（循环尝试数量）</p><p><strong>自适应自旋：</strong>如果在上一次自旋时获取到锁，则此次自旋时间稍微变长一点；如果在上一次自旋结束还没有获得锁，此次自旋时间稍微短一点</p><ul><li>公平性</li></ul><p>处于阻塞状态的线程无法立刻竞争被释放的锁；而处于自旋状态的线程含有可能先获取到锁</p><p>内建锁无法实现公平性，而lock体系可以实现公平锁</p><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>monitor是Java对象头的标记</p><p>JDK1.6之后对内建锁做了优化（新增偏向、轻量级锁）</p><p>锁共有四种状态：</p><blockquote><p>1.无锁状态-0–01</p><p>2.偏向锁-1–01</p><p>3.轻量级锁–00</p><p>4.重量级锁–10</p></blockquote><p>由于无锁状态和偏向锁的标记位都是01，那么为了区分两种锁，在对象头标记中又设置了一个标记位，该标志位用于区分无锁状态和偏向锁状态</p><p>这四种状态随着竞争情况逐渐升级，<strong>锁可以升级不能降级</strong>，为了提高获得锁与释放锁的效率</p><ul><li>偏向锁</li></ul><p>最乐观的锁，从始至终只有一个线程请求一把锁，没有自旋状态</p><p><strong>偏向锁获取：</strong></p><p>当<strong>一个线程</strong>访问同步代码块并获取锁时，会在对象头和栈桢中的锁记录中记录储存偏向锁的线程ID，以后该线程再次进入同步代码块时，不再需要CAS来加锁和解锁，只需简单测试一下对象头的mark word中偏向锁线程ID是否是当前线程ID，如果成功，表示线程已经获取到锁直接进入代码块运行</p><p>如果测试失败，检查当前偏向锁字段是否为0，如果为0，采用CAS操作将偏向锁字段设置为1，并且更新自己的线程ID到mark word字段中</p><p>如果为1，表示此时偏向锁已经被别的线程获取，则此线程需要不断尝试使用CAS获取偏向锁；或者将偏向锁撤销，升级为轻量级锁，升级为轻量级锁的概率比较高</p><p>加锁过程如图：</p><div align="center"><br>    <img src="/images/posts/CAS乐观锁/偏向锁.png" height="673" width="388"><br></div><br><strong>偏向锁的撤销：</strong><br><br>偏向锁使用一种等到竞争出现才释放锁的机制，当有其他进程尝试竞争偏向锁时，持有偏向锁的进程才会释放偏向锁<br><br><font color="red">注意：</font>偏向锁的撤销开销比较大，需要等待线程进入全局安全点safepoint（当前线程在CPU上没有执行任何有用字节码）<br><br>偏向锁在JDK6之后默认开启，但是他在应用程序启动几秒后才激活。<br><br>-XX：BiasedLockingStartupDelay=0，将延迟关闭，JVM一启动就激活偏向锁<br><br>-XX：-UseBiasedLocking=false，关闭偏向锁，程序默认进入轻量级锁<br><br>- 轻量级锁<br><br><strong>概念：</strong><br><br><strong>多个线程</strong>在不同时间段，请求同一把锁，也就是基本不存在锁竞争。针对此种状况，JVM采用轻量级锁来避免线程的堵塞以及唤醒<br><br><strong>加锁过程：</strong><br><br>线程在执行同步代码块之前，JVM先在当前线程的栈桢中创建<strong>用于存储锁记录</strong>的空间，并将对象头的mark word字段直接复制到此空间中，然后线程尝试使用CAS将对象头的mark word替换为指向锁记录的指针（指向当前线程），如果成功表示获取到轻量级锁。如果失败，表示其他线程竞争轻量级锁，当前线程便使用自旋来不断尝试<br><br><strong>释放过程：</strong><br><br>解锁时，会使用CAS将复制的mark word替换回对象头，如果成功，表示没有竞争发生，正常解锁；如果失败，表示当前所存在竞争，进一步膨胀为重量级锁<br><br><div align="center"><br>    <img src="/images/posts/CAS乐观锁/轻量级锁.png" height="547" width="730"><br></div><ul><li>重量级锁</li></ul><p>重量级锁会阻塞、唤醒请求加锁的线程。针对的是多个线程同一时刻竞争同一把锁的情况，JVM采用自适应自旋，来避免线程在面对非常小的同步块时，仍会被阻塞以及唤醒。</p><p>轻量级锁采用CAS操作，将锁对象的标记字段替换为指向线程的指针，存储着锁对象原本的标记字段。针对的是多个线程在不同时间段申请同一把锁的情况</p><p>偏向锁只会在第一次请求时采用CAS操作，在锁对象的mark word字段中记录下当前线程ID，此后运行中持有偏向锁的线程不再有加锁过程。针对的是锁仅会被同一线程持有</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;悲观锁概念—JDK1-6之前&quot;&gt;&lt;a href=&quot;#悲观锁概念—JDK1-6之前&quot; class=&quot;headerlink&quot; title=&quot;悲观锁概念—JDK1.6之前&quot;&gt;&lt;/a&gt;悲观锁概念—JDK1.6之前&lt;/h3&gt;&lt;p&gt;假设每一次执行同步代码块均会产生冲突，所以当线程获取锁成功，会阻塞其他尝试该锁的线程&lt;/p&gt;
&lt;h3 id=&quot;乐观锁概念&quot;&gt;&lt;a href=&quot;#乐观锁概念&quot; class=&quot;headerlink&quot; title=&quot;乐观锁概念&quot;&gt;&lt;/a&gt;乐观锁概念&lt;/h3&gt;&lt;p&gt;假设所有线程访问共享资源时不会出现冲突，既然不会出现冲突自然就不会阻塞其他线程。线程就不会出现阻塞状态&lt;/p&gt;
&lt;p&gt;CAS是无锁操作，使用CAS叫做比较交换来判断是否出现冲突，出现冲突就重试直到不冲突为止&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE之线程同步</title>
    <link href="http://www.bingoxin.top/2018/11/12/JavaSE%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>http://www.bingoxin.top/2018/11/12/JavaSE之线程同步/</id>
    <published>2018-11-12T12:30:09.000Z</published>
    <updated>2019-01-01T12:44:31.665Z</updated>
    
    <content type="html"><![CDATA[<p>同步问题：每一个线程对象轮番强占共享资源带来的问题</p><ul><li>同步处理</li></ul><p>使用内部关键字synchronized来处理同步问题，synchronized处理同步有两种方式：同步代码块、同步方法</p><ul><li>使用同步代码块</li></ul><p>设置一个锁定的对象，一般可以锁当前<strong>对象</strong>this，也可以锁一个类或任意对象</p><ul><li>同步方法</li></ul><p>在方法上添加synchronized关键字，表示此方法只有一个线程能进入。<strong>隐式锁对象，this</strong></p><a id="more"></a><h3 id="线程由运行态到阻塞态"><a href="#线程由运行态到阻塞态" class="headerlink" title="线程由运行态到阻塞态"></a>线程由运行态到阻塞态</h3><ul><li>调用<code>sleep()</code>方法</li></ul><p>线程由运行态到阻塞态，立刻交出CPU，但不释放对象锁</p><ul><li>线程调用阻塞式IO（BIO）方法</li><li>线程获取锁失败进入阻塞态</li><li>线程调用<code>wait()</code></li><li>线程调用<code>suspend()</code>，将线程挂起</li></ul><p>每个锁对象都有两个队列，一个称为同步队列，存储获取锁失败的线程。另一个称为等待队列，存储调用<code>wait()</code>等待的线程。将线程唤醒实际上是将处于等待队列的线程移到同步队列中竞争锁</p><h3 id="synchronize底层实现"><a href="#synchronize底层实现" class="headerlink" title="synchronize底层实现"></a>synchronize底层实现</h3><ul><li>类锁的实例化对象</li></ul><p><strong>锁当前对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">synchronize(<span class="keyword">this</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>锁类对象(全局锁)：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">synchronize(类名称.class)&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>任意实例对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String lock = <span class="string">""</span>;</span><br><span class="line">synchronize(lock)&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>同步方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">普通方法+synchronize :锁得是当前对象</span><br><span class="line">静态方法+synchronize :锁的是类-全局锁，效果等同于同步代码块的锁类对象</span><br></pre></td></tr></table></figure><ul><li>对象锁机制—JDK6之前</li></ul><p><strong>执行同步代码块底层操作</strong></p><blockquote><p>a.执行同步代码块后，首先要执行monitorenter指令，退出时执行monitorexit指令</p><p>b.使用内建锁(synchronized)进行同步，关键在于要获取指定锁对象monitor对象</p><p>c.当线程获取monitor后才能继续向下执行，否则就只能等待。这个获取过程是互斥的，即同一时刻只有一个线程能够获取到对象monitor</p><p>d.通常一个monitorenter指令会包含若干个monitorexit指令。原因在于JVM需要确保在正常执行路径以及异常执行路径上都能够正确解锁</p></blockquote><p><strong>执行同步方法底层实现</strong></p><p>当使用synchronized标记方法时，编译时字节码中方法的访问标记多了一个ACC_SYNCHRONIZED。该标记表示，进入该方法时，JVM需要进行monitorenter操作，退出该方法时，无论是否正常返回，JVM均需要进行monitorexit操作。也就是说，同步方法只能锁当前对象，同步方法和同步代码块的处理机制是相同的。</p><p><strong>互斥的底层实现：</strong>当执行monitorenter时，如果目标锁对象的monitor计数器为0，表示此对象没有被任何其他对象所特有。此时JVM会将该锁对象的持有线程设置为当前线程，并且将计数器+1；若执行monitorenter时，如果目标锁对象的monitor计数器为1，需判断该锁对象的持有线程是否为当前线程，若不是，则无法获取锁，需要进行等待。</p><p><strong>可重入性的底层实现：</strong></p><blockquote><p>a.如果目标锁对象的计数器不为0，判断锁对象的持有线程是否是当前线程，如果是再次将计数器+1（锁的可重入性）</p><p>b.如果锁对象的持有线程不是当前线程，当前线程需要等待，直至持有线程释放锁</p><p>c.当执行monitorexit时，JVM会将锁对象的计数器-1，当计数器值减为0时，代表该锁对象已经被释放</p></blockquote><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同步问题：每一个线程对象轮番强占共享资源带来的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用内部关键字synchronized来处理同步问题，synchronized处理同步有两种方式：同步代码块、同步方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用同步代码块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置一个锁定的对象，一般可以锁当前&lt;strong&gt;对象&lt;/strong&gt;this，也可以锁一个类或任意对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在方法上添加synchronized关键字，表示此方法只有一个线程能进入。&lt;strong&gt;隐式锁对象，this&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE之多线程</title>
    <link href="http://www.bingoxin.top/2018/11/11/JavaSE%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.bingoxin.top/2018/11/11/JavaSE之多线程/</id>
    <published>2018-11-11T12:28:11.000Z</published>
    <updated>2019-01-12T12:29:04.153Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>进程的概念</li></ul><p>os中一个程序的执行周期</p><ul><li>线程概念</li></ul><p>进程中的一个任务，一个进程中包含N个线程</p><a id="more"></a><ul><li>进程与线程的区别</li></ul><blockquote><p>a.每个进程拥有自己的一整套变量，是操作系统中资源分配的最小单位。线程依托于进程存在，多个线程共享进程的资源，os中任务调度的基本单位。</p><p>b.启动、撤销一个进程的开销要比启动、撤销一个线程的开销大得多。</p><p>c、没有进程就没有线程，进程一旦终止，其内线程全部撤销</p></blockquote><ul><li>高并发</li></ul><p>同一时刻线程的访问量非常高</p><h3 id="Java多线程实现"><a href="#Java多线程实现" class="headerlink" title="Java多线程实现"></a>Java多线程实现</h3><ul><li>继承thread类实现多线程</li></ul><p>java.lang.Thread是线程操作的核心类，JDK1.0提供</p><p>新建一个线程最简单的方法就是直接继承Thread类而后覆写类中的run()方法（相当于主方法）</p><p><strong>无论那种方式实现多线程，线程启动一律调用Thread类提供的start()方法</strong></p><p><strong>start()方法解析：</strong></p><blockquote><p>1.一个线程的start只能调用一次。首先检查线程状态是否为0（线程默认状态为0表示未启动），如果已经启 动start()方法会抛出非受查异常IllegalThreadStateException。</p><p>2.private native void start0()  通过strat0真正将线程启动</p><p>3.JVM调用start0方法进行资源分配与系统调度，准备好资源启动线程后回调run()来执行线程的具体任务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> String yellow;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread1</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        yellow = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">10</span>;i &gt; <span class="number">0</span>;--i)&#123;</span><br><span class="line">            System.out.println(yellow+<span class="string">"还剩"</span>+ticket--+<span class="string">"张票"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreads</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,Exception</span>&#123;</span><br><span class="line">        Thread MyThread1 = <span class="keyword">new</span> MyThread1(<span class="string">"黄牛A"</span>);</span><br><span class="line">        Thread MyThread2 = <span class="keyword">new</span> MyThread1(<span class="string">"黄牛B"</span>);</span><br><span class="line">        Thread MyThread3 = <span class="keyword">new</span> MyThread1(<span class="string">"黄牛C"</span>);</span><br><span class="line">        MyThread1.start();</span><br><span class="line">        MyThread2.start();</span><br><span class="line">        MyThread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Runnable接口实现多线程</li></ul><blockquote><p>a.Java中的多线程处理就是一个典型的代理模式，其中Thread类完成资源调度、系统分配辅助线程业务类；自定义的线程负责真是业务实现。</p><p>b.使用Runnable接口实现的多线程程序类可以更好地描述资源共享</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread2</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        name = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">10</span>;i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line">            System.out.println(name+<span class="string">"还剩"</span>+ticket--+<span class="string">"张票"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreads</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,Exception</span>&#123;</span><br><span class="line">        MyThread2 myThread1 = <span class="keyword">new</span> MyThread2(<span class="string">"黄牛A"</span>);</span><br><span class="line">        MyThread2 myThread2 = <span class="keyword">new</span> MyThread2(<span class="string">"黄牛B"</span>);</span><br><span class="line">        MyThread2 myThread3 = <span class="keyword">new</span> MyThread2(<span class="string">"黄牛C"</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(myThread1);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(myThread2);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(myThread3);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Callable\<v>接口实现多线程—唯一一个线程执行后有返回值</v></li></ul><p>juc:高并发程序包</p><p>java.util.concurrent.Callable，JDK1.5提供</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">call</span><span class="params">()</span><span class="keyword">throws</span> Exception:线程执行后有返回值V</span></span><br></pre></td></tr></table></figure><p>java.util.Future\<v>：</v></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException,ExecutionException:</span></span><br><span class="line"><span class="function">取得Callable接口call方法的返回值</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">10</span>;i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line">           System.out.println(<span class="string">"还剩"</span>+ticket--+<span class="string">"张票"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"票卖完了"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreads</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,Exception</span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(myThread);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程需要返回值时，只能采用Callable接口实现多线程</p><h3 id="多线程常用多线程方法"><a href="#多线程常用多线程方法" class="headerlink" title="多线程常用多线程方法"></a>多线程常用多线程方法</h3><ul><li>线程的命名与取得</li></ul><p><strong>通过构造方法将线程命名</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target,String name)</span></span></span><br></pre></td></tr></table></figure><p><strong>设置线程名称</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span></span><br></pre></td></tr></table></figure><p><strong>取得线程名称</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>取得当前正在执行的线程对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title">currentThread</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>Java中的main实际上是一个主线程（main）</p><ul><li>线程休眠—静态方法sleep(毫秒)</li></ul><p><strong>概念：</strong>让线程暂缓执行，等到了预计时间再恢复执行</p><p>线程休眠会立即交出CPU，让CPU去执行其他任务。线程休眠不会释放对象锁</p><ul><li>线程让步</li></ul><p>暂停当前正在执行的线程对象，并执行其他线程</p><p>yield()会让当前线程交出CPU，但<strong>不一定立即交出</strong>。yield()交出CPU后只能让拥有相同优先级的线程有获取CPU的机会。yield()不会释放对象锁</p><ul><li>join()方法</li></ul><p>等待该线程终止，如果在主线程中调用该方法会让主线程休眠，让调用该方法的线程先执行完毕后再恢复执行主线程</p><p>join方法只是对Object类wait()做了一层包装而已</p><ul><li>线程停止</li></ul><p>a.<strong>手工设置标记位，让线程在满足条件后退出</strong></p><p>b.<strong>使用stop方法强制让线程退出，但是该方法不安全已经被@Deprecated</strong></p><p>c.<strong>使用Thread类提供的interrupt()方法中断线程</strong>—只是将线程状态改为中断状态而已，它不会中断一个正在运行的线程</p><p>如果线程调用了，wait()、sleep()、join()进入阻塞态，调用该线程的interrupt()会抛出InterruptedException，并且将线程interrupt重置为false</p><h3 id="线程优先级-1-10"><a href="#线程优先级-1-10" class="headerlink" title="线程优先级(1~10)"></a>线程优先级(1~10)</h3><p>线程的优先级是指，优先级越高有<strong>有可能</strong>先执行</p><ul><li>设置优先级</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriorty)</span></span></span><br></pre></td></tr></table></figure><ul><li>获得优先级</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPriorty</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><ul><li>优先级默认参数</li></ul><p>Thread.MAX_PRIORITY = 10</p><p>Thread.MORM_PRIORITY =  5</p><p>Thread.MIN_PRIORITY = 1</p><ul><li>线程的继承性</li></ul><p>优先级可以继承，在A线程中启动B线程，则A和B的优先级一样</p><h3 id="守护线程-后台线程"><a href="#守护线程-后台线程" class="headerlink" title="守护线程(后台线程)"></a>守护线程(后台线程)</h3><ul><li>概念</li></ul><p>当前JVM进程中存在任何一个用户线程没有结束，守护线程就一直工作；只有当最后一个用户线程停止后，守护线程会随着JVM进程一同停止</p><p>守护线程属于陪伴线程</p><ul><li>线程的分类</li></ul><p>线程分为<strong>用户线程</strong>和<strong>守护线程</strong>—–判断函数isDaemon()—判断是否是守护线程</p><p>垃圾回收线程属于守护线程</p><ul><li>设置方式</li></ul><p><code>setDaemon()</code>将当前线程设置为守护线程，必须在线程启动之前设置</p><p><strong>Java中启动的线程默认为用户线程，包括main线程</strong></p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;进程的概念&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;os中一个程序的执行周期&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程概念&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程中的一个任务，一个进程中包含N个线程&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE新特性</title>
    <link href="http://www.bingoxin.top/2018/11/05/JavaSE%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://www.bingoxin.top/2018/11/05/JavaSE新特性/</id>
    <published>2018-11-05T12:25:43.000Z</published>
    <updated>2019-01-06T12:27:10.689Z</updated>
    
    <content type="html"><![CDATA[<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>定义一个表示基本颜色的类—多例模式</p><ul><li>语法</li></ul><p>枚举使用enum关键字定义枚举，枚举就是一种多例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color&#123;</span><br><span class="line">    RED,BLUE,GREEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Enum类</li></ul><p>JDK1.5新增的enum枚举结构并不是新的结构，使用enum定义的枚举本质上是一个类，默认继承java.lang.Enum父类</p><a id="more"></a><p><strong>属性：</strong></p><p>取得枚举名字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">name</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>取得枚举编号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">ordinal</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>取得所有枚举对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">枚举类.values():Enum[]</span><br></pre></td></tr></table></figure><h4 id="enum与Enum的区别"><a href="#enum与Enum的区别" class="headerlink" title="enum与Enum的区别"></a>enum与Enum的区别</h4><p>enum是一个关键字，使用enum定义的枚举类本质上就相对于一个类继承了Enum这个抽象类</p><h4 id="枚举中定义其他结构"><a href="#枚举中定义其他结构" class="headerlink" title="枚举中定义其他结构"></a>枚举中定义其他结构</h4><ul><li>普通属性</li><li>普通方法</li><li>内部类</li><li>实现接口：此时枚举中的每个对象都成为了接口对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IColor</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">color</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Color implements IColor&#123;</span><br><span class="line">    RED,BLUE,GREEN;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String title)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="red"><strong>枚举对象必须放在首行声明</strong></font><h3 id="注解—Annotation"><a href="#注解—Annotation" class="headerlink" title="注解—Annotation"></a>注解—Annotation</h3><ul><li>JDK提供的三大内置注解</li></ul><p><strong>声明覆写---@Override</strong></p><p>检查当前类中的覆写方法与父类定义的同名方法是否相同，如果有任何一个地方不同，编译报错</p><p><strong>声明过期处理---@Deprecated</strong></p><p>原有类或者方法在旧版本没有问题，但是在新版本不推荐使用，可以加上该关键字注解，明确表示不建议用户使用此类</p><p><strong>@SuppressWarnings</strong></p><p>当调用某些操作可能产生问题时，就会出现警告信息，警告信息并不是Exception</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unused"</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="JDK1-8新特性"><a href="#JDK1-8新特性" class="headerlink" title="JDK1.8新特性"></a>JDK1.8新特性</h3><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul><li>可以使用default来定义普通方法，需要通过对象来调用</li><li>可以使用static来定义静态方法，通过接口来调用</li></ul><h4 id="lambda表达式—函数式编程"><a href="#lambda表达式—函数式编程" class="headerlink" title="lambda表达式—函数式编程"></a>lambda表达式—函数式编程</h4><p>要想使用函数式编程有一个前提：接口必须只有一个方法。</p><p>如果接口中存在两个以上的方法，无法使用函数式编程语法。</p><p>如果现在某个接口就是为了函数式编程而生，@FunctionalInterface定义在接口上，检查此接口是否只存在一个方法。</p><ul><li>lambda表达式语法</li></ul><p>单行无返回值、单行有返回值:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()-&gt;...方法代码;</span><br></pre></td></tr></table></figure><p>多行有返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">()-&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> 返回值语句;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; class=&quot;headerlink&quot; title=&quot;枚举&quot;&gt;&lt;/a&gt;枚举&lt;/h3&gt;&lt;p&gt;定义一个表示基本颜色的类—多例模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;枚举使用enum关键字定义枚举，枚举就是一种多例模式&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; Color&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RED,BLUE,GREEN;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Enum类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JDK1.5新增的enum枚举结构并不是新的结构，使用enum定义的枚举本质上是一个类，默认继承java.lang.Enum父类&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的泛型</title>
    <link href="http://www.bingoxin.top/2018/11/05/Java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B/"/>
    <id>http://www.bingoxin.top/2018/11/05/Java中的泛型/</id>
    <published>2018-11-05T12:24:06.000Z</published>
    <updated>2019-01-06T12:27:25.145Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JDK1-5新特性"><a href="#JDK1-5新特性" class="headerlink" title="JDK1.5新特性"></a>JDK1.5新特性</h3><ul><li>方法的可变参数</li></ul><p><strong>语法：</strong></p><p>数据类型 … 可变参数名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ... data</span><br></pre></td></tr></table></figure><blockquote><p>a. 可变参数的本质是数组</p><p>b. 一个方法中只允许一个可变参数，可变参数一定是方法最后一个参数</p></blockquote><a id="more"></a><ul><li>foreach循环</li></ul><p>只用于数组、类集内容的取得，不能修改原数组、类集内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (数据类型 临时变量 : 数组名/类集名)</span><br><span class="line">例：</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> temp:data)</span><br></pre></td></tr></table></figure><ul><li>静态导入</li></ul><p>将一个类的所有静态域（包含静态属性、方法），全部导入到使用类中，此时调用属性和方法不再需要类名</p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>所谓的泛型指的是在定义类时，并不会设置类中的属性或方法的参数的具体类型，而是在类使用时再定义</p><p>安全性考虑，不再有类型转换异常</p><ul><li>语法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&lt;&gt;中的T被称为类型参数，用于指代任何类型</p><ul><li>出于规范起见，类型参数一般由单个的大写字母来表示：</li></ul><p>T：代表用在泛型类声明上，指代泛型类</p><p>E:一般用于属性</p><p>K、V：键值对</p><p>当泛型类中需要多个不同类型变量时，&lt;&gt;以，分隔声明不同大写字母即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">T</span>,<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    T t;</span><br><span class="line">    E x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型的出现彻底解决了向下转型带来的ClassCastException问题</strong></p><p><strong>泛型只能用引用数据类型，基本类型使用包装类</strong></p><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><ul><li>语法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当泛型类与泛型方法共存时，泛型方法中的类型参数与泛型类的类型参数无关，泛型方法始终以自己的类型参数为准</p><p>规范起见，当泛型类与泛型方法共存时，请使用不同的类型参数来区分彼此</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>解决泛型参数统一化问题</p><ul><li>？通配符</li></ul><p>作用于方法参数声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(MyClass&lt;?&gt; myClass)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时方法参数表示可以接收任意类型的MyClass对象</p><p>由于无法确定入参的类型，因此？通配符下的泛型参数，只能取得类中属性值，无法进行属性值的设置</p><ul><li>设置泛型上限</li></ul><p>用于泛型类声明：<code>T extends 类</code>，即T是这个类本身或其子类</p><p>方法参数：<code>？ extends 类</code></p><p>eg: <code>? extends Number :</code></p><p>表示方法入参只能接收Number以及其子类对象</p><p>方法参数设置泛型上限仍然取得类中属性值，而无法设置，因为设置父类值子类不一定能使用（父类不一定能发生向下转型变为子类）</p><ul><li>设置泛型下限—只能用于方法参数</li></ul><p><code>? super 类()</code>,这个类或这个类的父类</p><p>表示方法入参只能接收类以及其父类对象</p><p>方法参数设置泛型下限不仅可以取得类中属性值，还可以设置属性值。因为子类可以天然向上转型变为父类</p><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><ul><li>子类实现接口时继续保留泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InterfaceImpl&lt;T&gt; implements IInterface&lt;T&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>子类实现接口时就确定好类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InterfaceImpl implements IImterface&lt;String&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p><strong>泛型信息仅存在代码编译阶段</strong>，进入JVM之前，与泛型相关的信息会被擦除掉，专业术语就叫做类型擦除</p><p>换句话说，泛型类与普通类在JVM中没有任何差别</p><p>泛型类进入JVM之前会进行类型擦除，泛型类的类型参数如果没有指定类型上限，则擦除成为Object类；如果类型参数指定类型上限，擦除为相应类型上限</p><p>\<t>—&gt; Object</t></p><p>\<t extends="" string=""> -&gt; String</t></p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JDK1-5新特性&quot;&gt;&lt;a href=&quot;#JDK1-5新特性&quot; class=&quot;headerlink&quot; title=&quot;JDK1.5新特性&quot;&gt;&lt;/a&gt;JDK1.5新特性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;方法的可变参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据类型 … 可变参数名称&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ... data&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;a. 可变参数的本质是数组&lt;/p&gt;
&lt;p&gt;b. 一个方法中只允许一个可变参数，可变参数一定是方法最后一个参数&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Object类</title>
    <link href="http://www.bingoxin.top/2018/10/30/Java%E4%B8%AD%E7%9A%84Object%E7%B1%BB/"/>
    <id>http://www.bingoxin.top/2018/10/30/Java中的Object类/</id>
    <published>2018-10-30T12:22:43.000Z</published>
    <updated>2018-12-31T12:23:17.853Z</updated>
    
    <content type="html"><![CDATA[<p>Object类是JDK默认提供的一个类。Java中除了Object类，所有的类都存在继承关系，默认会继承Object父类</p><ul><li>toString()-取得对象信息</li></ul><p>系统输出默认调用对象的toString方法</p><p>Object类中的toString方法只是简单输出当前引用的类名称以及对象地址</p><p>如果想在类中取得本类属性信息，需要覆写toString();</p><p>String类对该方法进行覆写，若String类调用该方法会返回String类的内容</p><a id="more"></a><ul><li><p>对象比较—equals</p></li><li><p>接受引用数据类型</p></li></ul><p>Object可以接受所有引用数据类型：数组、类、接口</p><h3 id="包装类—使用Object接受一切数据"><a href="#包装类—使用Object接受一切数据" class="headerlink" title="包装类—使用Object接受一切数据"></a>包装类—使用Object接受一切数据</h3><ul><li>概念</li></ul><p>包装类就是将基本数据类型封装到类中</p><ul><li>包装类的分类</li></ul><p><strong>数值型包装类</strong>（Number的直接子类）：Byte、Double、Short、Long、Float、Integer</p><p>会发生类型转换异常—&gt;NumberFormatException</p><p><strong>对象型包装类</strong>（Object的直接子类）：Boolean、Character（char）</p><ul><li>装箱与拆箱</li></ul><p><strong>装箱：</strong>将基本数据类型变为包装类对象。利用每个包装类提供的构造方法实现。</p><p><strong>拆箱：</strong>将包装类中包装的基本数据类型取出。利用<code>xxValue()</code></p><p>Integer num的值在-128~127范围内赋值，Integer对象在常量池产生，会复用已有对象，这个区间外的所有数据都在堆上产生，不会复用已有对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">10</span>;</span><br><span class="line">Integer i2 = <span class="number">10</span>;</span><br><span class="line">i1 == i2 <span class="comment">//true</span></span><br><span class="line">Integer i3 = <span class="number">200</span>;</span><br><span class="line">Integer i4 = <span class="number">200</span>;</span><br><span class="line">i3 == i4 <span class="comment">//false</span></span><br></pre></td></tr></table></figure><ul><li>阿里编码规范</li></ul><p>a.强制要求所有POJO类（简单Java类，类中只有成员变量、构造方法、getter/setter方法）属性必须使用包装类</p><p>b.强制RPC方法返回值和参数必须使用包装类</p><p>c.推荐所有的局部变量使用基本类型</p><ul><li>包装类与字符串的转换</li></ul><p><strong>String变为基本数据类型</strong></p><p>包装类.<code>parsexxx</code>(str)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.parseInt(str);</span><br></pre></td></tr></table></figure><p>将字符串转换为布尔类型时：true—&gt;true</p><p>不是true—&gt;false</p><p><strong>基本数据类型-&gt;String</strong></p><p>a.””+基本数据类型</p><p>b.String类提供的静态方法valueOf（基本类型），不产生垃圾空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = String.valueOf(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Object类是JDK默认提供的一个类。Java中除了Object类，所有的类都存在继承关系，默认会继承Object父类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;toString()-取得对象信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;系统输出默认调用对象的toString方法&lt;/p&gt;
&lt;p&gt;Object类中的toString方法只是简单输出当前引用的类名称以及对象地址&lt;/p&gt;
&lt;p&gt;如果想在类中取得本类属性信息，需要覆写toString();&lt;/p&gt;
&lt;p&gt;String类对该方法进行覆写，若String类调用该方法会返回String类的内容&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的模块与包</title>
    <link href="http://www.bingoxin.top/2018/10/29/Java%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"/>
    <id>http://www.bingoxin.top/2018/10/29/Java中的模块与包/</id>
    <published>2018-10-29T12:21:15.000Z</published>
    <updated>2018-12-30T12:21:45.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="包的定义与使用"><a href="#包的定义与使用" class="headerlink" title="包的定义与使用"></a>包的定义与使用</h3><p>包就是文件夹</p><p>在源文件首行<code>package 包名称</code></p><ul><li>打包编译命令</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d . Test.java</span><br></pre></td></tr></table></figure><p>-d ：根据package定义的包名称创建生成目录</p><p>.：在当前目录下生成</p><ul><li>执行命令</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java www.bit.java.Test</span><br></pre></td></tr></table></figure><ul><li>自动打包 编译命令（将当前路径下所有源文件按照主类的使用情况自动编译）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d . .<span class="comment">/*.java</span></span><br></pre></td></tr></table></figure><h3 id="关键字default"><a href="#关键字default" class="headerlink" title="关键字default"></a>关键字default</h3><ul><li>包访问权限</li></ul><p>定义：本包下的所有源文件可以互相调用属性与方法</p><ul><li>常用包</li></ul><p><strong>java.lang:</strong>系统常用基础类（Object、String(sb)、包装类）</p><p>此包在JDK1.1之后自动导入</p><p><strong>java.util:</strong>java提供的工具程序包，类集（ArrayList、HashMap）</p><p><strong>java.util.concurrent</strong></p><p>在JDK1.8中，接口中的方法用default修饰，方法可以有方法体</p><h3 id="继承访问权限—protected"><a href="#继承访问权限—protected" class="headerlink" title="继承访问权限—protected"></a>继承访问权限—protected</h3><h3 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h3><p><strong>Error：</strong>描述Java运行时内部错误与资源耗尽错误。这种内部错误一旦出现，除了告知用户并使程序安全终止之外，再无能为力</p><p><strong>Exception：</strong>（程序出错）</p><p><strong>TOException：</strong>程序本身没有问题，由于IO处理导致的程序错误</p><p><strong>RuntimeException：</strong>由于程序错误导致的</p><p><strong>非受查异常：</strong>所有继承与Error或RuntimeException的异常类称为非受查异常（不需要强制处理）</p><p><strong>受查异常：</strong>所有继承于Exception与IOException的类成为受查异常类（需要强制处理）</p><ul><li>异常处理格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    code</span><br><span class="line">&#125;[<span class="keyword">catch</span>(异常类 对象)]&#123;</span><br><span class="line">    出异常的操作</span><br><span class="line">&#125;[<span class="keyword">finally</span>]&#123;</span><br><span class="line">    异常出口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>常用异常格式</li></ul><p>try…catch…</p><p>try…finally…</p><p>try…catch…finally…</p><p>无论是否产生异常，无论try、catch是否返回语句，最终都会执行finally块</p><p><strong>打印错误堆栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.printStackTrace();</span><br></pre></td></tr></table></figure><ul><li>throws关键字</li></ul><p>在进行方法定义时，如果要明确告诉调用者本方法可能产生哪些异常，可以使用throws方法进行声明，表示将异常抛回给调用方。并且当方法出现问题后可以不进行处理</p><ul><li>throw关键字—用在方法中</li></ul><p>throw语句直接用在方法中，表示人为进行异常的抛出，一般与自定义的异常类搭配使用</p><p>如果异常类对象不希望由JVM产生而通过用户产生，就可以使用throw语句来完成</p><p>例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 1).定义一个MulException类继承Exception类，要求两数相乘等于100报错，在主类中定义一个方法，在方法中抛出此异常，在主方法观察结果。</span></span><br><span class="line"><span class="comment"> * 2).定义一个DivException类继承RuntimeException类，要求两数相除等于2报错，在主类中定义一个方法，在方法中抛出此异常，在主方法观察结果。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MulException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MulException</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DivException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DivException</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                test();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            test1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Exception是受查异常，必须强制处理</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(i*j == <span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MulException(<span class="string">"两数相乘等于100"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">if</span>(x/y == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> DivException(<span class="string">"两数相除不能等于2"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>启动断言需要使用-ea参数手工开启，默认不开启断言，属于Error</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;包的定义与使用&quot;&gt;&lt;a href=&quot;#包的定义与使用&quot; class=&quot;headerlink&quot; title=&quot;包的定义与使用&quot;&gt;&lt;/a&gt;包的定义与使用&lt;/h3&gt;&lt;p&gt;包就是文件夹&lt;/p&gt;
&lt;p&gt;在源文件首行&lt;code&gt;package 包名称&lt;/code&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的三大设计模式</title>
    <link href="http://www.bingoxin.top/2018/10/28/Java%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.bingoxin.top/2018/10/28/Java中的三大设计模式/</id>
    <published>2018-10-28T12:19:22.000Z</published>
    <updated>2018-12-29T12:19:59.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>将客户端的new操作解耦到第三方（工厂类）</p><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><ul><li>特点</li></ul><blockquote><p>a.拥有具体的产品类</p><p>b.多个具体产品类</p><p>c.一个工厂—&gt;new操作在此工厂中进行，客户端通过工厂类获取具体实例</p></blockquote><a id="more"></a><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><ul><li>概念</li></ul><p>定义一个用来创建对象的接口，让子类决定实例化哪一个类</p><p>针对每个产品（产品族）提供一个共产类，客户端需要判断使用哪个工厂</p><ul><li>特点</li></ul><p>横向扩展方便</p><blockquote><p>a.一个抽象产品类</p><p>b.多个具体产品类</p><p>c.一个针对产品类的抽象工厂</p><p>d.多个具体工厂（每个产品家族拥有自己的工厂）</p></blockquote><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ul><li>特点</li></ul><p>两个子类共同实现同一个接口，其中一个子类负责真实业务实现，另一个子类完成辅助真实业务主题的操作</p><h3 id="开发时注意："><a href="#开发时注意：" class="headerlink" title="开发时注意："></a>开发时注意：</h3><p>1.接口是Java的核心，慢慢会学到接口更多的使用与设计</p><p>2.开发之中优先考虑接口，以避免单继承局限</p><p>3.抽象类是模板，有层次感；接口更关心行为与混合</p><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><ul><li>特点</li></ul><p>一个类只允许产生一个实例化对象</p><blockquote><p>构造方法私有化</p><p>在类内部实现对象的实例化</p><p>使用getter方法创建对象</p></blockquote><p><strong>饿汉式单例：</strong>先new为敬</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleEx</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleEx singleEx = <span class="keyword">new</span> SingleEx();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleEx</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleEx <span class="title">getSingleEx</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getSingle"</span>);</span><br><span class="line">        <span class="keyword">return</span> singleEx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingleEx singleEx =SingleEx.getSingleEx();</span><br><span class="line">        System.out.println(singleEx);</span><br><span class="line">        SingleEx singleEx1 =SingleEx.getSingleEx();</span><br><span class="line">        System.out.println(singleEx1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>懒汉式单例：</strong>用时再new</p><p>只是实例化时机与饿汉式不同，懒汉式单例存在线程安全问题（双重加锁单例模式）</p><h3 id="多例模式"><a href="#多例模式" class="headerlink" title="多例模式"></a>多例模式</h3><p>多例模式只是比单例模式多了一些内部实例化对象而已</p><p>无论是单例还是多例：</p><p>a.构造方法私有化</p><p>b.类内部提供静态方法返回有限个数对象</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h3&gt;&lt;p&gt;将客户端的new操作解耦到第三方（工厂类）&lt;/p&gt;
&lt;h4 id=&quot;简单工厂&quot;&gt;&lt;a href=&quot;#简单工厂&quot; class=&quot;headerlink&quot; title=&quot;简单工厂&quot;&gt;&lt;/a&gt;简单工厂&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;特点&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;a.拥有具体的产品类&lt;/p&gt;
&lt;p&gt;b.多个具体产品类&lt;/p&gt;
&lt;p&gt;c.一个工厂—&amp;gt;new操作在此工厂中进行，客户端通过工厂类获取具体实例&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
</feed>
