<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bingoxin&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.bingoxin.top/"/>
  <updated>2018-12-21T13:33:48.786Z</updated>
  <id>http://www.bingoxin.top/</id>
  
  <author>
    <name>bingoxin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://www.bingoxin.top/2018/12/21/Java%E7%B1%BB%E9%9B%86/"/>
    <id>http://www.bingoxin.top/2018/12/21/Java类集/</id>
    <published>2018-12-21T13:33:48.619Z</published>
    <updated>2018-12-21T13:33:48.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java类集"><a href="#Java类集" class="headerlink" title="Java类集"></a>Java类集</h1><p>Java类集就是动态数组，类集的使用比较容易操作，但是类集的底层需要用到数据结构和多线程</p><p>所有的类集都在java.util包下</p><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><ul><li><p>ArrayList与Vector区别</p></li><li><p>ArrayList线程不安全的List集合，是否了解JUC包下的线程安全List（<code></code>）</p></li></ul><h3 id="Java类集的产生"><a href="#Java类集的产生" class="headerlink" title="Java类集的产生"></a>Java类集的产生</h3><p>Java类集是从JDK1.2开始应用的，用于解决数组定长问题</p><ul><li>Collection接口—<strong>单个对象</strong>保存的最顶层父接口</li></ul><p>Collection接口以及其子接口，在每次进行数据操作时只能对单个对象进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Iterable&lt;E&gt;</code>:迭代器接口（用于遍历集合）</p><p><code>Interface&lt;E&gt; iterator()</code>：取得集合的迭代器，JDK1.5之前没有泛型，则迭代器直接写在Collection接口中</p><ul><li>Collection接口中提供的核心方法</li></ul><p><strong>向类集中添加元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>取得接口的迭代器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Collection 接口只定义了存储数据的标准，但是无法区分存储类型。因此在实际中我们往往是由两个子接口List（允许数据重复）、Set（不允许数据重复）一般不直接使用Collection接口</p><h2 id="List接口—允许数据重复"><a href="#List接口—允许数据重复" class="headerlink" title="List接口—允许数据重复"></a>List接口—允许数据重复</h2><p>在进行单个集合处理时，优先考虑List接口</p><p>在List接口中，拓展了两个重要方法（List独有）</p><ul><li>根据索引取得下标数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>根据索引下标更改数据，返回原来的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br></pre></td></tr></table></figure><p>List接口有三个重要子类：ArrayList、Vector、LinkedList</p><p>List接口要想保存自定义类的对象，该类必须覆写<code>equals()</code>来使用<code>contains()</code>、<code>remove()</code></p><h3 id="ArrayList-Vector-LinkedList的区别"><a href="#ArrayList-Vector-LinkedList的区别" class="headerlink" title="ArrayList/Vector/LinkedList的区别"></a>ArrayList/Vector/LinkedList的区别</h3><ul><li>ArrayList与Vector的区别</li></ul><p>1、<strong>出现版本：</strong>ArrayList 在JDK1.2版本才出现，Vector在JDK1.0版本就已经出现</p><p>2、<strong>调用无参构造的区别：</strong>Vector在无参构造执行后将对象数组大小初始化为10，ArrayList采用懒加载策略，在构造方法阶段并不初始化数组，在第一次添加元素时才会初始化数组，大小为10</p><p>3、<strong>扩容策略：</strong>ArrayList在扩容时，会扩容到原来长度的1.5倍；Vector在扩容时，会扩容到原来的两倍</p><p>4、<strong>线程的安全性：</strong>ArrayList采用异步处理，线程不安全，效率较高；Vector采用在方法上加锁，线程安全，效率更低。（即便要使用线程安全的List也不使用Vector）</p><p>5、<strong>遍历：</strong>Vector支持较老的迭代器；ArrayList不支持</p><ul><li>ArrayList与Vector的共同点</li></ul><p>底层都使用数组实现，且都是List的子类</p><ul><li>ArrayList与LinkedList的区别</li></ul><p>LinkedList底层是双向链表，ArrayList的底层是数组</p><h2 id="Set接口—不允许数据重复"><a href="#Set接口—不允许数据重复" class="headerlink" title="Set接口—不允许数据重复"></a>Set接口—不允许数据重复</h2><p>Set接口没有扩充方法，常用子类有<code>HashSet</code>(无序存储)和<code>TreeSet</code>(有序存储)</p><h3 id="Comparable接口与Compartor接口"><a href="#Comparable接口与Compartor接口" class="headerlink" title="Comparable接口与Compartor接口"></a>Comparable接口与Compartor接口</h3><p>在Java中，若实现自定义类的比较，提供了一下两个接口：</p><p>java.lang.Comparable接口（内部比较器）:若一个类实现了Comparable接口，就表示该类可以进行比较并排序的。存放该类的Conllection或数组，可以直接通过<code>Collection.sort()</code>或Array.sort进行排序</p><p>实现了Comparable接口的类可以直接存放在TreeSet或TreeMap中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>返回值三种情况：</p><p>返回正数：当前对象大于目标对象</p><p>返回负数：当前对象小于目标对象</p><p>返回0：当前对象等于目标对象</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>底层是由哈希表和红黑树，允许存放null，无序储存</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>底层使用红黑树，不允许空值出现，允许储存</p><p>保存自定义类需实现Comparable接口或者传入比较器（compartor接口）</p><h3 id="HashSet和TreeSet的区别"><a href="#HashSet和TreeSet的区别" class="headerlink" title="HashSet和TreeSet的区别"></a>HashSet和TreeSet的区别</h3><p>1、<strong>底层实现不同：</strong>HashSet底层是由哈希表和红黑树，允许存放null，无序储存；TreeSet底层使用红黑树，不允许空值出现，允许储存</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java类集&quot;&gt;&lt;a href=&quot;#Java类集&quot; class=&quot;headerlink&quot; title=&quot;Java类集&quot;&gt;&lt;/a&gt;Java类集&lt;/h1&gt;&lt;p&gt;Java类集就是动态数组，类集的使用比较容易操作，但是类集的底层需要用到数据结构和多线程&lt;/p&gt;
&lt;p&gt;所有
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.bingoxin.top/2018/12/08/hello-world/"/>
    <id>http://www.bingoxin.top/2018/12/08/hello-world/</id>
    <published>2018-12-08T07:49:47.515Z</published>
    <updated>2018-12-08T17:04:28.016Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a><a id="more"></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>函数栈桢</title>
    <link href="http://www.bingoxin.top/2017/12/13/%E5%87%BD%E6%95%B0%E6%A0%88%E6%A1%A2/"/>
    <id>http://www.bingoxin.top/2017/12/13/函数栈桢/</id>
    <published>2017-12-13T14:36:59.000Z</published>
    <updated>2018-12-21T14:39:19.051Z</updated>
    
    <content type="html"><![CDATA[<p>在做面试题的时候，我遇到了这样一道题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">int tmp=10;</span><br><span class="line">int* p=(int*)(*(&amp;tmp+1));</span><br><span class="line">*(p-1)=20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a=0;</span><br><span class="line">fun();</span><br><span class="line">printf(&quot;%d&quot;,a);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一眼看去，a的值好像并未发生改变。但是实际上并不是我们看到的这么简单哦~<a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在解这道题时，我们需要搞懂函数调用是怎么实现的？？？</p><p>接下来我就来一步一步讲解</p><h3 id="函数栈桢地址使用"><a href="#函数栈桢地址使用" class="headerlink" title="函数栈桢地址使用"></a>函数栈桢地址使用</h3><p>函数栈桢的使用是由高地址向低地址使用的</p><h3 id="函数压栈"><a href="#函数压栈" class="headerlink" title="函数压栈"></a>函数压栈</h3><p>函数压栈：在栈顶处不断放入数据</p><h3 id="函数调用时使用的寄存器"><a href="#函数调用时使用的寄存器" class="headerlink" title="函数调用时使用的寄存器"></a>函数调用时使用的寄存器</h3><ul><li>esp：函数栈顶的地址，随着压栈的进行，esp会向低地址处移动</li><li>ebp：函数栈底的地址</li></ul><h3 id="在调用main函数之前，还调用了一个函数叫做mainCRTStart"><a href="#在调用main函数之前，还调用了一个函数叫做mainCRTStart" class="headerlink" title="在调用main函数之前，还调用了一个函数叫做mainCRTStart()"></a>在调用main函数之前，还调用了一个函数叫做mainCRTStart()</h3><p>mainCRTStart是用来调用main函数的一个函数</p><p>接下来，我将以下面的代码为例，来讲解函数调用过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int Add(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">int z = 0;</span><br><span class="line">z = x + y;</span><br><span class="line">return z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">int ret = 0;</span><br><span class="line">ret = Add(a,b);</span><br><span class="line">printf(&quot;%d&quot;,ret);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h2 id="调用mainCRTStart"><a href="#调用mainCRTStart" class="headerlink" title="调用mainCRTStart()"></a>调用mainCRTStart()</h2><p>以调用mainCRTStart()来调用main函数，此时ebp在栈底，esp在栈顶。</p><h2 id="用汇编代码来看"><a href="#用汇编代码来看" class="headerlink" title="用汇编代码来看"></a>用汇编代码来看</h2><div align="center"><br>    <img src="\images\posts\函数栈桢\捕获5.PNG" height="500" width="500"><br></div><p>注意：函数栈桢图中的序号与步骤号对应，汇编代码前的红色数字与步骤号也是对应的，一个步骤可能执行多条语句</p><p><strong>第一步</strong></p><p>将ebp的值压在栈顶上(红色方框)，esp由esp1移到esp2的位置</p><p><strong>第二步</strong></p><p>将esp的值赋给ebp，即ebp由ebp1的位置移到ebp2的位置</p><p><strong>第三步</strong></p><p>esp-4Ch:esp由esp2的位置移到esp3的位置，此时为esp与ebp维护的空间是为main函数开辟了空间</p><p><strong>第四步</strong></p><p>将ebx、esi、edi依次压入栈中，esp随着每次压栈向低地址处移动，则esp由esp3的位置移到esp4的位置</p><p><strong>第五步</strong></p><blockquote><p>将edi放到ebp-4Ch的位置上，即将edi移动到edi1的位置，</p></blockquote><blockquote><p>将eax的内容拷贝ecx存放内容次，放到edi向下的内容中去。将为main函数开辟的空间全部初始化成随机值</p></blockquote><p><strong>第六步</strong></p><p>为ebp-4地址处赋值，为10(a)</p><p><strong>第七步</strong></p><p>为ebp-8地址处赋值，为20(b)</p><p><strong>第八步</strong></p><p>为ebp-12地址处赋值，为0(ret)</p><p><strong>第九步</strong></p><blockquote><p>将ebp-8地址处的值赋给寄存器eax，并将eax压入栈中(_b)</p></blockquote><blockquote><p>将ebp-4地址处的值赋给寄存器ecx，并将ecx压入栈中(_a)</p></blockquote><blockquote><p>将call指令下一条指令的地址压入栈中</p></blockquote><blockquote><p>该过程进行完，esp由esp4的位置移动到esp5的位置</p></blockquote><p><strong>第十步</strong></p><p>进入Add函数中，将main函数的ebp位置压入栈中，esp由esp5位置移到esp5的位置</p><p><strong>第十一步</strong></p><p>将ebp移动到esp的位置，即将ebp由ebp2的位置移到ebp3的位置</p><p><strong>第十二步</strong></p><p>esp-44h：为Add函数开辟空间</p><p><strong>第十三步</strong></p><p>依次将ebx、esi、edi压入栈中，则esp由esp7的位置移到esp8的位置</p><p><strong>第十四步</strong></p><p>将edi移动到edi1的位置(橙色)，并将Add函数开辟的空间初始化为随机值</p><p><strong>第十五步</strong></p><p>将ebp3-4的位置初始化成0（z）</p><p><strong>第十六步</strong></p><blockquote><p>将ebp+8的位置的值(a)放入eax寄存器中</p></blockquote><blockquote><p>将eax(x)中的值加ebp+0Ch(y)，将结果放在eax寄存器中</p></blockquote><blockquote><p>将eax中的值，赋给ebp-4(z)</p></blockquote><p><strong>第十七步</strong></p><p>将ebp-4(z)中的值放入eax寄存器中</p><p><strong>第十八步</strong></p><p>将edi、esi、ebx弹出栈，将esp由eap8的位置移动到esp7的位置</p><p><strong>第十九步</strong></p><p>将esp放在ebp的位置，即esp由esp7的位置移动到esp9的位置</p><p><strong>第二十步</strong></p><p>将ebp弹出，ebp移动至main函数的栈底位置，即esp2的位置</p><p><strong>第二十一步</strong></p><p>将寄存器eax中存放的值，赋给ebp-0Ch(ret)</p><h3 id="面试题解答"><a href="#面试题解答" class="headerlink" title="面试题解答"></a>面试题解答</h3><p>其实a的值是在调用函数fun时，通过指针赋值发生的改变</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做面试题的时候，我遇到了这样一道题：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void fun()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int tmp=10;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int* p=(int*)(*(&amp;amp;tmp+1));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	*(p-1)=20;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int a=0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fun();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	printf(&amp;quot;%d&amp;quot;,a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一眼看去，a的值好像并未发生改变。但是实际上并不是我们看到的这么简单哦~
    
    </summary>
    
    
      <category term="C语言" scheme="http://www.bingoxin.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言-操作符</title>
    <link href="http://www.bingoxin.top/2017/11/12/C%E8%AF%AD%E8%A8%80-%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://www.bingoxin.top/2017/11/12/C语言-操作符/</id>
    <published>2017-11-12T10:08:58.000Z</published>
    <updated>2018-12-09T10:13:52.314Z</updated>
    
    <content type="html"><![CDATA[<p>对于刚接触C语言的人来说，一提到操作符，可能也只有==、+、-、*等等。今天就来了解一下操作符的知识。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>操作符包括算术操作符、移位操作符、位操作符、赋值、单目操作符。关系操作符、逻辑操作符、条件操作符。逗号操作符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">算术操作符有：加（+）、减（-）、乘（*）、除（/）、取模（%）。</span><br></pre></td></tr></table></figure><p>在这些操作符中，需要注意的是除（/）和取模（%）的使用：</p><a id="more"></a><p>1、 浮点数相除是浮点数，整数相除是整数，浮点数除以整数为浮点数。</p><p>2、 取模（%）两边都应为整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">移位操作符有：左移（&lt;&lt;）和右移（&gt;&gt;）。</span><br></pre></td></tr></table></figure><p>在说这些之前，我们应该了解什么是源码、反码和补码。</p><p>电脑一般都是32位的，则在编程软件中，数字的二进制也是32位。正数在电脑中以源码保存，负数在电脑中以补码保存。正数的源码最高位是0，负数的源码最高位是1。正数的源码、反码、补码都相同。负数的反码是在符号位不变的基础上，其他位取反。其补码为反码+1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例如：1源码为0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">      1反码为0000 00000000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">      1补码为0000 00000000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">     -1源码为1000 00000000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">     -1反码为1111 11111111 1111 1111 1111 1111 1110</span><br><span class="line"></span><br><span class="line">     -1补码是1111 11111111 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure><p>接下来再说左移（&lt;&lt;），末位补0，最高位溢出。</p><p>例如：a=1,a&lt;&lt;2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a：00000000 0000 0000 0000 0000 0000 000100</span><br><span class="line"></span><br><span class="line">  溢出                                    补0</span><br><span class="line"></span><br><span class="line">则a&lt;&lt;2：0000 0000 0000 0000 0000 0000 0000 0100</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  int a = 1;</span><br><span class="line"></span><br><span class="line">  printf(&quot;a=%d\n&quot;,a);</span><br><span class="line"></span><br><span class="line">  a = a &lt;&lt; 2;</span><br><span class="line"></span><br><span class="line">  printf(&quot;a&lt;&lt;2=%d\n&quot;,a);</span><br><span class="line"></span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右移（&gt;&gt;）分为逻辑右移和算术右移。逻辑右移是左边补0，右边舍弃。算术右移是最高位补符号位，右边舍弃。经常使用的是算术右移。</p><p>例如：a=1，a&gt;&gt;2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a: 000000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">补符号位                                   舍弃</span><br><span class="line"></span><br><span class="line">a&lt;&lt;2: 0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  int a = 1;</span><br><span class="line"></span><br><span class="line">  printf(&quot;a=%d\n&quot;,a);</span><br><span class="line"></span><br><span class="line">  a = a &gt;&gt; 2;</span><br><span class="line"></span><br><span class="line">  printf(&quot;a&gt;&gt;2=%d\n&quot;,a);</span><br><span class="line"></span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">位操作符有三种，分别是：与（&amp;）、或（|），异或（^）的原则进行计算。</span><br></pre></td></tr></table></figure><p>与（&amp;）就是两个数的补码，每位进行比较，按照有0则为0，同为1则是1的原则进行计算。</p><p>异或（^）就是两个数的补码，每位进行比较，按照相同为0，不同为1的原则进行计算。</p><p>先看下面这段例程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int a = 3;</span><br><span class="line"></span><br><span class="line">    int b = 5;</span><br><span class="line"></span><br><span class="line">    printf(&quot;a&amp;b=%d\n&quot;,a&amp;b);</span><br><span class="line"></span><br><span class="line">    printf(&quot;a|b=%d\n&quot;,a|b);</span><br><span class="line"></span><br><span class="line">    printf(&quot;a^b=%d\n&quot;,a^b);</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a的补码是:0000 0000 0000 00000000 0000 0000 0011</p><p>b的补码是:0000 0000 0000 0000 0000 0000 0000 0101</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">则    a&amp;b=0000 0000 0000 0000 0000 0000 00000001=1</span><br><span class="line"></span><br><span class="line">      a|b=0000 0000 0000 0000 0000 0000 0000 0111=7</span><br><span class="line"></span><br><span class="line">      a^b=0000 0000 0000 0000 0000 0000 0000 0110=6</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">赋值中包括就是我们常见的=，还包括复合赋值操作符有+=、-=、*=、/=、%=、&lt;&lt;=、&gt;&gt;=、&amp;=、^=、|=。</span><br></pre></td></tr></table></figure><p>a+=2表示a=a+2，即操作符两边的数先进行计算再将计算结果赋值到操作数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关系操作符有!=、&lt;=、&gt;=、==、&lt;、&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单目操作符有！、-、+、&amp;、sizeof、~、++、--、*。</span><br></pre></td></tr></table></figure><p>！表示非，例如！（2=2），2=2为真，则！（2=2）为假。</p><p>-表示操作数的负值，-1也就是我们所说的负数。</p><p>+表示操作数的正值，一般被省略。</p><p>&amp;表示操作数的地址，例如：</p><p>int a = 10;</p><p>int* b = &a;</p><p>sizeof用于计算该操作数或表达式的字节数，初学者会认为这是一个函数，这是一个误区。</p><p>~用于整型求补操作，即将该操作数的二进制进行转换，1变为0,0变为1。</p><p>++用于操作数的自加，每次加1，++a表示先自加在使用该操作数，a++表示先使用该操作数再进行自加。</p><p><em>表示间接访问操作符，在指针中使用。</em>a表示访问a指向的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑操作符有&amp;&amp;（和）和||（或）</span><br></pre></td></tr></table></figure><p>在这里需要注意的是要和位操作符进行区分：</p><p>和即所有条件为真且为真，一个条件为假就是假</p><p>或即一个为真即为真，全部为假才是假。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件操作符包括三个部分：a？b : c</span><br></pre></td></tr></table></figure><p>a为一个判断条件，若a为真则执行b语句，若a为假则执行c语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逗号操作符使用很频繁，逗号操作符把多个表达式分隔开，表达式从左往右依次计算。</span><br></pre></td></tr></table></figure><h2 id="寄语"><a href="#寄语" class="headerlink" title="寄语"></a>寄语</h2><p>　　可能关于操作符的叙述不是很详细，欢迎交流！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于刚接触C语言的人来说，一提到操作符，可能也只有==、+、-、*等等。今天就来了解一下操作符的知识。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;p&gt;操作符包括算术操作符、移位操作符、位操作符、赋值、单目操作符。关系操作符、逻辑操作符、条件操作符。逗号操作符。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;算术操作符有：加（+）、减（-）、乘（*）、除（/）、取模（%）。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这些操作符中，需要注意的是除（/）和取模（%）的使用：&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.bingoxin.top/tags/C-C/"/>
    
  </entry>
  
</feed>
