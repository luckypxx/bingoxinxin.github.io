<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java中的类集</title>
      <link href="/2018/12/21/Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E9%9B%86/"/>
      <url>/2018/12/21/Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Java类集"><a href="#Java类集" class="headerlink" title="Java类集"></a>Java类集</h1><p>Java类集就是动态数组，类集的使用比较容易操作，但是类集的底层需要用到数据结构和多线程</p><p>所有的类集都在java.util包下<a id="more"></a></p><h3 id="Java类集的产生"><a href="#Java类集的产生" class="headerlink" title="Java类集的产生"></a>Java类集的产生</h3><p>Java类集是从JDK1.2开始应用的，用于解决数组定长问题</p><ul><li>Collection接口—<strong>单个对象</strong>保存的最顶层父接口</li></ul><p>Collection接口以及其子接口，在每次进行数据操作时只能对单个对象进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Iterable&lt;E&gt;</code>:迭代器接口（用于遍历集合）</p><p><code>Interface&lt;E&gt; iterator()</code>：取得集合的迭代器，JDK1.5之前没有泛型，则迭代器直接写在Collection接口中</p><ul><li>Collection接口中提供的核心方法</li></ul><p><strong>向类集中添加元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>取得接口的迭代器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Collection 接口只定义了存储数据的标准，但是无法区分存储类型。因此在实际中我们往往是由两个子接口List（允许数据重复）、Set（不允许数据重复）一般不直接使用Collection接口</p><h2 id="List接口—允许数据重复"><a href="#List接口—允许数据重复" class="headerlink" title="List接口—允许数据重复"></a>List接口—允许数据重复</h2><p>在进行单个集合处理时，优先考虑List接口</p><p>在List接口中，拓展了两个重要方法（List独有）</p><ul><li>根据索引取得下标数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>根据索引下标更改数据，返回原来的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br></pre></td></tr></table></figure><p>List接口有三个重要子类：ArrayList、Vector、LinkedList</p><p>List接口要想保存自定义类的对象，该类必须覆写<code>equals()</code>来使用<code>contains()</code>、<code>remove()</code></p><h3 id="ArrayList-Vector-LinkedList的区别"><a href="#ArrayList-Vector-LinkedList的区别" class="headerlink" title="ArrayList/Vector/LinkedList的区别"></a>ArrayList/Vector/LinkedList的区别</h3><ul><li>ArrayList与Vector的区别</li></ul><p>1、<strong>出现版本：</strong>ArrayList 在JDK1.2版本才出现，Vector在JDK1.0版本就已经出现</p><p>2、<strong>调用无参构造的区别：</strong>Vector在无参构造执行后将对象数组大小初始化为10，ArrayList采用懒加载策略，在构造方法阶段并不初始化数组，在第一次添加元素时才会初始化数组，大小为10</p><p>3、<strong>扩容策略：</strong>ArrayList在扩容时，会扩容到原来长度的1.5倍；Vector在扩容时，会扩容到原来的两倍</p><p>4、<strong>线程的安全性：</strong>ArrayList采用异步处理，线程不安全，效率较高；Vector采用在方法上加锁，线程安全，效率更低。（即便要使用线程安全的List也不使用Vector）</p><p>5、<strong>遍历：</strong>Vector支持较老的迭代器；ArrayList不支持</p><ul><li>ArrayList与Vector的共同点</li></ul><p>底层都使用数组实现，且都是List的子类</p><ul><li>ArrayList与LinkedList的区别</li></ul><p>LinkedList底层是双向链表，ArrayList的底层是数组</p><h2 id="Set接口—不允许数据重复"><a href="#Set接口—不允许数据重复" class="headerlink" title="Set接口—不允许数据重复"></a>Set接口—不允许数据重复</h2><p>Set接口没有扩充方法，常用子类有<code>HashSet</code>(无序存储)和<code>TreeSet</code>(有序存储)</p><h3 id="Comparable接口与Compartor接口"><a href="#Comparable接口与Compartor接口" class="headerlink" title="Comparable接口与Compartor接口"></a>Comparable接口与Compartor接口</h3><p>在Java中，若实现自定义类的比较，提供了一下两个接口：</p><p>java.lang.Comparable接口（内部比较器）:若一个类实现了Comparable接口，就表示该类可以进行比较并排序的。存放该类的Conllection或数组，可以直接通过<code>Collection.sort()</code>或Array.sort进行排序</p><p>实现了Comparable接口的类可以直接存放在TreeSet或TreeMap中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>返回值三种情况：</p><p>返回正数：当前对象大于目标对象</p><p>返回负数：当前对象小于目标对象</p><p>返回0：当前对象等于目标对象</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>底层是由哈希表和红黑树，允许存放null，无序储存</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>底层使用红黑树，不允许空值出现，允许储存</p><p>保存自定义类需实现Comparable接口或者传入比较器（compartor接口）</p><h3 id="HashSet和TreeSet的区别"><a href="#HashSet和TreeSet的区别" class="headerlink" title="HashSet和TreeSet的区别"></a>HashSet和TreeSet的区别</h3><p>1、<strong>底层实现不同：</strong>HashSet底层是由哈希表和红黑树，允许存放null，无序储存；TreeSet底层使用红黑树，不允许空值出现，允许储存</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自定义类型</title>
      <link href="/2018/03/05/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/03/05/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么存在内存对齐"><a href="#为什么存在内存对齐" class="headerlink" title="为什么存在内存对齐"></a>为什么存在内存对齐</h3><blockquote><p>1.<strong>平台原因：</strong>不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常</p></blockquote><blockquote><p>2.<strong>性能原因：</strong>数据结构(尤其是栈)应该尽可能地在自然边界上对齐<br>–&gt;若访问未对齐的内存，处理器需要做两次内存访问；而对齐的内存访问仅需要访问一次就可以拿到数据</p></blockquote><h3 id="结构体内存对齐规则"><a href="#结构体内存对齐规则" class="headerlink" title="结构体内存对齐规则"></a>结构体内存对齐规则</h3><p>Linux中，默认对齐数是4</p><p>Windows下的vs，默认对齐数是8</p><blockquote><p>1.第一个成员在与结构体变量偏移量为0的地址处</p><p>2.其他成员变量要对齐到某个数字(对齐数)的整数倍的地址处—&gt;对齐数=编译器默认的一个对齐数与该成员大小的较小值</p><p>3.结构体总大小为最大对齐数的整数倍</p><p>4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数的整数倍</p></blockquote><p>可以说，内存对齐是用时间来弥补空间</p><h3 id="结构体传参"><a href="#结构体传参" class="headerlink" title="结构体传参"></a>结构体传参</h3><p>结构体传参时，考虑变量可能过大，不要传结构体变量，要传结构体指针</p><h3 id="位段"><a href="#位段" class="headerlink" title="位段"></a>位段</h3><p>位段的声明和结构是类似的，有两个不同点：</p><blockquote><p>1.位段的成员必须是int、unsigned int 或 signed int</p><p>2.位段的成员后边有一个冒号和一个数字</p></blockquote><p>位段成员后面的数字表示bit位，位段可以节省空间</p><p><strong>开辟空间方式</strong></p><p>由于位段里变量为int类型，因此在开辟空间时，一次开辟4个字节的空间，即32个bit位。</p><p>需要注意的是：<strong>位段是不可以跨平台的、位段不存在对齐</strong></p><h3 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h3><p>枚举，即一一列举</p><p>枚举列举的是枚举常量，第一个常量为0，之后的常量大小依次+1</p><p><strong>枚举的优点</strong></p><ul><li>增加代码的可读性和可维护性</li><li>和#define定义的标识符比较，枚举有类型检查，更加严谨</li><li>防止命名污染</li><li>便于调试</li><li>使用方便，一次可以定义多个常量</li></ul><h3 id="联合-共用体"><a href="#联合-共用体" class="headerlink" title="联合(共用体)"></a>联合(共用体)</h3><p>在共用体中定义的变量共用一块内存</p><p><strong>空间计算</strong></p><ul><li>联合的大小至少是最大成员的大小</li><li>当最大成员不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍</li></ul><h3 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h3><p>小端：低字节放低地址处，高字节放高地址处</p><p>大端：低字节放高地址，高字节放低地址</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址是由点分十进制的方式处理的</p><p>IP地址实际是整型的十进制数字，将十进制数字的每个字节转化成转化成十进制，再用.连接，就是IP地址</p><p>代码实现：<br>​    #include &lt;stdio.h&gt;<br>​    #include &lt;Windows.h&gt;<br>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">union un</span><br><span class="line">&#123;</span><br><span class="line">unsigned int num;</span><br><span class="line">struct </span><br><span class="line">&#123;</span><br><span class="line">unsigned char a;</span><br><span class="line">unsigned char b;</span><br><span class="line">unsigned char c;</span><br><span class="line">unsigned char d;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">union un myip;</span><br><span class="line">myip.num = 716872929;</span><br><span class="line">printf(&quot;%d.%d.%d.%d&quot;, myip.d, myip.c, myip.b, myip.a);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎交流~~</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>函数栈桢</title>
      <link href="/2017/12/13/%E5%87%BD%E6%95%B0%E6%A0%88%E6%A1%A2/"/>
      <url>/2017/12/13/%E5%87%BD%E6%95%B0%E6%A0%88%E6%A1%A2/</url>
      
        <content type="html"><![CDATA[<p>在做面试题的时候，我遇到了这样一道题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">int tmp=10;</span><br><span class="line">int* p=(int*)(*(&amp;tmp+1));</span><br><span class="line">*(p-1)=20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a=0;</span><br><span class="line">fun();</span><br><span class="line">printf(&quot;%d&quot;,a);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一眼看去，a的值好像并未发生改变。但是实际上并不是我们看到的这么简单哦~<a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在解这道题时，我们需要搞懂函数调用是怎么实现的？？？</p><p>接下来我就来一步一步讲解</p><h3 id="函数栈桢地址使用"><a href="#函数栈桢地址使用" class="headerlink" title="函数栈桢地址使用"></a>函数栈桢地址使用</h3><p>函数栈桢的使用是由高地址向低地址使用的</p><h3 id="函数压栈"><a href="#函数压栈" class="headerlink" title="函数压栈"></a>函数压栈</h3><p>函数压栈：在栈顶处不断放入数据</p><h3 id="函数调用时使用的寄存器"><a href="#函数调用时使用的寄存器" class="headerlink" title="函数调用时使用的寄存器"></a>函数调用时使用的寄存器</h3><ul><li>esp：函数栈顶的地址，随着压栈的进行，esp会向低地址处移动</li><li>ebp：函数栈底的地址</li></ul><h3 id="在调用main函数之前，还调用了一个函数叫做mainCRTStart"><a href="#在调用main函数之前，还调用了一个函数叫做mainCRTStart" class="headerlink" title="在调用main函数之前，还调用了一个函数叫做mainCRTStart()"></a>在调用main函数之前，还调用了一个函数叫做mainCRTStart()</h3><p>mainCRTStart是用来调用main函数的一个函数</p><p>接下来，我将以下面的代码为例，来讲解函数调用过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int Add(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">int z = 0;</span><br><span class="line">z = x + y;</span><br><span class="line">return z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">int ret = 0;</span><br><span class="line">ret = Add(a,b);</span><br><span class="line">printf(&quot;%d&quot;,ret);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h2 id="调用mainCRTStart"><a href="#调用mainCRTStart" class="headerlink" title="调用mainCRTStart()"></a>调用mainCRTStart()</h2><p>以调用mainCRTStart()来调用main函数，此时ebp在栈底，esp在栈顶。</p><h2 id="用汇编代码来看"><a href="#用汇编代码来看" class="headerlink" title="用汇编代码来看"></a>用汇编代码来看</h2><div align="center"><br>    <img src="\images\posts\函数栈桢\捕获5.PNG" height="500" width="500"><br></div><p>注意：函数栈桢图中的序号与步骤号对应，汇编代码前的红色数字与步骤号也是对应的，一个步骤可能执行多条语句</p><p><strong>第一步</strong></p><p>将ebp的值压在栈顶上(红色方框)，esp由esp1移到esp2的位置</p><p><strong>第二步</strong></p><p>将esp的值赋给ebp，即ebp由ebp1的位置移到ebp2的位置</p><p><strong>第三步</strong></p><p>esp-4Ch:esp由esp2的位置移到esp3的位置，此时为esp与ebp维护的空间是为main函数开辟了空间</p><p><strong>第四步</strong></p><p>将ebx、esi、edi依次压入栈中，esp随着每次压栈向低地址处移动，则esp由esp3的位置移到esp4的位置</p><p><strong>第五步</strong></p><blockquote><p>将edi放到ebp-4Ch的位置上，即将edi移动到edi1的位置，</p></blockquote><blockquote><p>将eax的内容拷贝ecx存放内容次，放到edi向下的内容中去。将为main函数开辟的空间全部初始化成随机值</p></blockquote><p><strong>第六步</strong></p><p>为ebp-4地址处赋值，为10(a)</p><p><strong>第七步</strong></p><p>为ebp-8地址处赋值，为20(b)</p><p><strong>第八步</strong></p><p>为ebp-12地址处赋值，为0(ret)</p><p><strong>第九步</strong></p><blockquote><p>将ebp-8地址处的值赋给寄存器eax，并将eax压入栈中(_b)</p></blockquote><blockquote><p>将ebp-4地址处的值赋给寄存器ecx，并将ecx压入栈中(_a)</p></blockquote><blockquote><p>将call指令下一条指令的地址压入栈中</p></blockquote><blockquote><p>该过程进行完，esp由esp4的位置移动到esp5的位置</p></blockquote><p><strong>第十步</strong></p><p>进入Add函数中，将main函数的ebp位置压入栈中，esp由esp5位置移到esp5的位置</p><p><strong>第十一步</strong></p><p>将ebp移动到esp的位置，即将ebp由ebp2的位置移到ebp3的位置</p><p><strong>第十二步</strong></p><p>esp-44h：为Add函数开辟空间</p><p><strong>第十三步</strong></p><p>依次将ebx、esi、edi压入栈中，则esp由esp7的位置移到esp8的位置</p><p><strong>第十四步</strong></p><p>将edi移动到edi1的位置(橙色)，并将Add函数开辟的空间初始化为随机值</p><p><strong>第十五步</strong></p><p>将ebp3-4的位置初始化成0（z）</p><p><strong>第十六步</strong></p><blockquote><p>将ebp+8的位置的值(a)放入eax寄存器中</p></blockquote><blockquote><p>将eax(x)中的值加ebp+0Ch(y)，将结果放在eax寄存器中</p></blockquote><blockquote><p>将eax中的值，赋给ebp-4(z)</p></blockquote><p><strong>第十七步</strong></p><p>将ebp-4(z)中的值放入eax寄存器中</p><p><strong>第十八步</strong></p><p>将edi、esi、ebx弹出栈，将esp由eap8的位置移动到esp7的位置</p><p><strong>第十九步</strong></p><p>将esp放在ebp的位置，即esp由esp7的位置移动到esp9的位置</p><p><strong>第二十步</strong></p><p>将ebp弹出，ebp移动至main函数的栈底位置，即esp2的位置</p><p><strong>第二十一步</strong></p><p>将寄存器eax中存放的值，赋给ebp-0Ch(ret)</p><h3 id="面试题解答"><a href="#面试题解答" class="headerlink" title="面试题解答"></a>面试题解答</h3><p>其实a的值是在调用函数fun时，通过指针赋值发生的改变</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C语言-操作符</title>
      <link href="/2017/11/12/C%E8%AF%AD%E8%A8%80-%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2017/11/12/C%E8%AF%AD%E8%A8%80-%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>对于刚接触C语言的人来说，一提到操作符，可能也只有==、+、-、*等等。今天就来了解一下操作符的知识。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>操作符包括算术操作符、移位操作符、位操作符、赋值、单目操作符。关系操作符、逻辑操作符、条件操作符。逗号操作符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">算术操作符有：加（+）、减（-）、乘（*）、除（/）、取模（%）。</span><br></pre></td></tr></table></figure><p>在这些操作符中，需要注意的是除（/）和取模（%）的使用：</p><a id="more"></a><p>1、 浮点数相除是浮点数，整数相除是整数，浮点数除以整数为浮点数。</p><p>2、 取模（%）两边都应为整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">移位操作符有：左移（&lt;&lt;）和右移（&gt;&gt;）。</span><br></pre></td></tr></table></figure><p>在说这些之前，我们应该了解什么是源码、反码和补码。</p><p>电脑一般都是32位的，则在编程软件中，数字的二进制也是32位。正数在电脑中以源码保存，负数在电脑中以补码保存。正数的源码最高位是0，负数的源码最高位是1。正数的源码、反码、补码都相同。负数的反码是在符号位不变的基础上，其他位取反。其补码为反码+1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例如：1源码为0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">      1反码为0000 00000000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">      1补码为0000 00000000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">     -1源码为1000 00000000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">     -1反码为1111 11111111 1111 1111 1111 1111 1110</span><br><span class="line"></span><br><span class="line">     -1补码是1111 11111111 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure><p>接下来再说左移（&lt;&lt;），末位补0，最高位溢出。</p><p>例如：a=1,a&lt;&lt;2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a：00000000 0000 0000 0000 0000 0000 000100</span><br><span class="line"></span><br><span class="line">  溢出                                    补0</span><br><span class="line"></span><br><span class="line">则a&lt;&lt;2：0000 0000 0000 0000 0000 0000 0000 0100</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  int a = 1;</span><br><span class="line"></span><br><span class="line">  printf(&quot;a=%d\n&quot;,a);</span><br><span class="line"></span><br><span class="line">  a = a &lt;&lt; 2;</span><br><span class="line"></span><br><span class="line">  printf(&quot;a&lt;&lt;2=%d\n&quot;,a);</span><br><span class="line"></span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右移（&gt;&gt;）分为逻辑右移和算术右移。逻辑右移是左边补0，右边舍弃。算术右移是最高位补符号位，右边舍弃。经常使用的是算术右移。</p><p>例如：a=1，a&gt;&gt;2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a: 000000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">补符号位                                   舍弃</span><br><span class="line"></span><br><span class="line">a&lt;&lt;2: 0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  int a = 1;</span><br><span class="line"></span><br><span class="line">  printf(&quot;a=%d\n&quot;,a);</span><br><span class="line"></span><br><span class="line">  a = a &gt;&gt; 2;</span><br><span class="line"></span><br><span class="line">  printf(&quot;a&gt;&gt;2=%d\n&quot;,a);</span><br><span class="line"></span><br><span class="line">  system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">位操作符有三种，分别是：与（&amp;）、或（|），异或（^）的原则进行计算。</span><br></pre></td></tr></table></figure><p>与（&amp;）就是两个数的补码，每位进行比较，按照有0则为0，同为1则是1的原则进行计算。</p><p>异或（^）就是两个数的补码，每位进行比较，按照相同为0，不同为1的原则进行计算。</p><p>先看下面这段例程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int a = 3;</span><br><span class="line"></span><br><span class="line">    int b = 5;</span><br><span class="line"></span><br><span class="line">    printf(&quot;a&amp;b=%d\n&quot;,a&amp;b);</span><br><span class="line"></span><br><span class="line">    printf(&quot;a|b=%d\n&quot;,a|b);</span><br><span class="line"></span><br><span class="line">    printf(&quot;a^b=%d\n&quot;,a^b);</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a的补码是:0000 0000 0000 00000000 0000 0000 0011</p><p>b的补码是:0000 0000 0000 0000 0000 0000 0000 0101</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">则    a&amp;b=0000 0000 0000 0000 0000 0000 00000001=1</span><br><span class="line"></span><br><span class="line">      a|b=0000 0000 0000 0000 0000 0000 0000 0111=7</span><br><span class="line"></span><br><span class="line">      a^b=0000 0000 0000 0000 0000 0000 0000 0110=6</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">赋值中包括就是我们常见的=，还包括复合赋值操作符有+=、-=、*=、/=、%=、&lt;&lt;=、&gt;&gt;=、&amp;=、^=、|=。</span><br></pre></td></tr></table></figure><p>a+=2表示a=a+2，即操作符两边的数先进行计算再将计算结果赋值到操作数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关系操作符有!=、&lt;=、&gt;=、==、&lt;、&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单目操作符有！、-、+、&amp;、sizeof、~、++、--、*。</span><br></pre></td></tr></table></figure><p>！表示非，例如！（2=2），2=2为真，则！（2=2）为假。</p><p>-表示操作数的负值，-1也就是我们所说的负数。</p><p>+表示操作数的正值，一般被省略。</p><p>&amp;表示操作数的地址，例如：</p><p>int a = 10;</p><p>int* b = &a;</p><p>sizeof用于计算该操作数或表达式的字节数，初学者会认为这是一个函数，这是一个误区。</p><p>~用于整型求补操作，即将该操作数的二进制进行转换，1变为0,0变为1。</p><p>++用于操作数的自加，每次加1，++a表示先自加在使用该操作数，a++表示先使用该操作数再进行自加。</p><p><em>表示间接访问操作符，在指针中使用。</em>a表示访问a指向的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑操作符有&amp;&amp;（和）和||（或）</span><br></pre></td></tr></table></figure><p>在这里需要注意的是要和位操作符进行区分：</p><p>和即所有条件为真且为真，一个条件为假就是假</p><p>或即一个为真即为真，全部为假才是假。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件操作符包括三个部分：a？b : c</span><br></pre></td></tr></table></figure><p>a为一个判断条件，若a为真则执行b语句，若a为假则执行c语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逗号操作符使用很频繁，逗号操作符把多个表达式分隔开，表达式从左往右依次计算。</span><br></pre></td></tr></table></figure><h2 id="寄语"><a href="#寄语" class="headerlink" title="寄语"></a>寄语</h2><p>　　可能关于操作符的叙述不是很详细，欢迎交流！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
