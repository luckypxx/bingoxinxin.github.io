<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bingoxin&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.bingoxin.top/"/>
  <updated>2018-12-13T11:35:30.458Z</updated>
  <id>http://www.bingoxin.top/</id>
  
  <author>
    <name>bingoxin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊天室项目</title>
    <link href="http://www.bingoxin.top/2019/01/04/%E8%81%8A%E5%A4%A9%E5%AE%A4%E9%A1%B9%E7%9B%AE/"/>
    <id>http://www.bingoxin.top/2019/01/04/聊天室项目/</id>
    <published>2019-01-04T07:27:52.000Z</published>
    <updated>2018-12-13T11:35:30.458Z</updated>
    
    <content type="html"><![CDATA[<p>socket需要有服务器端和客户端</p><p>客户端在连接服务器时，需要指定服务器的IP（标识电脑）和端口号（标识电脑上的具体某个应用）</p><p>通信的前提是：要创建基站，并与基站建立连接。 </p><a id="more"></a><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p><strong>Scoket类</strong></p><ul><li>绑定指定域名、端口号的服务器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Socket</span><span class="params">(String host, <span class="keyword">int</span> port, InetAddress localAddr,<span class="keyword">int</span> localPort)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>获取客户端输入流，读取服务器发来的消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>获取客户端输出流，向服务器发送消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> OutputStream <span class="title">getOutputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><h4 id="基站类—ServerSocket"><a href="#基站类—ServerSocket" class="headerlink" title="基站类—ServerSocket"></a>基站类—ServerSocket</h4><ul><li>默认绑定本地IP：127.0.0.1，以及指定端口号。在本机根据指定端口号创建服务器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>等待客户端连接，线程阻塞，当有客户连接时，返回客户端socket。侦听并接受连接到本服务的客户端连接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Socket <span class="title">accept</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>当服务器与客户端建立起连接后，通过输入输出流（客户端的Scoket）来通信</p><ul><li>获取服务器端输入流，读取客户端发来的消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>获取服务器端输出流，向客户端发送消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> OutputStream <span class="title">getOutputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="简单版的单线程聊天"><a href="#简单版的单线程聊天" class="headerlink" title="简单版的单线程聊天"></a>简单版的单线程聊天</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;socket需要有服务器端和客户端&lt;/p&gt;
&lt;p&gt;客户端在连接服务器时，需要指定服务器的IP（标识电脑）和端口号（标识电脑上的具体某个应用）&lt;/p&gt;
&lt;p&gt;通信的前提是：要创建基站，并与基站建立连接。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="项目" scheme="http://www.bingoxin.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://www.bingoxin.top/2019/01/03/JVM/"/>
    <id>http://www.bingoxin.top/2019/01/03/JVM/</id>
    <published>2019-01-03T13:10:46.000Z</published>
    <updated>2019-01-09T13:06:11.019Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机是通过软件模拟的具有完整硬件功能，运行在完全隔离环境中的计算机系统。</p><p>使用最多的是VMWare和Virtual Box。</p><p>JVM是通过软件<strong>模拟Java字节码指令集</strong>，JVM只保留了PC寄存器，而普遍的虚拟机有很多寄存器。</p><p>做JVM的公司有很多家，从<strong>JDK1.3</strong>开始，HotSpot为默认JVM。</p><p>JVM上<strong>不止可以运行Java的代码</strong></p><a id="more"></a><h3 id="JVM内存区域划分"><a href="#JVM内存区域划分" class="headerlink" title="JVM内存区域划分"></a>JVM内存区域划分</h3><p>Java内存区共分为6块内存</p><h4 id="线程私有内存"><a href="#线程私有内存" class="headerlink" title="线程私有内存"></a>线程私有内存</h4><p>每个线程都有，并且彼此之间相互隔离</p><ul><li>程序计数器</li></ul><p>程序计数器是比较小的内存空间，记录当前线程所执行的字节码的行号指示器。</p><p><strong>程序计数器记录的两种情况：</strong></p><p>1、若当前的线程执行的是Java方法，程序计数器记录的是正在执行的JVM字节码指令地址</p><p>2、若当前的执行线程执行的是Native方法，计数器值为空（监测不到C语言）</p><p>程序计数器是<strong>唯一一块不会产生OOM异常</strong>的区域</p><ul><li>虚拟机栈</li></ul><p>虚拟机栈描述Java<strong>方法</strong>执行的<strong>内存</strong>模型。</p><p>每个方法执行的同时，都会创建一个栈桢来存储<strong>局部变量表、操作数栈、方法出口</strong>等信息。每个方法从调用直到执行完毕的过程，对应一个栈桢在虚拟机栈的入栈和出栈过程。</p><p><strong>局部变量表存放内容：</strong>8种基本数据类型和对象引用（4个字节），因此每次开辟虚拟机栈桢的大小是确定的。</p><p>生命周期与线程相同：在创建线程时，同时创建线程的虚拟机栈。在线程执行完毕时，虚拟机栈也被一同回收。</p><p><strong>此区域一共会产生两种异常：</strong></p><p>1、若线程请求的栈深度大于JVM允许的深度（-Xss设置栈容量），抛出<code>StackOverFlowError</code>异常。常见于单线程</p><p>2、虚拟机在进行栈的动态扩展时，若无法申请到足够内存，抛出OOM（<code>OutOfMemoryError</code>）异常。常见于多线程</p><ul><li>本地方法栈</li></ul><p>本地方法（<code>Native</code>方法）执行的内存模型</p><p>在<strong>HotSpot虚拟机</strong>中，本地方法栈与虚拟机栈是同一块内存区域。</p><h4 id="线程共享内存"><a href="#线程共享内存" class="headerlink" title="线程共享内存"></a>线程共享内存</h4><p>所有线程共享此内存空间，并且此内存空间<strong>对所有线程可见</strong></p><ul><li>堆（GC堆）</li></ul><p>Java堆是JVM管理的最大内存区域。当JVM启动时创建。所有线程共享此内存，此内存中存放的都是数组和对象实例。</p><p>Java堆是垃圾回收器管理的最主要内存区域。Java堆可以处于物理上不连续的内存空间。-Xmx设置堆最大值，-Xms设置堆最小值</p><p><strong>异常：</strong>若在堆中没有足够的内存完成对象实例分配并且堆无法再次扩展时，抛出OOM异常</p><ul><li>方法区</li></ul><p>用于存储已被JVM加载的类信息、常量、静态变量等数据。JDK8以前，方法区也叫永久代。JDK8以后叫做元空间（Meta Space）</p><p>方法区无法满足内存分配需求时，抛出OOM</p><ul><li>运行时常量池</li></ul><p>运行时常量池是方法区的一部分，存放字面量与符号引用</p><p><strong>字面量：</strong>字符串常量（JDK7中移入堆中）、final常量、基本数据类型的值</p><p><strong>符号引用：</strong>类、字段、方法的完全限定名、名称、描述符</p><p>JVM内存区域划分-&gt;判断对象是否存活-&gt;垃圾回收算法-&gt;</p><h4 id="对象产生的过程"><a href="#对象产生的过程" class="headerlink" title="对象产生的过程"></a>对象产生的过程</h4><p>符号引用-&gt;类-&gt;具体引用 </p><p>根据符号引用去JVM方法区拿到该类的信息，然后再去堆中开辟空间</p><h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><p>OOM共有两种：内存溢出和内存泄漏</p><p><strong>内存泄漏：</strong>无用对象无法被垃圾回收，无法解决</p><p><strong>内存溢出：</strong></p><h3 id="垃圾回收器与内存分配策略"><a href="#垃圾回收器与内存分配策略" class="headerlink" title="垃圾回收器与内存分配策略"></a>垃圾回收器与内存分配策略</h3><h4 id="判断对象是否已死"><a href="#判断对象是否已死" class="headerlink" title="判断对象是否已死"></a>判断对象是否已死</h4><ul><li>引用计数法</li></ul><p>给每个对象附加一个引用计数器，每当有一个地方引用此对象时，计数器+1；每当有一个引用失效时，计数器-1；在任意时刻，只要计数器值为0的对象就是不能再被使用，即对象已死。</p><p>引用计数法实现简单，判定效率较高，但是无法解决循环引用问题。JVM并未采用此算法</p><p><code>-XX:+printGC</code>:查看垃圾处理装置</p><ul><li>可达性分析算法</li></ul><p>Java采用可达性分析算法来判断对象是否存活（C#也适用该算法）</p><p><strong>核心思想:</strong>通过一系列<code>GC Roots</code>的对象作为起点，从这些节点开始向下搜索对象，搜索走过的路径，称为“引用链”，当一个对象到任意一个GC Roots对象没有任何的引用链相连时（从GC Roots到对象不可达），证明此对象已死。</p><p><strong>Java中能作为GC Roots的对象包含以下四种：</strong></p><p>1、虚拟机栈中的引用对象</p><p>2、类静态变量引用的对象</p><p>3、本地方法栈中引用的对象</p><p>4、常量引用的对象</p><p><strong>JDK1.2之后对于引用的概念做了扩充：</strong></p><ul><li>强引用-StrongReference</li></ul><p>强引用指的是代码中普遍存在的，类似于Object obj = new Object();</p><p>在JVM中只要强引用还在，垃圾回收器永远不会回收此类对象的空间</p><ul><li>软引用-SoftReference</li></ul><p>软引用用来描述一些有用但不必须的对象，对于仅被软引用指向的对象，在系统将要发生内存溢出之前，会将<strong>所有软引用对象</strong>进行垃圾回收。若内存够用，这些对象仍然保留。在JDK1.2之后，提供了Soft Reference来实现软引用。</p><ul><li>弱引用-WeakReference</li></ul><p>弱引用用来描述一些有用但不必须的对象，但弱引用比软引用更差一点。仅被弱引用关联的对象最多只能生存到下一次GC开始之前。当垃圾回收器开始工作时，<strong>无论当前内存是否够用</strong>，都会回收掉仅被弱引用关联的对象。JDK1.2以后，使用WeakReference来实现弱引用</p><ul><li>虚引用-PhantomReference</li></ul><p>虚引用也称为幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在完全不会对其生存时间有影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是在这个对象被GC之前，收到一个系统通知。JDK1.2之后，提供PhantomReference来描述虚引用。</p><p><strong>为什么要有虚引用：</strong></p><p>在一个虚引用被垃圾回收之前，会收到一个通知来告诉JVM该虚引用对象将被销毁</p><h4 id="对象的自我拯救-finalize"><a href="#对象的自我拯救-finalize" class="headerlink" title="对象的自我拯救-finalize"></a>对象的自我拯救-finalize</h4><p>在可达性分析算法中不可达对象，也并非“非死不可”，所有不可达的对象处于缓刑阶段。要宣告一个对象的彻底死亡，需要经历两次标记过程：</p><p>若对象在进行可达性分析之后，发现到GC Roots不可达，此对象会进行一次筛选过程。</p><p><strong>筛选的条件</strong>是此对象是否有必要执行<code>finalize()</code>。当对象没有覆写<code>finalize()</code>或<code>finalize()</code>已被调用过，JVM会将此对象彻底宣判死亡。若筛选成功（对象覆写了<code>finalize()</code>，并且未被执行过），会将此对象放到F-Queue中</p><p>如果对象在finalize方法中成功自救（此对象与任意一个GC Roots建立联系），则对象在第二次标记时被移除回收集合，成功存活；若对象在finalize中仍然与GC Roots不可达，宣告死亡。</p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>方法区的回收主要回收两部分内容：废弃常量和无用的类</p><p><strong>判断常量是否被废弃的条件：</strong></p><p>常量未被引用</p><p><strong>判断一个类是无用类的条件：</strong></p><p>1、该类的所有实例都已经被回收，也就是在堆中不存在该类的任何实例。</p><p>2、加载该类的类加载器都被回收</p><p>3、该类的Class对象没有在任何其他地方被引用，也无法通过反射访问该类的所有内容</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><ul><li>算法核心思想：</li></ul><p>整个算法分为<strong>标记清除</strong>两个阶段：标记阶段标记出此次垃圾回收需要回收的对象，清除阶段一次性清除所有带标记对象。</p><p>如图所示：</p><p><img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.PNG"></p><ul><li>弊端</li></ul><p>1.效率上：标记与清除两个阶段的效率都不高</p><p>2.空间问题：标记清除算法会产生大量的不连续空间，若程序中需要分配较大连续对象时，由于空间碎片较多因此无法找到连续内存而不得不再次出发GC</p><h4 id="复制算法-新生代垃圾回收算法"><a href="#复制算法-新生代垃圾回收算法" class="headerlink" title="复制算法-新生代垃圾回收算法"></a>复制算法-新生代垃圾回收算法</h4><ul><li>核心思想</li></ul><p>将内存块按容量划分为大小相等的两块，每次只使用其中一块内存。当使用的内存需要垃圾回收时，会将此区域的所有存活对象一次性复制到保留区域，然后将使用的内存块一次清理掉。</p><p><img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.PNG"></p><ul><li>弊端</li></ul><p>复制算法最大的问题在于内存利用率太低，商用JVM都对复制算法做了改进</p><h4 id="JVM改进后的算法"><a href="#JVM改进后的算法" class="headerlink" title="JVM改进后的算法"></a>JVM改进后的算法</h4><p>新生代中98%的对象都是“朝生夕死”（存活时间短），所以并不需要按照1:1来划分内存空间。将内存（新生代内存）分为一块较大的Eden（伊甸园）和两块较小的Survivor（幸存者空间，大小一样，一块称为From区，一块称为To区）空间。每次只使用Eden和其中一块Survivor区域。（默认比例8:1:1）</p><ul><li>HotSpot复制算法流程</li></ul><p>1.当Eden区满的时候，会触发一次垃圾垃圾回收，将所有的存活对象拷贝到From区域中，然后一次性清除Eden区；当Eden区再次触发Minor GC，会扫描Eden区的From区，将这两块空间中的存活对象拷贝到To区，而后一次性清除Eden区的From区的不存活对象</p><p>2.当后续Eden区再次发生Minor GC时，会对Eden和To区进行回收，存活对象移动到From区，后续流程类似，只是将From和To区来回作为保留区域</p><p>3.部分对象会在From与To区域中来回复制，如此交换15次（MaxTenuringThreshold,默认为15）最终会存入老年代</p><p><img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/%E5%8D%87%E7%BA%A7%E7%89%88.png"></p><p>Survivor区域若无法放下所有存活对象，需要依赖其他内存（肉老年代）</p><h4 id="标记整理算法—老年代GC算法"><a href="#标记整理算法—老年代GC算法" class="headerlink" title="标记整理算法—老年代GC算法"></a>标记整理算法—老年代GC算法</h4><p>老年代中对象存活率很高，因此不适用复制算法（需要大量进行对象的复制过程，效率很低）</p><ul><li>算法思想</li></ul><p>算法分为标记与整理两个阶段。标记过程与标记清除过程一致，整理过程需要让所有存活对象向一端移动，而后直接清理掉存活对象边界以外的内存</p><h4 id="分代回收算法"><a href="#分代回收算法" class="headerlink" title="分代回收算法"></a>分代回收算法</h4><ul><li>算法核心思想</li></ul><p>根据对象的存活周期将内存分为以下两块</p><p>新生代：每次GC都有大批对象死去，只有少量存活，因此采用复制算法</p><p>老年代：对象存活率较高，没有额外空间对其分配担保，采用标记整理算法</p><h4 id="Minor-FullGC"><a href="#Minor-FullGC" class="headerlink" title="Minor FullGC"></a>Minor FullGC</h4><p>1.MinorGC称为新生代GC：指的是发生在新生代的垃圾回收。由于新生代对象大多存活周期较短，因此MinorGC发生频率非常频繁，一般回收速度较高</p><p>2.Full GC称为老年代GC或Major GC</p><p>GC：指的是发生在老年代的垃圾回收，出现了Major</p><p>GC通常会伴随至少一次的Minor GC（并非绝对）。一般Full GC比Minor GC慢10倍以上，发生频率较低</p><h3 id="垃圾收集器（垃圾回收算法的具体实现）-JDK8"><a href="#垃圾收集器（垃圾回收算法的具体实现）-JDK8" class="headerlink" title="垃圾收集器（垃圾回收算法的具体实现）-JDK8"></a>垃圾收集器（垃圾回收算法的具体实现）-JDK8</h3><ul><li>串行</li></ul><p>垃圾回收线程与用户线程在JVM中顺序执行</p><ul><li>并行</li></ul><p>垃圾回收线程一起执行，用户线程仍处于等待状态</p><ul><li>并发</li></ul><p>垃圾回收线程与用户线程一起执行</p><ul><li>STW</li></ul><p>当垃圾回收线程工作时，用户线程处于等待状态</p><p><strong>新生代垃圾回收器：</strong></p><p>Serial（串行收集器）、ParNew（并行）、parallel Scavenge（并行）</p><p><strong>老年代垃圾回收器：</strong></p><p>CMS（并发）、Serial Old（串行）、Parallel Old（并行）</p><p>全区域垃圾回收器：G1（并发）</p><h3 id="对象分配策略"><a href="#对象分配策略" class="headerlink" title="对象分配策略"></a>对象分配策略</h3><h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>大多数情况下，对象在新生代Eden区分配。当Eden区没有足够的空间分配时，JVM发生一次Minor GC</p><p><code>-Xmn</code>:新生代内存大小</p><p><code>-XX:SurvivorRatio = 8</code>:改变分配比例</p><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p><code>-XX:PretenureSizeThreshold = 字节大小</code>对象超过规定大小就将对象放入老年代</p><h4 id="长期存活对象进入老年代"><a href="#长期存活对象进入老年代" class="headerlink" title="长期存活对象进入老年代"></a>长期存活对象进入老年代</h4><p>JVM给每个对象定义了一个对象年龄的计数器，若对象在Eden去出生并且经历一次Minor GC后，仍然存活并且能被Survivor容纳，将此对象的年龄置为1，此后对象每再Survivor区域中经历一次Minor GC，年龄就增加一岁。当其年龄增加到一定程度（默认为15），此对象晋升到老年代</p><p><code>-XX:MaxTenuringThreshold = 15</code>设置晋升到老年代的大小</p><h4 id="动态年龄判定"><a href="#动态年龄判定" class="headerlink" title="动态年龄判定"></a>动态年龄判定</h4><p>JVM并不是永远要求对象的年龄必须达到MaxTenuringThreshold规定的值，才能晋升老年代。若Survivor空间中相同年龄的所有对象大小的总和和大于Survivor空间的一半，此时年龄大于等于该年龄的所有对象直接进入老年代，无须等到MaxTenuringThreshold要求的年龄</p><h3 id="JDK命令行工具"><a href="#JDK命令行工具" class="headerlink" title="JDK命令行工具"></a>JDK命令行工具</h3><ul><li>jps***</li></ul><p><strong>JVM进程状态工具</strong></p><p>列出正在运行的JVM进程，并返回进程ID</p><p>常用参数：<code>-l</code> 输出主类的全名称，返回进程ID</p><ul><li>jstat</li></ul><p>JVM统计信息监视工具，显示本地或远程JVM中类装载、内存、垃圾回收等数据</p><p><code>jstat -gcutil PID</code>:显示垃圾回收信息</p><ul><li>jinfo</li></ul><p>JVM配置信息查看工具</p><p><code>jinfo -flags PID</code></p><ul><li>jmap***</li></ul><p>内存映像工具</p><p>jmap用于生成堆转储快照（堆得快照）</p><p><code>jmap -heap PID</code>：显示JVM堆具体信息</p><p><code>jmap -histo PID</code>:显示JVM中对象的统计信息</p><ul><li>jhat</li></ul><p>heap文件的分析工具</p><p><code>jhat heap文件路径</code></p><ul><li>jstack***</li></ul><p>Java栈跟踪工具</p><p>jstack生成当前JVM线程的快照。</p><p>可用于定位线程出现长时间停顿的原因</p><h3 id="Java内存模型—JMM"><a href="#Java内存模型—JMM" class="headerlink" title="Java内存模型—JMM"></a>Java内存模型—JMM</h3><p>Java内存模型是基于线程的，JMM定义的主要目标是为了定义程序中各个变量的访问规则（JVM中如何将变量从内存中取出以及如何将变量再写回内存的细节）。此处的变量包括实例字段、静态字段与数组元素</p><h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><p>主内存是所有线程共享的，而工作内存指的是每个线程独有的</p><p>JMM规定<strong>所有变量必须存储在主内存</strong>中。每条线程都有自己的工作内存，工作内存中保存了该线程使用到的变量的主内存副本。线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，不能直接读写主内存中的变量。不同线程之间也无法直接访问彼此的工作内存变量，线程间变量值的传递均需要通过主内存来完成。</p><h4 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h4><p><strong>JMM内存三大特性：</strong></p><ul><li>原子性</li></ul><p>基本数据类型的访问读写是具有原子性，如若需要更大范围的原子性，需要内键锁或lock体系的支持（i++、i–等操作）</p><ul><li>可见性</li></ul><p>当一个线程修改了共享变量的值，其他线程能够立即得知此修改。volatile、final、synchronized可以实现可见性</p><ul><li>有序性</li></ul><p>如果在本线程内观察，所有操作都是有序的；若在线程之外观察另外一个线程，所有操作都是无序的</p><p>JMM具备先天的有序性，即无须通过任何手段就能保证的有序性。称为JMM的happens-before原则。若两个操作的次序无法从happens-before中推导出来，则无法保证其有序性，JVM可以随意对其重排序。</p><p>要想并发程序正确执行，必须同时保证原子性、可见性以及有序性。只要有任意一个没有被保证，就有可能导致程序运行不正确</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</p><ul><li>保证此变量对所有线程的可见性</li></ul><p>当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。普通变量无法做到可见性。</p><p>volatile变量在各个线程中是一致的，但是volatile变量的运算在并发下一样是不安全的。Java中运算操作并非原子性操作，必须结合内键锁或lock体系来约束。</p><ul><li>由于volatile变量只保证可见性，在不符合一下两条规则的场景下，仍然需要使用加锁来保证原子性：</li></ul><p>1.运算结果不依赖当前变量的值，或者能够确保只有单一的线程修改变量值</p><p>2.变量不需要与其他的状态变量共同参与不变约束</p><ul><li>并发场景下对于类似i++操作如何保证程序的正确结果：</li></ul><p>1、加锁</p><p>2、使用原子类（java.util.concurrent.atomic包下的所有类-内部使用CAS保证原子性）</p><ul><li>禁止指令重排（内存屏障）</li></ul><p>1.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作更改肯定全部已经执行完毕且结果已经对后面的操作可见，在其后面的操作肯定还没有执行</p><p>2.在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能提前执行</p><h4 id="懒汉式单例的线程安全问题"><a href="#懒汉式单例的线程安全问题" class="headerlink" title="懒汉式单例的线程安全问题"></a>懒汉式单例的线程安全问题</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虚拟机是通过软件模拟的具有完整硬件功能，运行在完全隔离环境中的计算机系统。&lt;/p&gt;
&lt;p&gt;使用最多的是VMWare和Virtual Box。&lt;/p&gt;
&lt;p&gt;JVM是通过软件&lt;strong&gt;模拟Java字节码指令集&lt;/strong&gt;，JVM只保留了PC寄存器，而普遍的虚拟机有很多寄存器。&lt;/p&gt;
&lt;p&gt;做JVM的公司有很多家，从&lt;strong&gt;JDK1.3&lt;/strong&gt;开始，HotSpot为默认JVM。&lt;/p&gt;
&lt;p&gt;JVM上&lt;strong&gt;不止可以运行Java的代码&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
      <category term="JVM" scheme="http://www.bingoxin.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深浅拷贝</title>
    <link href="http://www.bingoxin.top/2019/01/03/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://www.bingoxin.top/2019/01/03/深浅拷贝/</id>
    <published>2019-01-03T10:37:30.000Z</published>
    <updated>2019-01-03T14:13:59.364Z</updated>
    
    <content type="html"><![CDATA[<h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><p>拷贝的执行函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><p>并不是所有的类都可以被拷贝，需实现<code>Cloneable</code>接口，并且在类中自定义<code>clone()</code>调用Object类提供的继承权限<code>clone()</code></p><p>若不实现Cloneable接口，在调用<code>clone()</code>时，会抛出CloneNotSupportedException异常。</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>对于浅拷贝而言，拷贝出来的对象仍然保留原对象的所有引用。</p><p>只要拷贝对象和原对象中引用的属性发生改变，其所有的该引用属性都会发生改变</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>对于深拷贝而言，拷贝出来的对象会产生新的对象。</p><p>对于拷贝的原对象和拷贝出来的对象来说，改变一个引用的属性，互不影响</p><p>对象中包含的引用只是自定义引用</p><h3 id="如何实现深拷贝"><a href="#如何实现深拷贝" class="headerlink" title="如何实现深拷贝"></a>如何实现深拷贝</h3><p>1.包含的其他类继续实现Cloneable接口，并且调用<code>clone()</code></p><p>2*.实现序列化</p><h4 id="调用clone"><a href="#调用clone" class="headerlink" title="调用clone()"></a>调用<code>clone()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baby</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Baby&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Baby <span class="title">clone</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        Baby baby = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            baby =(Baby) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Baby</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line">    <span class="keyword">public</span> Baby baby;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Monkey</span><span class="params">(String name, Integer age, Baby baby)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.baby = baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Monkey&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", baby="</span> + baby +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Baby <span class="title">getBaby</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBaby</span><span class="params">(Baby baby)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baby = baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Monkey <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Monkey monkey = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            monkey = (Monkey) <span class="keyword">super</span>.clone();</span><br><span class="line">            monkey.baby = <span class="keyword">this</span>.baby.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> monkey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Baby baby = <span class="keyword">new</span> Baby(<span class="string">"zxh"</span>,<span class="number">3</span>);</span><br><span class="line">        Monkey monkey = <span class="keyword">new</span> Monkey(<span class="string">"zh"</span>,<span class="number">88</span>,baby);</span><br><span class="line"></span><br><span class="line">        Monkey monkey1 = monkey.clone();</span><br><span class="line">        System.out.println(monkey1);</span><br><span class="line">System.out.println(monkey.baby == monkey1.baby);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><ul><li>概念</li></ul><p>将内存中保存的对象变为二进制流，进行输出或保存在文本中，即将对象变为二进制流。<br>若类要实现序列化，必须实现<code>Serializable</code>接口</p><p>Serializable接口为标识接口，只有实现了Serializable接口的类，才具备对象序列化的功能。</p><p>但要具体实现序列化和反序列化需要使用IO包中提供的两个处理类：ObjectOutputStream（序列化）、ObjectInputStream（反序列化）</p><ul><li>ObjectOutputStream（序列化）</li></ul><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectOutputStream</span><span class="params">(OutputStream out)</span></span>;</span><br></pre></td></tr></table></figure><p>将文件转化为二进制流输出到终端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writeObject(Object obj);</span><br></pre></td></tr></table></figure><p>例程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Monkey</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Monkey&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\pxx\\Desktop"</span> + <span class="string">"\\1.txt"</span>);</span><br><span class="line">        Monkey monkey = <span class="keyword">new</span> Monkey(<span class="string">"zh"</span>,<span class="number">99</span>);</span><br><span class="line">        OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(outputStream);</span><br><span class="line">        oos.writeObject(monkey);</span><br><span class="line">        oos.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>transient</code>关键字</p><p>若希望类中的若干属性不被序列化，可以在属性前添加该关键字</p></li><li><p>ObjectInputStream(反序列化)</p></li></ul><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectInputStream</span><span class="params">(InputStream in)</span></span>;</span><br></pre></td></tr></table></figure><p>将文件中的二进制流输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readObject(Object obj);</span><br></pre></td></tr></table></figure><h4 id="使用序列化实现深拷贝"><a href="#使用序列化实现深拷贝" class="headerlink" title="使用序列化实现深拷贝"></a>使用序列化实现深拷贝</h4><p>使用序列化进行深拷贝时，无须实现Cloneable接口，而需要实现Serializable接口</p><p>用序列化实现上一例程的拷贝Monkey对象的功能，代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public Monkey ObjectClone()&#123;</span><br><span class="line"></span><br><span class="line">        OutputStream outputStream = new ByteOutputStream();</span><br><span class="line">        Monkey monkey = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(outputStream);</span><br><span class="line"></span><br><span class="line">            oos.writeObject(this);</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            InputStream bis = new ByteInputStream(((ByteOutputStream) outputStream).getBytes(),((ByteOutputStream) outputStream).size());</span><br><span class="line">            ObjectInputStream ois = new ObjectInputStream(bis);</span><br><span class="line"></span><br><span class="line">            monkey = (Monkey) ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line">            bis.close();</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return monkey;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;深浅拷贝&quot;&gt;&lt;a href=&quot;#深浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;深浅拷贝&quot;&gt;&lt;/a&gt;深浅拷贝&lt;/h3&gt;&lt;p&gt;拷贝的执行函数&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>网络基础概念理解</title>
    <link href="http://www.bingoxin.top/2018/12/25/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
    <id>http://www.bingoxin.top/2018/12/25/网络基础概念理解/</id>
    <published>2018-12-25T09:20:25.000Z</published>
    <updated>2019-01-02T13:50:37.345Z</updated>
    
    <content type="html"><![CDATA[<p>总是听到身边的人说局域网，那么局域网到底是什么呢？</p><p>如何将一个数据发送到另一台主机呢？</p><p>操作系统是如何知道网卡中有数据发来呢？</p><p>请接下这篇博客<a id="more"></a></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="局域网与公网"><a href="#局域网与公网" class="headerlink" title="局域网与公网"></a>局域网与公网</h3><ul><li><p>局域网概念—LAN</p><p>局域网指在某一区域内由多台计算机互联成的计算机组，应用在局部范围内，例如我们家里或者学校使用的无线网</p></li></ul><p>我们使用的WIFI也叫WLAN，即无线局域网。</p><p>在同一局域网内，两台主机可以直接通信</p><ul><li><p>广域网—WAN</p><p>广域网是连接不同地区局域网或城域网计算机通信的远程网，通常跨接很大的物理范围，例如我们使用的阿里云服务器</p></li></ul><p>公网接入方式：上网的计算机得到的IP地址是Internet上的非保留地址，公网的计算机和Internet上的其他计算机可随意互相访问。</p><p>任何一台在局域网上的主机，在不欠费的情况下，是可以访问公网上的服务器的</p><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>协议就像是一种约定，而网络协议也可以被理解为是在网络上的一种约定</p><ul><li>协议分层</li></ul><p>例如，两个人在打电话，这个通信过程可以将其分为两部分：通信工具和人。</p><p>当中国人和中国人打电话时，两人均使用汉语进行沟通，当其中一人使用电话进行通话时，两人依然可以正常沟通。再或者，其中一个中国人给一个英国人打电话时，两人还是可以用英语进行交流。</p><p>这也可以说明了分层的<strong>好处</strong>：其中一层发生改变整体不受影响，即分层可以更好的解耦</p><p>在分层这里要注意：同层之间才可以通信</p><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总是听到身边的人说局域网，那么局域网到底是什么呢？&lt;/p&gt;
&lt;p&gt;如何将一个数据发送到另一台主机呢？&lt;/p&gt;
&lt;p&gt;操作系统是如何知道网卡中有数据发来呢？&lt;/p&gt;
&lt;p&gt;请接下这篇博客
    
    </summary>
    
    
      <category term="操作系统和网络" scheme="http://www.bingoxin.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java中的类集</title>
    <link href="http://www.bingoxin.top/2018/12/21/Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E9%9B%86/"/>
    <id>http://www.bingoxin.top/2018/12/21/Java中的类集/</id>
    <published>2018-12-21T14:44:51.000Z</published>
    <updated>2019-01-08T13:53:41.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java类集"><a href="#Java类集" class="headerlink" title="Java类集"></a>Java类集</h1><p>Java类集就是动态数组，类集的使用比较容易操作，但是类集的底层需要用到数据结构和多线程</p><p>所有的类集都在java.util包下<a id="more"></a></p><h3 id="Java类集的产生"><a href="#Java类集的产生" class="headerlink" title="Java类集的产生"></a>Java类集的产生</h3><p>Java类集是从JDK1.2开始应用的，用于解决数组定长问题</p><ul><li>Collection接口—<strong>单个对象</strong>保存的最顶层父接口</li></ul><p>Collection接口以及其子接口，在每次进行数据操作时只能对单个对象进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Iterable&lt;E&gt;</code>:迭代器接口（用于遍历集合）</p><p><code>Interface&lt;E&gt; iterator()</code>：取得集合的迭代器，JDK1.5之前没有泛型，则迭代器直接写在Collection接口中</p><ul><li>Collection接口中提供的核心方法</li></ul><p><strong>向类集中添加元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>取得接口的迭代器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Collection 接口只定义了存储数据的标准，但是无法区分存储类型。因此在实际中我们往往是由两个子接口List（允许数据重复）、Set（不允许数据重复）一般不直接使用Collection接口</p><h2 id="List接口—允许数据重复"><a href="#List接口—允许数据重复" class="headerlink" title="List接口—允许数据重复"></a>List接口—允许数据重复</h2><p>在进行单个集合处理时，优先考虑List接口</p><p>在List接口中，拓展了两个重要方法（List独有）</p><ul><li>根据索引取得下标数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>根据索引下标更改数据，返回原来的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br></pre></td></tr></table></figure><p>List接口有三个重要子类：ArrayList、Vector、LinkedList</p><p>List接口要想保存自定义类的对象，该类必须覆写<code>equals()</code>来使用<code>contains()</code>、<code>remove()</code></p><h3 id="ArrayList-Vector-LinkedList的区别"><a href="#ArrayList-Vector-LinkedList的区别" class="headerlink" title="ArrayList/Vector/LinkedList的区别"></a>ArrayList/Vector/LinkedList的区别</h3><ul><li>ArrayList与Vector的区别</li></ul><p>1、<strong>出现版本：</strong>ArrayList 在JDK1.2版本才出现，Vector在JDK1.0版本就已经出现</p><p>2、<strong>调用无参构造的区别：</strong>Vector在无参构造执行后将对象数组大小初始化为10，ArrayList采用懒加载策略，在构造方法阶段并不初始化数组，在第一次添加元素时才会初始化数组，大小为10</p><p>3、<strong>扩容策略：</strong>ArrayList在扩容时，会扩容到原来长度的1.5倍；Vector在扩容时，会扩容到原来的两倍</p><p>4、<strong>线程的安全性：</strong>ArrayList采用异步处理，线程不安全，效率较高；Vector采用在方法上加锁，线程安全，效率更低。（即便要使用线程安全的List也不使用Vector）</p><p>5、<strong>遍历：</strong>Vector支持较老的迭代器；ArrayList不支持</p><ul><li>ArrayList与Vector的共同点</li></ul><p>底层都使用数组实现，且都是List的子类</p><ul><li>ArrayList与LinkedList的区别</li></ul><p>LinkedList底层是双向链表，ArrayList的底层是数组</p><h2 id="Set接口—不允许数据重复"><a href="#Set接口—不允许数据重复" class="headerlink" title="Set接口—不允许数据重复"></a>Set接口—不允许数据重复</h2><p>Set接口没有扩充方法，常用子类有<code>HashSet</code>(无序存储)和<code>TreeSet</code>(有序存储)</p><p>Set接口本质上就是Map接口，Set就是value值都为PRESENT的Map</p><h3 id="Comparable接口与Comparator接口"><a href="#Comparable接口与Comparator接口" class="headerlink" title="Comparable接口与Comparator接口"></a>Comparable接口与Comparator接口</h3><ul><li>Comparable接口</li></ul><p>在Java中，若实现自定义类的比较，提供了一下两个接口：</p><p>java.lang.Comparable接口（内部比较器）:若一个类实现了Comparable接口，就表示该类可以进行比较并排序的。存放该类的Conllection或数组，可以直接通过<code>Collection.sort()</code>或Array.sort进行排序</p><p>实现了Comparable接口的类可以直接存放在TreeSet或TreeMap中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>返回值三种情况：</p><p>返回正数：当前对象大于目标对象</p><p>返回负数：当前对象小于目标对象</p><p>返回0：当前对象等于目标对象</p><ul><li>Comparator接口</li></ul><p>Comparator是外部排序接口</p><p>若要控制某个自定义类的顺序，而该类本身不支持排序—实现Comparator接口，覆写compareTo方法或实现一个比较器传入TreeSet或TreeMap中进行比较即可。</p><p>实现了Comparator接口的类作为比较器，通过该比较器来进行类排序，具有两个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1,T o2)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值与compareTo返回值完全一样</p><p>返回正数，o1&gt;o2</p><p>返回负数，o1&lt;o2</p><p>返回0，o1=o2</p><p>实现<code>Comparator</code>接口进行第三方排序—策略模式，此方法更加灵活，可以轻松改变策略进行第三方的排序方法</p><ul><li>Comparable接口与Comparator接口的关系</li></ul><p>Comparable是排序接口，若一个类实现了Comparable接口，意味着该类支持排序，是一个内部比较器（自己去和别人比）</p><p>Comparator接口是比较器接口，类本身不支持排序，专门有若干个第三方的比较器（实现了Comparator接口的类）来进行类排序，是一个外部比较器</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>底层是由哈希表和红黑树，允许存放null，无序储存</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>底层使用红黑树，不允许空值出现，允许储存</p><p>保存自定义类需实现Comparable接口或者传入比较器（compartor接口）</p><h3 id="HashSet和TreeSet的区别"><a href="#HashSet和TreeSet的区别" class="headerlink" title="HashSet和TreeSet的区别"></a>HashSet和TreeSet的区别</h3><p>1、<strong>底层实现不同：</strong>HashSet底层是由哈希表和红黑树，允许存放null，无序储存；TreeSet底层使用红黑树，不允许空值出现，允许储存</p><h3 id="重复元素比较"><a href="#重复元素比较" class="headerlink" title="重复元素比较"></a>重复元素比较</h3><p>TreeSet与TreeMap依靠Comparator或Comparable接口来区别重复元素</p><p>HashMap和HashSet不依赖比较接口，可以通过同时覆写其<code>equals()</code>和<code>HashCode()</code>方法来区分</p><p><strong>元素比较步骤：</strong></p><p>1、调用<code>hashCode()</code>计算出对象hash码决定存放的hash桶</p><p>2、使用<code>equals()</code>方法来判定两个元素内容是否相等，若相等，则不放置元素，若不相等，则在相同桶之后将元素链起来</p><p>object类内置的<code>hashCode()</code>是默认比较对象的地址转为hash码</p><p>两个对象<code>equals()</code>方法返回true，他们的hashCode必然保持相等，</p><p>两个对象的hashCode相等，不能保证他们的<code>equals()</code>一定相等，当且仅当hashCode和equals都返回true是，才说明两个对象都相等</p><ul><li>覆写<code>equals()</code>方法原则</li></ul><blockquote><p>自反性：对于任何非空引用值x，<code>x.equals(x)</code>都返回true</p><p>对称性：对于任何非空的x,y,当且仅当<code>x.equals(y)</code>返回true，<code>y.equals(x)</code>返回true</p><p>传递性：对于任何非空的x,y,z,当<code>x.equals(y)</code>返回true，<code>y.equals(z)</code>返回true,才有<code>x.equals(z)</code>返回true</p><p>一致性：对于任何非空的x,y,若x与y中属性没有变，则多次调用<code>equals()</code>方法，都返回true或false</p><p>非空性：对于任何非空引用值x，<code>x.equlas(null)</code>，返回false</p></blockquote><h3 id="集合输出—迭代器Iterator输出"><a href="#集合输出—迭代器Iterator输出" class="headerlink" title="集合输出—迭代器Iterator输出"></a>集合输出—迭代器Iterator输出</h3><ul><li>迭代输出—Collection接口支持</li></ul><p><strong>Iterator的两个核心方法</strong></p><p>判断是否还有元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>取得下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>单向迭代输出</strong></p><p>调用Collection集合子类的Iterator方法取得内置的迭代器，使用一下输出格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双向迭代输出</strong>–ListIterator</p><p>除了<code>hasNext</code>与<code>next</code>方法外还有：</p><p>判断是否有上一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasPrevious();</span><br></pre></td></tr></table></figure><p>取得上一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">previous();</span><br></pre></td></tr></table></figure><p>要想从后向前遍历，首先至少要从前向后遍历一次才可使用</p><ul><li>Enumeration枚举输出—Vector类支持</li></ul><p>判断是否有下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasMoreElements();</span><br></pre></td></tr></table></figure><p>取得下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextElement();</span><br></pre></td></tr></table></figure><ul><li>for-each输出</li></ul><p>能使用for-each的本质是各个集合类都内置了迭代器</p><ul><li>fail-fast机制</li></ul><p>ConcurrentModificationException发生在Collection集合使用迭代器遍历时，使用了集合类提供的修改集合内容方法报错。而如果使用Iterator迭代器的<code>remove()</code>不会出现此类错误</p><p>Collection集合中的modCount表示当前集合修改的次数</p><p>exceptedModCount是迭代器中记录当前集合的修改次数</p><p>当取得集合迭代器时，调用<code>new Itr()</code>会执行expectedModCount = ModCount，换言之，迭代器就是当前集合的一个副本</p><p>快速失败策略保证了所有用户在进行迭代遍历集合时，拿到的数据一定是最新的数据（避免脏读产生）</p><ul><li>fail-safe</li></ul><p>不产生ConcurrentModificationException异常，juc包下的所有线程安全集合（CopyOnWriteArrayList）</p><p><strong>以后再迭代器遍历时，不要修改集合的内容</strong></p><h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><p>Map接口是Java中保存二元偶对象的最顶层接口</p><p>Map中key值唯一，即通过可以值就可以找到对应的value值</p><ul><li>核心方法</li></ul><p>向Map中添加数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key,V value)</span></span>;</span><br></pre></td></tr></table></figure><p>根据指定的key值取得相应的value值，若没有key值，返回null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>;</span><br></pre></td></tr></table></figure><p>将Map集合变为Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure><p>返回所有key值集合，key不能重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>返回所有value值，value可以重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Map接口常用子类：HashMap、TreeMap、Hashtable、ConcurrentHashMap</p><ul><li>类比HashMap与Hashtable</li></ul><p>1、<strong>key和value的取值：</strong>HashMap的key值和value值可以取null，而Hashtable中key和value均不能取value值</p><p>2、<strong>出现的版本不同：</strong>JDK1.2产生了HashMap，JDK1.0就产生了Hashtable</p><p>3、<strong>线程安全问题：</strong>HashMap采用异步处理，线程不安全但是效率高，Hashtable采用同步处理，线程安全，效率低</p><p>4、<strong>底层实现：</strong>HashMap的底层是用哈希表和红黑树实现的，Hashtable的底层是用哈希表实现的</p><h4 id="Map集合使用迭代器输出"><a href="#Map集合使用迭代器输出" class="headerlink" title="Map集合使用迭代器输出"></a>Map集合使用迭代器输出</h4><ul><li>将Map集合转为Set集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure><h4 id="Collection与Map的储存方式"><a href="#Collection与Map的储存方式" class="headerlink" title="Collection与Map的储存方式"></a>Collection与Map的储存方式</h4><p>两者都是以对象为单位进行储存的</p><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><ul><li>栈—先入后出</li></ul><p>函数栈桢，浏览器标签页的后退，安卓Activity的后腿，编辑器撤销</p><p><strong>面试题：自己实现一个html识别器</strong></p><ul><li>队列—先入先出</li></ul><p>消息队列：kafka，RobitMQ</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>Queue接口：</p><p>入队列：<code>add()</code></p><p>出队列：<code>poll()</code></p><p>返回队列头元素，不出队：<code>peek()</code></p><h3 id="属性文件操作—资源（Properties）文件操作"><a href="#属性文件操作—资源（Properties）文件操作" class="headerlink" title="属性文件操作—资源（Properties）文件操作"></a>属性文件操作—资源（Properties）文件操作</h3><p>Java中有一种特殊的文件是以<code>.properties</code>为后缀的文件，资源文件的内容都是K,V模式的，并且K和Value都是String类型</p><ul><li>设置属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">setProperty</span><span class="params">(String key,String Value)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>取得属性,若没有指定key值，返回null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>若没有指定key值，返回默认值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getProperty(String key,String defaultValue);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java类集&quot;&gt;&lt;a href=&quot;#Java类集&quot; class=&quot;headerlink&quot; title=&quot;Java类集&quot;&gt;&lt;/a&gt;Java类集&lt;/h1&gt;&lt;p&gt;Java类集就是动态数组，类集的使用比较容易操作，但是类集的底层需要用到数据结构和多线程&lt;/p&gt;
&lt;p&gt;所有的类集都在java.util包下
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDBC</title>
    <link href="http://www.bingoxin.top/2018/12/20/JDBC/"/>
    <id>http://www.bingoxin.top/2018/12/20/JDBC/</id>
    <published>2018-12-20T06:20:21.000Z</published>
    <updated>2019-01-02T12:58:41.473Z</updated>
    
    <content type="html"><![CDATA[<p>现在的应用系统大多都离不开数据库，而Java程序访问数据库的基本方式是通过JDBC。</p><p>Java Database Connectivity，Java数据库连接。</p><p>用于执行SQL语句的Java API</p><p>JDBC使用流程如下：</p><p><img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JDBC/%E6%8D%95%E8%8E%B7.PNG"></p><a id="more"></a><h3 id="JDBC的使用"><a href="#JDBC的使用" class="headerlink" title="JDBC的使用"></a>JDBC的使用</h3><ul><li>加载JDBC驱动程序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br></pre></td></tr></table></figure><ul><li>建立数据库连接</li></ul><p>代码格式：jdbc:{数据库的名称}://host:port/databaseName?param1=value&amp;param2=value2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/memo? user=root&amp;password=root&amp;useUnicode=true&amp;characterEncoding=UTF-8"</span>);</span><br></pre></td></tr></table></figure><ul><li>创建操作命令（statement）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement statement = connection.createStatement();</span><br></pre></td></tr></table></figure><ul><li>执行SQL语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">            ResultSet resultSet = statement.executeQuery(sql);</span><br></pre></td></tr></table></figure><ul><li>处理结果集</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">                String title = resultSet.getString(<span class="string">"ename"</span>);</span><br><span class="line">                System.out.println(id == resultSet.getInt(<span class="string">"empno"</span>));</span><br><span class="line">                System.out.println(String.format(<span class="string">"id = %d,title = %s"</span>, id, title));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ul><li>释放资源（关闭结果集，命令，连接）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭结果集</span></span><br><span class="line"><span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        resultSet.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; &#125; </span><br><span class="line"><span class="comment">//关闭命令</span></span><br><span class="line"><span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        statement.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; &#125;</span><br><span class="line"><span class="comment">//关闭连接命令</span></span><br><span class="line"><span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();    </span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="Statement对象"><a href="#Statement对象" class="headerlink" title="Statement对象"></a>Statement对象</h3><p>用于将SQL语句发送到数据库中，JDBC API中主要提供了三种Statement对象</p><ul><li>Statement</li></ul><p>用于执行不带参数的简单SQL语句</p><p>SQL语句通过拼接字符串来实现，该方式效率比较低，系统会自动将该字符串定义为StringBuilder，拼接时调用<code>append()</code>方法</p><ul><li>PreparedStatement</li></ul><p>用于执行带或者不带参数的SQL语句</p><p>SQL语句会预编译在数据库系统</p><p>执行速度快于Statement对象</p><ul><li>CallableStatement</li></ul><p>用于执行数据库存储过程的调用</p><p>实际开发中最常用的是PreparedStatement，其具有以下优点：</p><blockquote><p>1、性能比Statement高（拼接字符串效率较低）</p><p>2、参数化SQL查询</p><p>3、占位符不能使用多值，占位符下标从1开始</p><p>4、SQL预编译</p><p>5、阻止常用SQL注入攻击</p></blockquote><p><strong>SQL两种执行方法：</strong></p><p>方法执行后返回单个结果集的，通常用于select语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executeQuery()</span><br></pre></td></tr></table></figure><p>方法返回值是一个整数，指示受影响的行数，通常用于update、insert、delete</p><h3 id="ResultSet对象"><a href="#ResultSet对象" class="headerlink" title="ResultSet对象"></a>ResultSet对象</h3><p>ResultSet对象被称为结果集，表示符合SQL语句执行结果的所有行，并且提供了一套<code>getXXX()</code>方法提供了对这些行中数据的访问。ResultSet就像一个迭代器，其所指的数据行叫做当前数据行。</p><p>取得某一条记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet.next()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在的应用系统大多都离不开数据库，而Java程序访问数据库的基本方式是通过JDBC。&lt;/p&gt;
&lt;p&gt;Java Database Connectivity，Java数据库连接。&lt;/p&gt;
&lt;p&gt;用于执行SQL语句的Java API&lt;/p&gt;
&lt;p&gt;JDBC使用流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JDBC/%E6%8D%95%E8%8E%B7.PNG&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://www.bingoxin.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="http://www.bingoxin.top/2018/12/16/%E8%BF%9B%E7%A8%8B/"/>
    <id>http://www.bingoxin.top/2018/12/16/进程/</id>
    <published>2018-12-16T12:03:24.000Z</published>
    <updated>2018-12-17T12:04:18.854Z</updated>
    
    <content type="html"><![CDATA[<h3 id="冯诺依曼体系结构"><a href="#冯诺依曼体系结构" class="headerlink" title="冯诺依曼体系结构"></a>冯诺依曼体系结构</h3><ul><li>组成</li></ul><p>包括输入单元、输入设备、存储器、运算器、控制器、输出单元、输出设备</p><p>存储器更多指的是内存</p><ul><li>关于冯诺依曼</li></ul><p>a.CPU只能对内存进行读写，不能访问外设</p><p>b.外设要读入或输出数据，只能写入内存或者从内存中读取，即所有外设只能和内存打交道</p><a id="more"></a><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li>概念</li></ul><p>操作系统包括：内核(进程管理、内存管理、文件管理、驱动管理)和其他程序(函数库、shell程序等)</p><ul><li>设计操作系统的目的</li></ul><p>a.与硬件交互，管理所有的软件和硬件</p><p>b.为用户提供一个良好的执行环境</p><ul><li>管理的概念</li></ul><p>即先将被管理对象描述起来，再将被管理对象组织起来</p><p>假如硬盘中存着一个程序，对程序进行编译后会生成一个可执行文件，而这个可执行文件就会加载到内存中供操作系统读取，但在内存中的仅仅是代码和数据。一个程序会生成一个进程，那么在操作系统中就会维护一个结构体(PCB)，结构体中该程序的属性。操作系统中不只有一个进程，那么就会产生多个结构体，为了方便管理，使用链表来将这些结构体连接起来，这是操作系统只需要知道该链表的头结点。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程之间是互相<strong>独立</strong>的，虽然代码有可能相同，但是各个进程都在维护各自的数据，因此进程之间是互不干扰的</p><ul><li>进程的控制块—PCB</li></ul><p>PCB包含一些字段，字段中包含程序的数据</p><ul><li>进程的字段</li></ul><p>pid（唯一标识符）、优先级、状态、</p><ul><li>进程的状态</li></ul><p>在不同的操作系统中，进程的状态是不同的</p><blockquote><ul><li><p><strong>R</strong>(unning)—可执行状态</p></li><li><p><strong>S</strong>(leep)—休眠状态</p></li><li><p><strong>T</strong>(stop)—停止状态</p></li><li><p><strong>D</strong>(isk sleep)—深度睡眠，不会被杀死</p></li><li><p><strong>X</strong>(dead)—死亡状态</p></li><li><p><strong>Z</strong>(zombie)—僵尸状态(进程已经退出，但仍保留该进程的信息，僵尸进程过多会导致内存泄漏问题)</p></li></ul></blockquote><ul><li>进程并发—进程间切换</li></ul><p>在一段时间内，多个进程在同一个CPU下采用进程切换的方式进行，让多个进程都得以推进</p><ul><li>进程并行</li></ul><p>同一时刻，多个进程在多个CPU下分别进行</p><ul><li>硬件上下文</li></ul><p>进程在运行期间在CPU寄存器上产生的数据</p><p>切换的时候将数据保存，返回时被恢复</p><p>硬件上下文被保存在PCB中</p><ul><li>查看进程的两种方式</li></ul><p>1.ps axj</p><p>2.查看proc目录</p><ul><li>获取pid的方法</li></ul><p>有pid就能实现进程调度</p><p><strong>获取当前进程pid：</strong> <code>getpid()</code></p><p><strong>获取父进程pid：</strong> <code>getppid()</code></p><ul><li>外壳程序</li></ul><p>操作系统通过外壳向用户传输数据，用户通过外壳向操作系统输入数据</p><blockquote><p>Windows系统的外壳是：窗口界面</p><p>Linux系统的外壳是：终端命令行</p></blockquote><p>shell：外壳程序的统称</p><p>bash（命令行解释器）：本身就是进程，为Linux系统下的父进程，可以创建子进程</p><ul><li>创建子进程</li></ul><p>关键字：fork（系统调用）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> id = fork();  <span class="comment">//当id = 0时，表示创建子进程成功，当id &gt; 0时，表示正在进行父进程，id为子进程的pid</span></span><br></pre></td></tr></table></figure><p>fork之后创建的子进程的代码是从父进程继承来的，即代码时共享的，但数据时各自私有的（写时拷贝）。因为代码是相同的，子进程的PCB中的内容大部分是和父进程PCB中的内容是一样的</p><ul><li>孤儿进程</li></ul><p>父进程提前退出，而子进程还在，子进程就会被1号进程领养，即子进程的ppid = 1</p><ul><li>修改进程</li></ul><p>关键字：kill</p><p>查看kill手册：<code>kill -l</code></p><h3 id="进程的优先级（PRI）"><a href="#进程的优先级（PRI）" class="headerlink" title="进程的优先级（PRI）"></a>进程的优先级（PRI）</h3><ul><li>取值范围：60~99</li></ul><p><strong>优先级值越小越早被执行，值越小进程优先级越高</strong></p><ul><li><strong>查看优先级命令：</strong>ps -l</li></ul><p>操作系统会在链表中找优先级最高的进程，只要该程序的状态是非r状态，操作系统将其对应的代码块放在CPU上执行</p><p>由于可能同时进行多个进程，若挨个查找链表中的结构体会浪费太多时间，则操作系统会有两条链表，一条用于存放r状态的进程（可执行队列），一条用于存放非r状态的进程</p><ul><li><strong>修正值nice</strong></li></ul><p>取值范围：-20~19</p><p>PRI（new） =PRI（OLD）+nice(修正值)</p><ul><li><strong>renice</strong>—修改nice的值</li></ul><p><code>sudo renice 修改值 -p pid</code> </p><ul><li><strong>nice</strong>—在进程开始进行时，指明优先级</li></ul><p><code>sudo nice -n 修改值</code></p><ul><li><strong>top</strong></li></ul><p>输入top-&gt;按 r-&gt;输入进程pid-&gt;输入nice值</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul><li>概念</li></ul><p>在操作系统中，用来指定操作系统运行环境的一些参数</p><ul><li>常见环境变量</li></ul><blockquote><p>PATH:命令搜索路径</p><p>HOME:指定用户的主工作目录</p><p>HISTSIZE:保存历史命令记录的条数</p><p>SHELL:当前shell，通常是bash</p></blockquote><p>ls是一个环境变量，它是一个二进制可执行程序，之所以它可以在任何路径下都可以使用，是因为它是被放在PATH下，PATH是什么呢？这是你可以在操作系统中输入<code>echo $PATH</code>你会得到一串路径，也就是说，当你把可执行文件放在这一串路径中的其中一个里，这个可执行文件就可以在任何路径下执行。</p><ul><li>如何让一个可执行文件可以在任何路径下都可以执行呢</li></ul><p>a.把可执行文件放在PATH中的一个路径下</p><p>b.将可执行文件的路径放在PATH中，使用命令<code>PATH=$PATH:可执行文件所在路径</code></p><h3 id="程序的地址空间"><a href="#程序的地址空间" class="headerlink" title="程序的地址空间"></a>程序的地址空间</h3><ul><li>虚拟地址空间</li></ul><p>每个进程都会创建一个PCB，每个PCB都会指向一个虚拟地址空间</p><ul><li>物理内存</li></ul><p>进程的代码和数据最终被写在物理内存中</p><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>目前所接触到创建进程的方式有两种：使用fork()函数、执行一个程序</p><p>当一个进程被创建时，操作系统会为该进程维护一个结构体（PCB），PCB中有该进程的属性。而每个PCB都会指向一个虚拟地址空间，虚拟地址空间中保存着进程的代码和数据。当一个进程和其子进程同时开始运行时，操作系统会为这两个进程维护一个数据结构—叫做页表，页表的功能是：将虚拟地址空间里的内容映射到物理内存中去。而此时，物理内存中就会有进程的代码和数据由于两个进程的代码是共享的，因此在物理内存中两个进程的代码映射区相同，而其数据不同。这也就是<strong>写时拷贝</strong>。</p><h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><p>退出的情况共有三种：代码运行完毕且结果正确，代码执行完毕但结果不对，代码异常终止</p><ul><li>判断结果是否正确</li></ul><p>使用<code>echo $?</code>，查看进程退出码</p><p>可以使用的方法:<code>_exit()</code>、<code>exit()</code>、return</p><ul><li><code>_exit()</code></li></ul><p><code>void _exit(int status)</code>status定义了进程终止状态，父进程可以通过<code>wait()</code>来获取该值（status只有低八位可以被父进程使用）</p><ul><li><code>exit()</code></li></ul><p>也可以结束进程，与<code>_exit()</code>的区别是：<code>exit()</code>会关闭流和刷新缓冲区，<code>_exit()</code>直接将进程关闭</p><p>进程终止时，释放数据结构，保留PCB中的数据，那么此时进程的状态就为僵尸进程</p><h3 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h3><p>若父进程不管理子进程，子进程若编程僵尸进程，这是父进程就没办法将该进程kill掉，从而造成内存泄漏。父进程需要知道子进程是否正常退出，而进程的退出有三种，又该如何判断呢？</p><ul><li><code>wait()</code></li></ul><p><code>pid_t wait(int* status)</code></p><p>若该进程成功结束，则返回该进程的pid，否则返回-1</p><p>参数为子进程退出状态</p><ul><li><code>waitpid()</code></li></ul><p><code>pid-t waitpid(pid_t pid,int* status,int options)</code></p><p>正常返回时，返回子进程的pid</p><ul><li><p>status</p><p>status的低八位为进程的退出码，第七位为该进程的结束信号，当退出信号为0，说明代码执行完但结果不对</p></li></ul><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><ul><li>概念</li></ul><p>守护进程是在后台运行的一种特殊进程，独立于控制终端且周期性的执行任务或等待处理任务，则守护进程不受用户登录注销的影响。</p><ul><li>守护进程经常采用以d结尾的名字</li><li>TPGID一栏写着-1的都是守护进程</li></ul><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;冯诺依曼体系结构&quot;&gt;&lt;a href=&quot;#冯诺依曼体系结构&quot; class=&quot;headerlink&quot; title=&quot;冯诺依曼体系结构&quot;&gt;&lt;/a&gt;冯诺依曼体系结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;组成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;包括输入单元、输入设备、存储器、运算器、控制器、输出单元、输出设备&lt;/p&gt;
&lt;p&gt;存储器更多指的是内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于冯诺依曼&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;a.CPU只能对内存进行读写，不能访问外设&lt;/p&gt;
&lt;p&gt;b.外设要读入或输出数据，只能写入内存或者从内存中读取，即所有外设只能和内存打交道&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.bingoxin.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>求1+2+3+...+n</title>
    <link href="http://www.bingoxin.top/2018/10/09/%E6%B1%821-2-3-n/"/>
    <id>http://www.bingoxin.top/2018/10/09/求1-2-3-n/</id>
    <published>2018-10-09T12:08:00.000Z</published>
    <updated>2018-12-21T12:08:43.252Z</updated>
    
    <content type="html"><![CDATA[<p>今天做了一道面试题，题目描述如下：</p><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><a id="more"></a><p>看到这道题，题目要求不能用循环，我首先想到的是用递归。</p><p>于是我想到了如下解法：</p><pre><code>class Solution {public:    int Sum_Solution(int n) {        int ret = n;        if(n &gt; 0)            ret += Sum_Solution(n-1);        return ret;    }};</code></pre><p>我又看了一下别人的程序：</p><pre><code>class Solution {public:    int Sum_Solution(int n) {        int ret = n;        bool choose = ((n&gt;0)&amp;&amp;((ret += Sum_Solution(n-1)) &gt; 0));        return ret;    }};</code></pre><p>感叹一下，这个短路与用的真是巧妙~</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天做了一道面试题，题目描述如下：&lt;/p&gt;
&lt;p&gt;求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://www.bingoxin.top/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>初识Java</title>
    <link href="http://www.bingoxin.top/2018/09/20/%E5%88%9D%E8%AF%86Java/"/>
    <id>http://www.bingoxin.top/2018/09/20/初识Java/</id>
    <published>2018-09-20T12:06:27.000Z</published>
    <updated>2018-12-20T12:07:12.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>首先说一下Java的源文件</p><p>Java源文件的格式是：文件名.java，以此来保存原始java代码</p><p>Java是一种半解释半编译语言</p><p><strong>编译过程：</strong></p><p>输入命令javac 要编译的源文件，生成.class 文件（二进制文件），来给JVM阅读的，启动JVM小虚拟机</p><p>若源文件中有汉字，编译命令需使用：</p><pre><code>javac -encoding UTF-8 文件名.java</code></pre><p><strong>解释过程：</strong></p><p>输入命令：java 主类名</p><p>若要给主类中默认参数赋值，在解释过程中使用</p><pre><code>java 主类名 参数1 参数2 ... </code></pre><a id="more"></a><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote><p>a.单行注释：//</p><p>b.多行注释: /<em> </em>/</p><p>c.文档注释：/*<em> </em>/ (用于方法与类之上描述其作用)</p></blockquote><h3 id="标识符、类与常量的命名"><a href="#标识符、类与常量的命名" class="headerlink" title="标识符、类与常量的命名"></a>标识符、类与常量的命名</h3><ul><li>标识符命名</li></ul><blockquote><p>a.java指定的标识符由字母、字符和_组成，不能用数字开头，不能使用java中的关键字</p><p>b.标识符采用有意义的简单命名</p><p>c.对于变量和方法，标识符由多个单词组成，采用驼峰命名，即第一个单词的首字母小写，第二个之后的单词首字母大写。</p></blockquote><ul><li>类的命名</li></ul><p>类名以大写字母开头，如果类名由多个单词组成，则每个单词首字母大写。</p><p>Java源文件文件名必须与公共类(public class)的名称相同。</p><ul><li>常量命名</li></ul><p>全大写，多个单词以_连接</p><h3 id="数据类型划分"><a href="#数据类型划分" class="headerlink" title="数据类型划分"></a>数据类型划分</h3><ul><li>基本数据类型：(8大基本数据类型)</li></ul><p>数值型：</p><pre><code>整型：byte(-128~127)、short、int(-2^31~2^31-1)、long(-2^63~2^63-1)(默认值是0)浮点型：double、float(默认值是0.0)</code></pre><p>字符型：</p><pre><code>char(默认值是\u0000)</code></pre><p>布尔型：</p><p>表示真假用true和false</p><pre><code>boolean(默认值是false)</code></pre><ul><li><p>引用数据类型</p><p>数组、类、接口(默认值为null)</p></li></ul><p>数据类型使用：</p><blockquote><p>a.描述整数就用int，描述小数就用double</p><p>b.long一般用于描述日期、时间、内存或者文件大小</p><p>c.编码转换或者二进制流的操作使用byte</p><p>d.char一般用于描述中文(基本忽略)</p></blockquote><p>在java程序中，任何一个整型常量都是int类型</p><p>在java中声明一个long类型的常量，要在数字后加上L或l</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>大数据类型与小数据类型做数据类型运算时，小的数据类型会自动转换成大的数据类型，无需强转</p><p>大的数据类型类型转为小的数据类型必须强转，可能会丢失内容</p><p>强转一定是从大的数据类型到小的数据类型</p><p><strong>byte与int类型转换：</strong></p><p>整型常量赋值给byte变量时，若常量值在byte类型保存范围内可以直接赋值无须强转；整型变量无论是否在byte类型的保存范围中，一律需要强转</p><p><strong>注意：</strong></p><p>小数默认类型为double类型，要声明float类型，需要在浮点数常量后加f或F</p><p>所有数据类型的默认值必须结合类来观察，主方法中不存在默认值</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;p&gt;首先说一下Java的源文件&lt;/p&gt;
&lt;p&gt;Java源文件的格式是：文件名.java，以此来保存原始java代码&lt;/p&gt;
&lt;p&gt;Java是一种半解释半编译语言&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入命令javac 要编译的源文件，生成.class 文件（二进制文件），来给JVM阅读的，启动JVM小虚拟机&lt;/p&gt;
&lt;p&gt;若源文件中有汉字，编译命令需使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;javac -encoding UTF-8 文件名.java
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;解释过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入命令：java 主类名&lt;/p&gt;
&lt;p&gt;若要给主类中默认参数赋值，在解释过程中使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java 主类名 参数1 参数2 ... 
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>线程</title>
    <link href="http://www.bingoxin.top/2018/09/17/%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.bingoxin.top/2018/09/17/线程/</id>
    <published>2018-09-17T12:04:43.000Z</published>
    <updated>2018-12-18T12:05:38.373Z</updated>
    
    <content type="html"><![CDATA[<p>当多个PCB指向同一块虚拟地址空间时，这些PCB的资源是共享的，而该PCB被称为一个线程。但是对于CPU来说，是没有办法判断一个PCB是一个进程还是线程。每个PCB都是小于等于一个进程的，则将Linux中的一个进程是一个轻量级进程，这也就可以看出：在Linux下，没有真正意义的线程，线程使用进程模拟出来的。</p><a id="more"></a><p>由以上描述可以发现，在Linux下，进程是承担分配系统资源的基本单位，是由一个执行流、虚拟地址空间、页表和映射关系组成的。线程是调度的基本单位，由多个执行流、一个虚拟地址空间、页表和映射关系组成的。那么在Linux中，就没有进程和线程的区别，则线程称为轻量级进程。</p><h3 id="线程的优点"><a href="#线程的优点" class="headerlink" title="线程的优点"></a>线程的优点</h3><blockquote><p>1.创建一个线程要比创建一个进程的代价小的多</p><p>2.与进程相比线程切换的工作量要小的多</p><p>3.线程占用的资源比较小</p><p>4.线程可以并行</p></blockquote><h3 id="线程的缺点"><a href="#线程的缺点" class="headerlink" title="线程的缺点"></a>线程的缺点</h3><blockquote><p>1.性能缺失</p><p>2.健壮性降低</p><p>3.缺乏访问控制</p><p>4.编程难度提高</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当多个PCB指向同一块虚拟地址空间时，这些PCB的资源是共享的，而该PCB被称为一个线程。但是对于CPU来说，是没有办法判断一个PCB是一个进程还是线程。每个PCB都是小于等于一个进程的，则将Linux中的一个进程是一个轻量级进程，这也就可以看出：在Linux下，没有真正意义的线程，线程使用进程模拟出来的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.bingoxin.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的开发工具</title>
    <link href="http://www.bingoxin.top/2018/09/06/Linux%E4%B8%AD%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.bingoxin.top/2018/09/06/Linux中的开发工具/</id>
    <published>2018-09-06T12:01:47.000Z</published>
    <updated>2018-12-16T12:02:32.465Z</updated>
    
    <content type="html"><![CDATA[<p>使用Linux，免不了和开发工具打交道，开发工具都有哪些呢？</p><a id="more"></a><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>说起文本编辑器，大家首先想到的应该就是vim了，毕竟只要打开一个文本都需要的它</p><p>你的vim可能什么特殊功能都没有</p><p>接下来看一下有关于vim的配置吧~</p><h4 id="首先输入命令"><a href="#首先输入命令" class="headerlink" title="首先输入命令"></a>首先输入命令</h4><pre><code>su  </code></pre><p>这时需要输入密码，将权限切换到root权限</p><h4 id="输入以下指令"><a href="#输入以下指令" class="headerlink" title="输入以下指令"></a>输入以下指令</h4><pre><code>cd ~cd /etcvim vimrc</code></pre><p>进入到vimrc的文本编辑</p><h4 id="在最后一行加入"><a href="#在最后一行加入" class="headerlink" title="在最后一行加入"></a>在最后一行加入</h4><pre><code>set nuset tabstop=4set cursorline</code></pre><p>即可更改vim的配置，三条语句的作用一次是</p><blockquote><p>在左侧添加行号</p></blockquote><blockquote><p>tab键的空格数，赋值为4，即一个tab键等于4个空格</p></blockquote><blockquote><p>标识当前行</p></blockquote><p>在Linux下，还有Emacs、Sublime Text、Lime、Atom等</p><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>Linux中常见的编译器就是gcc</p><p>gcc是C语言编译器</p><blockquote><p>-c 只编译子程序</p><p>-o 产生目标文件</p><p>-g 附加调试信息</p></blockquote><p>例如，<strong>test.c的编译过程</strong></p><p>gcc -E test.c   预处理  会生成临时文件test.i</p><p>gcc -S test.i -o test.s  生成汇编代码  会生成临时文件test.s</p><p>gcc -c test.s -o test.o  生成二进制文件  会生成临时文件test.o</p><p>gcc -o test test.o  进行链接操作  会生成可执行文件test</p><h3 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h3><p>GDB是一个调试程序的调试器</p><p>GDB可以调试C、C++等</p><h3 id="make与makefile"><a href="#make与makefile" class="headerlink" title="make与makefile"></a>make与makefile</h3><p>我们在编译一个C文件后，会产生一个a.out文件，这是一个可执行的二进制文件，若要执行文件，使用./a.out即可</p><p>注意：make不是编译器</p><h4 id="make与makefile的区别："><a href="#make与makefile的区别：" class="headerlink" title="make与makefile的区别："></a>make与makefile的区别：</h4><p>make是一条命令，makefile是一个文件</p><h4 id="makefile的编写"><a href="#makefile的编写" class="headerlink" title="makefile的编写"></a>makefile的编写</h4><p>在讲makefile的撰写之前，先来解释两个名词—依赖关系、依赖方法</p><p><strong>依赖关系</strong>可以看做是两个文件确定之间的关系</p><p><strong>依赖方法</strong>可以看做是两个文件的关系实现的过程</p><ul><li>makefile中放依赖方法和依赖关系</li><li>makefile中可以只有依赖方法</li><li>makefile中依赖方法要以Tab键开头</li></ul><p>例如：</p><pre><code>test:test.c    gcc -o test test.c.THONY:clean clean:    rm -f test</code></pre><p>test:test.c  是依赖关系</p><p>gcc -o test test.c   是依赖方法</p><p>.THONY clean  中的clean是一个伪目标，凡是伪目标，都是总是被执行的；而非伪目标只有被修改时才能编译。</p><p>那么如何确定文件是否是被修改呢？</p><p>当然是看文件最后一次被修改的时间啦~</p><h4 id="make的使用"><a href="#make的使用" class="headerlink" title="make的使用"></a>make的使用</h4><p>每次修改完要编译的文件后，使用 make 命令，如上述makefile：会产生一个test文件，若要执行test.c，只需使用 ./test 即可执行。</p><p>若要执行伪目标，使用 make clean 命令即可</p><h3 id="yum工具—软件包管理器"><a href="#yum工具—软件包管理器" class="headerlink" title="yum工具—软件包管理器"></a>yum工具—软件包管理器</h3><p>yum是一种可以安装软件的工具</p><p>在linux环境下，安装有以下两种：</p><blockquote><p>源码安装：在网上会下载一些程序的源码，编译后就得到了可执行程序(使用make、make install命令)</p></blockquote><blockquote><p>软件包安装：有的人把软件编译好，做成软件包(就像Windows下的应用)</p></blockquote><p>在这里提一下，<strong>软件包和软件包管理器的关系就像APP和应用商店的关系</strong></p><p><strong>yum的使用</strong></p><ul><li><p>yum需要联网状态才能正常工作</p></li><li><p>安装或卸载程序需要sudo命令来权限提升</p><p>sudo yum 文件名//文件安装</p><p>sudo yum remove 文件名 //文件卸载</p></li><li><p>yum list可以罗列出所有的软件包，可以用grep筛选</p></li></ul><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Linux，免不了和开发工具打交道，开发工具都有哪些呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.bingoxin.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的权限</title>
    <link href="http://www.bingoxin.top/2018/09/03/Linux%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90/"/>
    <id>http://www.bingoxin.top/2018/09/03/Linux中的权限/</id>
    <published>2018-09-03T11:59:51.000Z</published>
    <updated>2018-12-15T12:00:47.033Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux下的用户"><a href="#Linux下的用户" class="headerlink" title="Linux下的用户"></a>Linux下的用户</h3><ul><li>超级用户—#</li></ul><p>可以在Linux系统下做任何事情</p><ul><li>普通用户—$</li></ul><p>在Linux下做有限的事情</p><a id="more"></a><h3 id="用户切换命令—su"><a href="#用户切换命令—su" class="headerlink" title="用户切换命令—su"></a>用户切换命令—su</h3><ul><li><code>su (root)</code></li></ul><p>由普通用户切换到root用户</p><ul><li><code>su user</code></li></ul><p>由root用户切换到普通用户</p><h3 id="文件类型区分"><a href="#文件类型区分" class="headerlink" title="文件类型区分"></a>文件类型区分</h3><p>在Windows下，文件类型的区分是由文件的后缀决定的，而在Linux下文件的后缀并不起决定性作用</p><p>输入<code>ll</code>，可以得到文件的属性，而第一列就是文件的类型</p><ul><li><p>以-开头为普通文件</p></li><li><p>以d开头为目录文件</p></li><li><p>以p开头为管道文件</p></li><li><p>以l开头为链接文件</p></li></ul><h3 id="Linux权限管理"><a href="#Linux权限管理" class="headerlink" title="Linux权限管理"></a>Linux权限管理</h3><ul><li>文件访问者</li></ul><blockquote><p>a.u—文件和目录的拥有者</p><p>b.g—文件和目录的所有者所在组的用户</p><p>c.o—其他用户</p></blockquote><p>输入<code>ll</code>命令后，除了第一列，其他九列三列为一组，代表拥有者、所属组和other的权限</p><blockquote><p>r–读</p><p>w–写</p><p>x–执行</p></blockquote><p>将权限看做一列，第三列是文件的拥有者，第四列是文件的所属组</p><ul><li>权限修改</li></ul><p><strong>单个权限修改</strong></p><p><code>chmod 访问者 +/- 权限 文件名</code>将文件的访问者某访问权限增加或取消</p><p><strong>多个权限修改</strong></p><p><code>chmod 访问者1 +/- 权限,访问者2 +/- 权限 文件名</code>将文件的多个访问者某访问权限增加或取消</p><p>或者将用二进制来表示访问者的权限，权限共有r/w/x，则r—4，w—2，x—1</p><p>例如：</p><p><code>chmod 777 文件名</code>给所有的访问者赋予所有权限</p><ul><li>修改文件的拥有者和所属组</li></ul><p><code>chown 访问者 文件名</code>将文件的拥有者或所属组进行修改，将普通用户转换为root用户时，需在命令前加sudo关键字</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linux下的用户&quot;&gt;&lt;a href=&quot;#Linux下的用户&quot; class=&quot;headerlink&quot; title=&quot;Linux下的用户&quot;&gt;&lt;/a&gt;Linux下的用户&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;超级用户—#&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以在Linux系统下做任何事情&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通用户—$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Linux下做有限的事情&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.bingoxin.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>STL的底层与应用</title>
    <link href="http://www.bingoxin.top/2018/08/28/STL%E7%9A%84%E5%BA%95%E5%B1%82%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>http://www.bingoxin.top/2018/08/28/STL的底层与应用/</id>
    <published>2018-08-28T11:06:53.000Z</published>
    <updated>2018-12-26T11:10:46.364Z</updated>
    
    <content type="html"><![CDATA[<p>STL是惠普实现的，其有多个版本，但都是在HP版本的基础上完成的</p><p>STL是C++的标准模板库，包括数据结构和算法的软件框架<a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>STL将常用的数据结构封装起来，在封装过程中使用了算法，使用方便</p><p>其具有通用、高效的特点 </p><h3 id="STL的六大组件"><a href="#STL的六大组件" class="headerlink" title="STL的六大组件"></a>STL的六大组件</h3><p>容器、适配器、迭代器、空间配置器、仿函数、算法</p><p>接下来我会从组件功能、组件实例和实例的底层实现等方面来对各组件进行讲解</p><h3 id="容器-vector、slist、array、deque等"><a href="#容器-vector、slist、array、deque等" class="headerlink" title="容器(vector、slist、array、deque等)"></a>容器(vector、slist、array、deque等)</h3><p>容器中数据的区间都是左闭右开的</p><p>容器分两种：线性和特殊线性结构</p><p>线性结构有：array、vector、slist、deque、string等</p><font color="red" size="3">vector</font><p>vector的底层是动态顺序表，底层结构：</p><div align="center"><br>    <img src="/images/posts/STL/vector.png" height="300" width="500"><br></div><p>由于vector是一段连续的空间，其迭代器被设计成一个原生态指针</p><p>在使用vector时要注意：包含其头文件<vector>并引入标准命名空间std</vector></p><p>其具体功能如下：</p><div align="center"><br>    <img src="/images/posts/STL/vector功能.png" height="500" width="500"><br></div><font color="red" size="3">list</font><p>list的底层是一个带头结点的双向单链表，底层结构：</p><div align="center"><br>    <img src="/images/posts/STL/单链表底层.png" height="300" width="500"><br></div><p>当集合需要大量的插入和删除时，考虑用list</p><p>list的迭代器需要其实现者自己提供</p><p>其具体功能如下：</p><div align="center"><br>    <img src="/images/posts/STL/list功能.png" height="500" width="500"><br></div><font color="red" size="3">deque</font><p>deque是一段假想的连续空间，是一个双端序列，可以实现动态的二维数组</p><p>deque的两端都可以进行插入和删除，其结构如下：</p><div align="center"><br>    <img src="/images/posts/STL/deque.png" height="400" width="600"><br></div><p>deque是分段连续空间，维护其连续的假象的是迭代器</p><p>若迭代器中的cur到了last的位置，即表示已到当前队列的边缘</p><p>在deque的底层，有中控器(map)记录每个队列的迭代器地址(node)，迭代器中有队列的初始位置(first)、末尾位置(last)以及当前指向位置(pur)</p><p>若创建的队列过多，中控器空间不足，则扩容中控器，新的中控器从中间开始存储迭代器(node)的地址</p><p>则deque底层实现如下：</p><div align="center"><br>    <img src="/images/posts/STL/deque底层实现.png" height="300" width="500"><br></div><p>deque的操作如下：</p><div align="center"><br>    <img src="/images/posts/STL/deque功能.png" height="300" width="500"><br></div><p>array的底层实现是静态顺序表</p><p>string也是静态顺序表，他是用来存放字符串的，而array是用来存放各种数据的</p><p>slist是带头结点的单链表</p><p>这些就不做详细讲解了</p><h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><p>仿函数是一个函数对象，即将一个类像函数一样使用</p><pre><code>class people{   public:      返回值类型 operator()(参数列表);   成员变量}；</code></pre><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>适配器是设计模式的一种，该模式的作用是将一个类的接口转换成用户希望的另一个接口</p><p>STL中适配器有三种：应用于容器的适配器、应用于迭代器的适配器、应用于仿函数的适配器</p><h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h4><p>stack和queue都是一种特殊的线性数据结构，其只能在固定端插入和删除</p><p>stack无法遍历，无begin(),end()</p><p>由于deque是双开口序列，则将其稍作改装就可以实现stack和queue</p><p>在使用priority_queue时，用户可以以任意次序将数据放进去，但是取出时，会以优先级高低取出</p><p>其以vector为底层结构，加上堆算法重新封装</p><h4 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h4><p>关联式容器是用键值对(&lt;key,value&gt;)来实现的</p><font color="red" size="3">键值对</font><p>键值对实际是一个结构体，该结构体具有两个字段，两个字段有着一一对应的关系</p><p>在其应用时</p><pre><code>pair&lt;key,value&gt;(key,value);make_pair(key,value);</code></pre><p>这两种形式都可以创建键值对，第一种是对模板类的实例化，第二种返回键值对</p><h5 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h5><p>序列式容器在查找数据时，时间复杂度为O(n)</p><p>而关联式容器map/multimap底层是由红黑树构成的</p><p>这就使得其在查找数据时时间复杂度变成了O(1)，提高了查找效率</p><font color="red" size="3">数据存储方式：</font><p>由于其底层是由红黑树构成的，则在插入变量时，会与key进行比较，则对红黑树进行中序遍历，会得到一个有序序列</p><h4 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h4><p>其底层实现也是红黑树</p><p>其与map的相同之处在于：底层结构都是红黑树</p><p>不同之处是：map中存放的是一个真正的键值对，而set中key与value相同</p><p>map与multimap,set与multiset之间的区别是map/set不可以存储重复的变量，可以去重，而multimap/multiset可以存放相同变量，只是单纯的排序</p><h4 id="unordered-map-unordered-multimap-unordered-set-unordered-multiset"><a href="#unordered-map-unordered-multimap-unordered-set-unordered-multiset" class="headerlink" title="unordered_map/unordered_multimap  unordered_set/unordered_multiset"></a>unordered_map/unordered_multimap  unordered_set/unordered_multiset</h4><p>unordered_map/unordered_multimap放置的内容是一个正常的键值对</p><p>而unordered_set/unordered_multiset放置的内容是key与value相同的键值对</p><p>其底层是由哈希桶实现的，则其的数据存放方式是无序的</p><font color="blue" size="3">map与unordered_map的区别：</font><blockquote><p>1.底层：map的底层是红黑树，unordered_map的底层是哈希桶</p></blockquote><blockquote><p>2.查找方式：map的查找效率高，为O(log2n)，而unordered_map的查找效率为O(n)</p></blockquote><blockquote><p>3.map是有序存放的，而unordered_map是无序放的</p></blockquote><blockquote><p>4.两者的应用场景不同</p></blockquote><blockquote><p>5.迭代器方式不同：map可以正向和反向遍历，而unordered_map只可以正向遍历</p></blockquote><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法有两种：与数据结构有关的算法(绑定在容器上的算法)和与数据结构无关的算法(通用算法)</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是一种设计模式，其实际上是一种行为类似于指针的对象，因此指针的功能迭代器都有</p><p>迭代器的实现只要在类中将指针的功能重载即可</p><p>迭代器的提供者就是容器的实现者</p><h3 id="空间管理"><a href="#空间管理" class="headerlink" title="空间管理"></a>空间管理</h3><h4 id="普通存放数据的原理"><a href="#普通存放数据的原理" class="headerlink" title="普通存放数据的原理"></a>普通存放数据的原理</h4><p>需要空间–&gt;new/new[]–&gt;申请空间、构造对象</p><p>new是将malloc重新封装的，使用一次malloc，在内存中除了会开辟所需空间外，还会额外开辟36个字节</p><p>结构如下图：</p><div align="center"><br>    <img src="/images/posts/STL/malloc.png" height="300" width="500"><br></div><p>通过这种形式管理空间可以防止越界访问</p><h4 id="普通方式存放数据的缺陷"><a href="#普通方式存放数据的缺陷" class="headerlink" title="普通方式存放数据的缺陷"></a>普通方式存放数据的缺陷</h4><blockquote><p>1.频繁的向系统索要小的内存块，会产生内存碎片</p></blockquote><blockquote><p>2.频繁的向系统索要小的内存块，产生额外开销，效率低</p></blockquote><blockquote><p>3.没有及时的释放空间，造成内存泄漏</p></blockquote><blockquote><p>4.空间不足时，无法获取空间</p></blockquote><h4 id="标准空间配置器"><a href="#标准空间配置器" class="headerlink" title="标准空间配置器"></a>标准空间配置器</h4><p>标准空间配置器只是将new,delete进行简单的封装，与我们平常使用的new和delete没太大区别</p><h4 id="重新设计空间配置器"><a href="#重新设计空间配置器" class="headerlink" title="重新设计空间配置器"></a>重新设计空间配置器</h4><p>重新设计空间配置器有一级空间配置器和二级空间配置器两种</p><p>重新设计空间配置器会根据用户索要空间的大小来选择空间配置器</p><font color="blue" size="3">一级空间配置器</font><p>当用户索要空间大于128个字节时，会使用一级空间配置器</p><p>一级空间配置器将malloc和free进行简单的封装</p><pre><code>void* allocate(字节数):malloc若空间充足，开辟空间成功，直接返回若空间不充足，开辟空间失败，启动空间不足应对措施(函数指针)allocate_OOM (字节数){   检测空间不足应对措施是否设置   是：malloc  //重新开辟空间   否:throw bad_alloc  //抛异常}//将空间归还系统void deallocate(void* p,size_t size){   free(p);}</code></pre><font color="blue" size="3">二级空间配置器</font><p>当用户索取空间小于128个字节时，会使用二级空间配置器</p><p>为了减少多次开辟空间造成的额外消耗，二级空间配置器会开辟一个很大空间作为内存池</p><p>同时会构造一个哈希表，其中会有128/8=16个结点，每个结点下面会挂(n+1)*8字节的内存块，构成哈希桶，以此来管理小的内存块</p><p>结构如下：</p><div align="center"><br>    <img src="/images/posts/STL/空间配置器.png" height="300" width="500"><br></div><p>空间管理如下：</p><pre><code>void* allocate(size_t size){   if(size&gt;128)       一级空间配置器   else   {       1.找size对应的哈希桶       2.检测该哈希桶有没有结点        有：将第一块内存给用户        没有：refill(size向上取整到8的整数倍，向当前链表中补充空间)   }}void* refill(size_t size){   1.通过chunk_alloc(objs,size)索要nobjs(20)个size个字节的内存块   2.nobjs = 1---&gt;返回----&gt;将一块内存返回给用户     20 &gt;= objs &gt; 1 ---&gt;将剩余的内存块挂在链表中}void* chunk_alloc(size_t&amp; nobjs,size_t size){   从内存池中索要空间     &gt;1.计算总共需要的字节数  totalBytes = nobjs*size     &gt;2.计算内存池中剩余的字节数  leftBytes =_endFree-_startFree;   if(leftByte&gt;=totalBytes)   {       提供20个内存块   }   else if (leftBytes&gt;=size)   {       nobjs=leftBytes/size;   }   else   {       0.把内存池剩余的元素处理掉(挂到对应的哈希桶中)       1.向系统索要空间补充内存池---&gt;成功---&gt;_startFree接受malloc的返回值---&gt;递归chunk_alloc()       2.如果1失败，从当前链表往后去找是否还有更大的内存块---&gt;找到了---&gt;补充到内存池---&gt;递归chunk_alloc()       3.使用一级空间配置器(内存不足应对措施)---&gt;递归chunk_alloc()   }}</code></pre><p>这种处理内存碎片的方式虽然解决了外部存在大量的内存碎片的问题，但是还是会有在哈希桶上挂的小碎片<br>​<br>可能有的地方叙述的不是很清楚，欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;STL是惠普实现的，其有多个版本，但都是在HP版本的基础上完成的&lt;/p&gt;
&lt;p&gt;STL是C++的标准模板库，包括数据结构和算法的软件框架
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.bingoxin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>数据库---数据类型</title>
    <link href="http://www.bingoxin.top/2018/08/20/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://www.bingoxin.top/2018/08/20/数据库-数据类型/</id>
    <published>2018-08-20T11:57:42.000Z</published>
    <updated>2018-12-15T11:58:53.114Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们需要明白一点：<strong>不同的码制一个字符是由不同个数字节组成的</strong></p><p>utf-8 一个字符1~4个字节，英文一个字符一个字节，汉字一个字符三个字节</p><p>GBK   一个字符两个字节 </p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><blockquote><p>char()、varchar()括号内是字符数</p></blockquote><blockquote><p>char()最大为256个<strong>字符</strong>—&gt;数据固定时使用—&gt;效率高</p></blockquote><blockquote><p>varchar是可变长度字符串，最多能放65535个<strong>字节</strong>—&gt;数据长度有变化时使用—&gt;效率低</p></blockquote><blockquote><p>—&gt;有1~2个字节用于存储存放数据的长度，实际上只有65532个字节存放数据</p></blockquote><h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><blockquote><p>datatime:日期+时间—&gt;‘yyyy-mm-dd HH:ii:ss’–&gt;</p></blockquote><blockquote><p>data:日期</p></blockquote><blockquote><p>timestamp:记录表中的最后更改时间</p></blockquote><p>current_timestamp：当前时间距1970-01-01 00:00:01差多少秒</p><h3 id="enum-枚举-和set-集合"><a href="#enum-枚举-和set-集合" class="headerlink" title="enum(枚举)和set(集合)"></a>enum(枚举)和set(集合)</h3><blockquote><p>enum:单选—&gt;数据库会自动将每个选项当做数字1,2,3,4…—&gt;用数字效率更高—&gt;最多存储65535个选项</p></blockquote><blockquote><p>set:多选—&gt;由于多个选项中用’选项1,选项2’表示，则须注意选项之间不要出现英文的逗号—&gt;数据库会自动将每个选项当做数字1,2,4,8…<br>—&gt;最多存储64个选项</p></blockquote><pre><code>select * from 数据库名 where find_in_set (&apos;其中选项&apos;,表名)</code></pre><h3 id="表的约束"><a href="#表的约束" class="headerlink" title="表的约束"></a>表的约束</h3><p>保证数据的合法性</p><ul><li>null/not null</li></ul><p>可以插入新的一条数据时，可以不为该属性赋值</p><ul><li>default</li></ul><p>默认值，用户可以选择性的使用默认值</p><ul><li>comment</li></ul><p>列描述，相当于注释</p><pre><code>create table t (a int comment &apos;注释&apos;);show create table t \G //查看列描述</code></pre><ul><li>zerofill</li></ul><p>零填充，将数据格式化，将无效位置零</p><ul><li>primary key</li></ul><p>主键，用来约束该字段里面的数据，<strong>不能重复，不能为空</strong>，一张表中最多只能有一个主键，主键所在列通常为整型类型</p><blockquote><p>复合主键:将某几个列构成一个主键</p></blockquote><pre><code>create table t (id int, course int ,score int,primary key(id,course));</code></pre><blockquote><p>追加主键:</p></blockquote><pre><code>alter table t add primary key (id);</code></pre><blockquote><p>删除主键:每个表只有一个主键，因此删除时不需要指定，若删除主键不会改变列not null性质</p></blockquote><pre><code>alter table t drop primary key;</code></pre><ul><li>auto_increment</li></ul><blockquote><p>自增长,当对应的字段不给值时，会自动的被系统触发，系统会从当前字段中已经有的最大值+1操作，得到新的不同的值，该字段只增不减。通常与主键搭配使用，作为逻辑主键。一张表中最多只能有一个自增长</p></blockquote><pre><code>create table t (id int primary key auto_increment,name char(13));</code></pre><ul><li>unique key</li></ul><blockquote><p>唯一键:可以使多个字段拥有唯一性，唯一键允许为空</p></blockquote><pre><code>create table t (id int primary key auto_increment comment &apos;编号&apos;,num in not null unique comment &apos;学号&apos;)</code></pre><ul><li>forigen key</li></ul><blockquote><p>外键:将主表和从表关联起来，外键约束主要定义在从表上，主表则必须是有主键约束或unique约束。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先我们需要明白一点：&lt;strong&gt;不同的码制一个字符是由不同个数字节组成的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;utf-8 一个字符1~4个字节，英文一个字符一个字节，汉字一个字符三个字节&lt;/p&gt;
&lt;p&gt;GBK   一个字符两个字节 &lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.bingoxin.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Python之面向对象</title>
    <link href="http://www.bingoxin.top/2018/08/18/Python%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.bingoxin.top/2018/08/18/Python之面向对象/</id>
    <published>2018-08-18T11:56:00.000Z</published>
    <updated>2018-12-02T11:56:49.446Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>抽象是指对现实世界问题和实体的本质表现，行为，特征进行建模</p><h3 id="对象的三要素"><a href="#对象的三要素" class="headerlink" title="对象的三要素"></a>对象的三要素</h3><p>id、type、value</p><h3 id="对象的三大特性"><a href="#对象的三大特性" class="headerlink" title="对象的三大特性"></a>对象的三大特性</h3><p>封装、继承、多态 </p><h3 id="封装和接口"><a href="#封装和接口" class="headerlink" title="封装和接口"></a>封装和接口</h3><p><strong>封装</strong></p><p>封装是对数据和信息进行隐藏，对象的使用者只能通过接口来访问或修改对象的数据</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>所有的类都继承于根类(object)</p><p><strong>根类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Animal(object):</span><br><span class="line"></span><br><span class="line">#静态变量</span><br><span class="line"></span><br><span class="line">    x=0 </span><br><span class="line"></span><br><span class="line">#非静态成员方法</span><br><span class="line"></span><br><span class="line">def Print(self):</span><br><span class="line"></span><br><span class="line">print &quot;print&quot; </span><br><span class="line"></span><br><span class="line">#非静态变量</span><br><span class="line"></span><br><span class="line">def __init__(self):</span><br><span class="line"></span><br><span class="line">self.Name=&quot;name&quot;</span><br><span class="line"></span><br><span class="line">self.Age=10</span><br><span class="line"></span><br><span class="line">#静态成员方法</span><br><span class="line"></span><br><span class="line">@staticmethod</span><br><span class="line"></span><br><span class="line">def Print1()</span><br><span class="line"></span><br><span class="line">print &quot;print1&quot;</span><br><span class="line"></span><br><span class="line">print Animal.x</span><br><span class="line"></span><br><span class="line">#类的实例化</span><br><span class="line"></span><br><span class="line">A=Animal()</span><br><span class="line"></span><br><span class="line">print A.Name,A.Age</span><br></pre></td></tr></table></figure><p>​    </p><p>根类中有静态变量、非静态成员方法，非静态变量、静态成员方法</p><p>非静态变量和方法要有self关键字</p><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Animal)</span><br></pre></td></tr></table></figure><p>Dog继承自Animal</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>子类可以进行自由扩展，对调用封闭</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;抽象&quot;&gt;&lt;a href=&quot;#抽象&quot; class=&quot;headerlink&quot; title=&quot;抽象&quot;&gt;&lt;/a&gt;抽象&lt;/h3&gt;&lt;p&gt;抽象是指对现实世界问题和实体的本质表现，行为，特征进行建模&lt;/p&gt;
&lt;h3 id=&quot;对象的三要素&quot;&gt;&lt;a href=&quot;#对象的三要素&quot; cl
      
    
    </summary>
    
    
      <category term="Python" scheme="http://www.bingoxin.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python中的文件操作</title>
    <link href="http://www.bingoxin.top/2018/08/14/Python%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.bingoxin.top/2018/08/14/Python中的文件操作/</id>
    <published>2018-08-14T11:52:56.000Z</published>
    <updated>2018-12-03T11:54:07.499Z</updated>
    
    <content type="html"><![CDATA[<p>读写缓冲区具体实现步骤？</p><p>文件指针？</p><a id="more"></a><h3 id="读写缓冲区"><a href="#读写缓冲区" class="headerlink" title="读写缓冲区"></a>读写缓冲区</h3><pre><code>f=open(&quot;文件名&quot;,&quot;w&quot;,&quot;开辟缓冲区字节数&quot;)flush()f.close()</code></pre><p>读写缓冲区具体实现步骤： </p><blockquote><p>flush刷新缓冲区</p></blockquote><blockquote><p>关闭文件写入</p></blockquote><blockquote><p>缓冲区满，则刷新缓冲区，将内容写入文件</p></blockquote><h3 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h3><p><strong>seek</strong></p><p>seek将文件指针移动到从文件开头、结尾或当前位置算起的字节处。共接受两个参数，第一个参数表示偏移量，第二个参数是偏移量的起始位置：0表示从文件开始处，1表示从当前位置，2表示从文件结尾</p><p><strong>tell</strong></p><p>获取当前文件指针指向的位置，返回当前位置到文件开头的偏移量</p><h3 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h3><pre><code>with open(&quot;test.txt&quot;) as f    print &apos;&apos;.join(f.readlines())</code></pre><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><p><strong>基于一个简单的文本构造大文本</strong></p><pre><code>#!/usr/bin/python#coding utf-8&apos;&apos;&apos;根据内容输入文件，构造一个大文本input.txt output.txt&apos;&apos;&apos;import sys#获取命令行参数#获取到内容输入文件的路径input_file_path=sys.argv[1]#输出文件的路径output_file_path=sys.argv[2]#获取构造文本的大小output_size =int(sys.argv[3])*1024*1024#打开内容输入文件input_file=open(input_file_path,&quot;r&quot;)#读取全部内容到input_data []input_data=input_file.readlines()#打开内容输出文件output_file=open(output_file_path,&quot;a+&quot;)#行数计数器count=0#当前文件大小while true:    if totol_size &gt; output_size:        break;       output_file.write(input_data[index % len(input_data)])    totl_size += len(input_data[index % len(input_data)])    index+=1</code></pre><p>ghjk</p><pre><code>#构造一个内容读取函数def Printscreen(f):#行数计数器line_num=0for line in f:print lineif line_num&gt;25breakline_num+=1path = sys.argv[1]f=open(path,&quot;r&quot;)while True:os.system(&quot;clear&quot;)Printscreen(f)command=input(&quot;:&quot;)if(command == q)break</code></pre><h3 id="打印文件名"><a href="#打印文件名" class="headerlink" title="打印文件名"></a>打印文件名</h3><p>import os</p><p>print os.path.basename(“文件路径”)</p><h3 id="打印文件目录"><a href="#打印文件目录" class="headerlink" title="打印文件目录"></a>打印文件目录</h3><p>print os.path.dirname(“文件路径”)</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读写缓冲区具体实现步骤？&lt;/p&gt;
&lt;p&gt;文件指针？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://www.bingoxin.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用指令</title>
    <link href="http://www.bingoxin.top/2018/08/12/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>http://www.bingoxin.top/2018/08/12/Linux常用指令/</id>
    <published>2018-08-12T11:50:35.000Z</published>
    <updated>2018-12-06T11:51:43.397Z</updated>
    
    <content type="html"><![CDATA[<ul><li>ls</li></ul><p>罗列出当前目录下的文件</p><p>-a 列出隐藏文件（.test）</p><ul><li>ll</li></ul><p>罗列出当前目录下所有文件的属性</p><ul><li>cd</li></ul><p>进入或退出路径</p><p>. 表示当前路径</p><p>..表示上级路径</p><ul><li>pwd</li></ul><p>打印当前位置的路径</p><ul><li>mv</li></ul><p>将一个文件移动到指定位置</p><ul><li>cp</li></ul><p>将一个文件赋值到指定位置</p><ul><li>cat</li></ul><p>打印出文档的内容</p><ul><li>tac</li></ul><p>倒着打印出文档的内容</p><ul><li>more</li></ul><p>打印出可以输出到当前屏幕文档内容，用回车键下翻，q键退出</p><ul><li>less</li></ul><p>打印出可以输出到当前屏幕文档内容，用上下键上下翻，q键退出</p><ul><li>grep</li></ul><p>有筛选功能，可以用来查找含有关键字的内容</p><p><code>grep &#39;关键字&#39; 路径</code></p><ul><li>head</li></ul><p>打印出文档前指定行数的内容</p><ul><li>tail</li></ul><p>打印出文档后指定行数的内容</p><ul><li>whoami</li></ul><p>打印出当前使用者姓名</p><ul><li>ps aux</li></ul><p>打印所有的进程</p><ul><li>top</li></ul><p>查看进程相关信息，相当于Windows下的任务管理器</p><ul><li>find</li></ul><p><code>find ~/bit-code/ -name test.c</code>查找在目标路径下文件名为test.c的文件</p><ul><li>halt</li></ul><p>关机命令，shutdown也可以</p><ul><li>echo</li></ul><p><code>echo &quot;内容&quot;</code>将指定内容打印出来</p><p><code>echo &quot;内容&quot; &gt; 文件名</code>将内容写进指定文件里   ”&gt;“为输出重定项</p><p><code>echo &quot;内容&quot;&gt;&gt;文件名</code>将指定内容追加进指定文件里   “&gt;&gt;”追加重定项</p><ul><li>|</li></ul><p>管道，用来连接两条命令，将左侧命令的输出作为右侧命令的输入</p><ul><li>file</li></ul><p>查看文件类型</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;ls&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;罗列出当前目录下的文件&lt;/p&gt;
&lt;p&gt;-a 列出隐藏文件（.test）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ll&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;罗列出当前目录下所有文件的属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cd&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进入
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://www.bingoxin.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Python中的模块和包</title>
    <link href="http://www.bingoxin.top/2018/08/11/Python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"/>
    <id>http://www.bingoxin.top/2018/08/11/Python中的模块和包/</id>
    <published>2018-08-11T11:48:03.000Z</published>
    <updated>2018-12-08T11:49:29.131Z</updated>
    
    <content type="html"><![CDATA[<p>为什么要有命名空间？</p><p>往下看吧~</p><a id="more"></a><p>sys.path.append(“文件所在路径”)</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>解决名字冲突问题</p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>顺序：先引入Python标准库、Python第三方库 </p><h3 id="import-from"><a href="#import-from" class="headerlink" title="import-from"></a>import-from</h3><p>from 模块名 import 方法</p><p>导入模块中的某一方法</p><p>from 模块名 import*</p><p>会导入模块中所有的方法，不可以导入模块中私有化变量，会提示未定义</p><h3 id="import-as"><a href="#import-as" class="headerlink" title="import as"></a>import as</h3><p>该语句的功能是为模块起一个别名</p><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p><strong>name</strong>是系统变量</p><p>当模块被直接使用时，<strong>name</strong>=<strong>main</strong></p><p>当模块被当做模块使用时，<strong>name</strong>=文件名去掉.py</p><h3 id="reload"><a href="#reload" class="headerlink" title="reload"></a>reload</h3><p>重新加载模块</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>把多个模块放在同一个目录下，该目录下要有<strong>init</strong>.py文件，只有有该文件，该目录才会被确认是包目录</p><p>zip文件也会被当做是包</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么要有命名空间？&lt;/p&gt;
&lt;p&gt;往下看吧~&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://www.bingoxin.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-异常</title>
    <link href="http://www.bingoxin.top/2018/08/11/Python-%E5%BC%82%E5%B8%B8/"/>
    <id>http://www.bingoxin.top/2018/08/11/Python-异常/</id>
    <published>2018-08-11T11:46:28.000Z</published>
    <updated>2018-12-11T11:47:18.118Z</updated>
    
    <content type="html"><![CDATA[<p>这是Python为我们设计的异常处理机制</p><a id="more"></a><h3 id="轻松地捕获和处理异常"><a href="#轻松地捕获和处理异常" class="headerlink" title="轻松地捕获和处理异常"></a>轻松地捕获和处理异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    print &quot;123&quot; + 4</span><br><span class="line">#捕获异常，加入处理机制</span><br><span class="line">except :</span><br><span class="line">    print 异常已处理</span><br></pre></td></tr></table></figure><p>若要知道该种类型异常是什么，可以通过以下方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    print &quot;123&quot; + 4</span><br><span class="line">#捕获异常，加入处理机制</span><br><span class="line">except Exception, e:</span><br><span class="line">    print e</span><br><span class="line">    print 异常已处理</span><br></pre></td></tr></table></figure><h3 id="捕获类型异常"><a href="#捕获类型异常" class="headerlink" title="捕获类型异常"></a>捕获类型异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    f=open(&quot;test.txt&quot;,&quot;r&quot;)</span><br><span class="line">#捕获异常，加入处理机制</span><br><span class="line">except TypeError,e:</span><br><span class="line">    print 异常已处理</span><br></pre></td></tr></table></figure><p>若不存在test.txt文件，则会出现IO异常，而不是Type异常，这样的话，如果我们只是捕获Type异常，代码是会终止的</p><p>dir(<strong>builtins</strong>)<br>Python</p><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    print &quot;line&quot;</span><br><span class="line">    print &quot;123&quot;+4</span><br><span class="line">except:</span><br><span class="line">    print &quot;出现异常&quot;</span><br><span class="line">finally:</span><br><span class="line">    print &quot;无论如何都会被执行的代码&quot;</span><br></pre></td></tr></table></figure><p>finally关键字下的代码行，无论是否出现异常都会执行</p><h3 id="自己定义异常"><a href="#自己定义异常" class="headerlink" title="自己定义异常"></a>自己定义异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def Div(x,y):</span><br><span class="line">    if y==0:</span><br><span class="line">        raise Exception(&quot;除数不能为0&quot;)#抛出自己设计的异常</span><br><span class="line">    else:</span><br><span class="line">        print x/y</span><br><span class="line">try:</span><br><span class="line">    print Div(10,0)</span><br><span class="line">except Exception,e:</span><br><span class="line">    print e</span><br><span class="line">    print type(e)</span><br></pre></td></tr></table></figure><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是Python为我们设计的异常处理机制&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://www.bingoxin.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>列表与字典的深度学习</title>
    <link href="http://www.bingoxin.top/2018/08/08/%E5%88%97%E8%A1%A8%E4%B8%8E%E5%AD%97%E5%85%B8%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.bingoxin.top/2018/08/08/列表与字典的深度学习/</id>
    <published>2018-08-08T11:42:08.000Z</published>
    <updated>2018-12-11T11:44:53.645Z</updated>
    
    <content type="html"><![CDATA[<h3 id="列表切片操作法进阶"><a href="#列表切片操作法进阶" class="headerlink" title="列表切片操作法进阶"></a>列表切片操作法进阶</h3><p>[start,stop,step]</p><blockquote><p>当step&lt;0时，为倒序 </p></blockquote><blockquote><p>当step&gt;0时，为顺序</p></blockquote><p>想知道更多就点开吧~</p><a id="more"></a><h3 id="枚举函数"><a href="#枚举函数" class="headerlink" title="枚举函数"></a>枚举函数</h3><p>枚举出序列所有下标及其对应的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enumerate()</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>原生字符串(r)</strong></p><p>原生字符串是没有转义字符的</p><p><strong>unicode</strong></p><p>是一种编码形式</p><p><strong>if语句</strong></p><p>if不只是局限于判断长度为1的字符串，而是可以判断任意一目标字符串的子字符串</p><h3 id="repr"><a href="#repr" class="headerlink" title="repr"></a>repr</h3><p>可以将整型、浮点类型转化为字符串</p><p>repr精度更高，转化成字符串相当于给解释器看有没有引号</p><h3 id="list的各类操作方法"><a href="#list的各类操作方法" class="headerlink" title="list的各类操作方法"></a>list的各类操作方法</h3><p><strong>append</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.append(&quot;追加字符串或列表&quot;)</span><br><span class="line"> </span><br><span class="line"># 在列表后追加内容，会生成新的列表</span><br></pre></td></tr></table></figure><p><strong>extend</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1.extend(list2)</span><br><span class="line"></span><br><span class="line"># 两个列表拼接，不会生成新的列表</span><br></pre></td></tr></table></figure><p><strong>remove</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1(5)</span><br><span class="line"></span><br><span class="line"># 删除指定位置的元素</span><br></pre></td></tr></table></figure><h3 id="列表的深拷贝和浅拷贝"><a href="#列表的深拷贝和浅拷贝" class="headerlink" title="列表的深拷贝和浅拷贝"></a>列表的深拷贝和浅拷贝</h3><blockquote><p>若采取直接赋值的方式，两个会变量会引用同一个对象，一个改变，另一个也会发生改变</p></blockquote><blockquote><p>在使用函数工厂时，只是生成了目标列表的一部分内容的列表，id不同</p></blockquote><blockquote><p>除非特殊声明，否则，所有行为都是浅拷贝</p></blockquote><blockquote><p>在拷贝列表时，简单元素会采取深拷贝的方式，复杂元素会采取浅拷贝的方式</p></blockquote><p>在这里就要提一下深拷贝的函数：</p><p><strong>deepcopy</strong></p><p>在使用该函数时，需调用copy模块</p><p>采用深拷贝，无论是简单元素还是复杂元素都会新建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy.deepcopy()</span><br></pre></td></tr></table></figure><h3 id="判断两个字典是否相同"><a href="#判断两个字典是否相同" class="headerlink" title="判断两个字典是否相同"></a>判断两个字典是否相同</h3><p>由于字典比较复杂，所以在判断两个字典是否相同时，系统会按照长度、key和value的顺序对两字典进行比较</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;列表切片操作法进阶&quot;&gt;&lt;a href=&quot;#列表切片操作法进阶&quot; class=&quot;headerlink&quot; title=&quot;列表切片操作法进阶&quot;&gt;&lt;/a&gt;列表切片操作法进阶&lt;/h3&gt;&lt;p&gt;[start,stop,step]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当step&amp;lt;0时，为倒序 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;当step&amp;gt;0时，为顺序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想知道更多就点开吧~&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://www.bingoxin.top/tags/Python/"/>
    
  </entry>
  
</feed>
