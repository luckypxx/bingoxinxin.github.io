<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bingoxin&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.bingoxin.top/"/>
  <updated>2019-01-04T12:21:13.753Z</updated>
  <id>http://www.bingoxin.top/</id>
  
  <author>
    <name>bingoxin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊天室项目</title>
    <link href="http://www.bingoxin.top/2019/01/04/%E8%81%8A%E5%A4%A9%E5%AE%A4%E9%A1%B9%E7%9B%AE/"/>
    <id>http://www.bingoxin.top/2019/01/04/聊天室项目/</id>
    <published>2019-01-04T07:27:52.000Z</published>
    <updated>2019-01-04T12:21:13.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p><strong>Scoket类</strong></p><ul><li>绑定指定域名、端口号的服务器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Socket</span><span class="params">(String host, <span class="keyword">int</span> port, InetAddress localAddr,<span class="keyword">int</span> localPort)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>获取客户端输入流，读取服务器发来的消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>获取客户端输出流，向服务器发送消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> OutputStream <span class="title">getOutputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><h4 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h4><ul><li>默认绑定本地IP：127.0.0.1，以及指定端口号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>等待客户端连接，线程阻塞，当有客户连接时，返回客户端socket</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Socket <span class="title">accept</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>当服务器与客户端建立起连接后，通过输入输出流（客户端的Scoket）来通信</p><ul><li>获取服务器端输入流，读取客户端发来的消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>获取服务器端输出流，向客户端发送消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> OutputStream <span class="title">getOutputStream</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="简单版的单线程聊天"><a href="#简单版的单线程聊天" class="headerlink" title="简单版的单线程聊天"></a>简单版的单线程聊天</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;常用函数&quot;&gt;&lt;a href=&quot;#常用函数&quot; class=&quot;headerlink&quot; title=&quot;常用函数&quot;&gt;&lt;/a&gt;常用函数&lt;/h3&gt;&lt;h4 id=&quot;客户端&quot;&gt;&lt;a href=&quot;#客户端&quot; class=&quot;headerlink&quot; title=&quot;客户端&quot;&gt;&lt;/a&gt;客户
      
    
    </summary>
    
    
      <category term="项目" scheme="http://www.bingoxin.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://www.bingoxin.top/2019/01/03/JVM/"/>
    <id>http://www.bingoxin.top/2019/01/03/JVM/</id>
    <published>2019-01-03T13:10:46.000Z</published>
    <updated>2019-01-05T04:18:45.800Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机是通过软件模拟的具有完整硬件功能，运行在完全隔离环境中的计算机系统。</p><p>使用最多的是VMWare和Virtual Box。</p><p>JVM是通过软件<strong>模拟Java字节码指令集</strong>，JVM只保留了PC寄存器，而普遍的虚拟机有很多寄存器。</p><p>做JVM的公司有很多家，从<strong>JDK1.3</strong>开始，HotSpot为默认JVM。</p><p>JVM上<strong>不止可以运行Java的代码</strong></p><a id="more"></a><h3 id="JVM内存区域划分"><a href="#JVM内存区域划分" class="headerlink" title="JVM内存区域划分"></a>JVM内存区域划分</h3><p>Java内存区共分为6块内存</p><h4 id="线程私有内存"><a href="#线程私有内存" class="headerlink" title="线程私有内存"></a>线程私有内存</h4><p>每个线程都有，并且彼此之间相互隔离</p><ul><li>程序计数器</li></ul><p>程序计数器是比较小的内存空间，记录当前线程所执行的字节码的行号指示器。</p><p><strong>程序计数器记录的两种情况：</strong></p><p>1、若当前的线程执行的是Java方法，程序计数器记录的是正在执行的JVM字节码指令地址</p><p>2、若当前的执行线程执行的是Native方法，计数器值为空（监测不到C语言）</p><p>程序计数器是<strong>唯一一块不会产生OOM异常</strong>的区域</p><ul><li>虚拟机栈</li></ul><p>虚拟机栈描述Java<strong>方法</strong>执行的<strong>内存</strong>模型。</p><p>每个方法执行的同时，都会创建一个栈桢来存储<strong>局部变量表、操作数栈、方法出口</strong>等信息。每个方法从调用直到执行完毕的过程，对应一个栈桢在虚拟机栈的入栈和出栈过程。</p><p><strong>局部变量表存放内容：</strong>8种基本数据类型和对象引用（4个字节），因此每次开辟虚拟机栈的大小是确定的。</p><p>生命周期与线程相同：在创建线程时，同时创建线程的虚拟机栈。在线程执行完毕时，虚拟机栈也被一同回收。</p><p><strong>此区域一共会产生两种异常：</strong></p><p>1、若线程请求的栈深度大于JVM允许的深度（-Xss设置栈容量），抛出<code>StackOverFlowError</code>异常。常见于单线程</p><p>2、虚拟机在进行栈的动态扩展时，若无法申请到足够内存，抛出OOM（<code>OutOfMemoryError</code>）异常。常见于多线程</p><ul><li>本地方法栈</li></ul><p>本地方法（<code>Native</code>方法）执行的内存模型</p><p>在<strong>HotSpot虚拟机</strong>中，本地方法栈与虚拟机栈是同一块内存区域。</p><h4 id="线程共享内存"><a href="#线程共享内存" class="headerlink" title="线程共享内存"></a>线程共享内存</h4><p>所有线程共享此内存空间，并且此内存空间<strong>对所有线程可见</strong></p><ul><li>堆（GC堆）</li></ul><p>Java堆是JVM管理的最大内存区域。当JVM启动时创建。所有线程共享此内存，此内存中存放的都是数组和对象实例。</p><p>Java堆是垃圾回收器管理的最主要内存区域。Java堆可以处于物理上不连续的内存空间。-Xmx设置堆最大值，-Xms设置堆最小值</p><p><strong>异常：</strong>若在堆中没有足够的内存完成对象实例分配并且堆无法再次扩展时，抛出OOM异常</p><ul><li>方法区</li></ul><p>用于存储已被JVM加载的类信息、常量、静态变量等数据。JDK8以前，方法区也叫永久代。JDK8以后叫做元空间（Meta Space）</p><p>方法区无法满足内存分配需求时，抛出OOM</p><ul><li>运行时常量池</li></ul><p>运行时常量池是方法区的一部分，存放字面量与符号引用</p><p><strong>字面量：</strong>字符串常量（JDK7中移入堆中）、final常量、基本数据类型的值</p><p><strong>符号引用：</strong>类、字段、方法的完全限定名、名称、描述符</p><p>JVM内存区域划分-&gt;判断对象是否存活-&gt;垃圾回收算法-&gt;</p><h4 id="对象产生的过程"><a href="#对象产生的过程" class="headerlink" title="对象产生的过程"></a>对象产生的过程</h4><p>符号引用-&gt;类-&gt;具体引用 </p><p>根据符号引用去JVM方法区拿到该类的信息，然后再去堆中开辟空间</p><h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><p>OOM共有两种：内存溢出和内存泄漏</p><p><strong>内存泄漏：</strong>无用对象无法被垃圾回收，无法解决</p><p><strong>内存溢出：</strong>内存中</p><h3 id="垃圾回收器与内存分配策略"><a href="#垃圾回收器与内存分配策略" class="headerlink" title="垃圾回收器与内存分配策略"></a>垃圾回收器与内存分配策略</h3><h4 id="判断对象是否已死"><a href="#判断对象是否已死" class="headerlink" title="判断对象是否已死"></a>判断对象是否已死</h4><ul><li>引用计数法</li></ul><p>给每个对象附加一个引用计数器，每当有一个地方引用此对象时，计数器+1；每当有一个引用失效时，计数器-1；在任意时刻，只要计数器值为0的对象就是不能再被使用，即对象已死。</p><p>引用计数法实现简单，判定效率较高，但是无法解决循环引用问题。JVM并未采用此算法</p><p><code>-XX:printGC</code>:查看垃圾处理装置</p><ul><li>可达性分析算法</li></ul><p>Java采用可达性分析算法来判断对象是否存活（C#也适用该算法）</p><p><strong>核心思想:</strong>通过一系列<code>GC Roots</code>的对象作为起点，从这些节点开始向下搜索对象，搜索走过的路径，称为“引用链”，当一个对象到任意一个GC Roots对象没有任何的引用链相连时（从GC Roots到对象不可达），证明此对象已死。</p><p><strong>Java中能作为GC Roots的对象包含以下四种：</strong></p><p>1、虚拟机栈中的引用对象</p><p>2、类静态变量引用的对象</p><p>3、本地方法栈中引用的对象</p><p>4、常量引用的对象</p><p><strong>JDK1.2之后对于引用的概念做了扩充：</strong></p><ul><li>强引用-StrongReference</li></ul><p>强引用指的是代码中普遍存在的，类似于Object obj = new Object();</p><p>在JVM中只要强引用还在，垃圾回收器永远不会回收此类对象的空间</p><ul><li>软引用-SoftReference</li></ul><p>软引用用来描述一些有用但不必须的对象，对于仅被软引用指向的对象，在系统将要发生内存溢出之前，会将<strong>所有软引用对象</strong>进行垃圾回收。若内存够用，这些对象仍然保留。在JDK1.2之后，提供了Soft Reference来实现软引用。</p><ul><li>弱引用-WeakReference</li></ul><p>弱引用用来描述一些有用但不必须的对象，但弱引用比软引用更差一点。仅被弱引用关联的对象最多只能生存到下一次GC开始之前。当垃圾回收器开始工作时，<strong>无论当前内存是否够用</strong>，都会回收掉仅被弱引用关联的对象。JDK1.2以后，使用WeakReference来实现弱引用</p><ul><li>虚引用-PhantomReference</li></ul><p>虚引用也称为幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在完全不会对其生存时间有影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是在这个对象被GC之前，收到一个系统通知。JDK1.2之后，提供PhantomReference来描述虚引用。</p><p><strong>为什么要有虚引用：</strong></p><p>在一个虚引用被垃圾回收之前，会收到一个通知来告诉JVM该虚引用对象将被销毁</p><h4 id="对象的自我拯救-finalize"><a href="#对象的自我拯救-finalize" class="headerlink" title="对象的自我拯救-finalize"></a>对象的自我拯救-finalize</h4><p>在可达性分析算法中不可达对象，也并非“非死不可”，所有不可达的对象处于缓刑阶段。要宣告一个对象的彻底死亡，需要经历两次标记过程：</p><p>若对象在进行可达性分析之后，发现到GC Roots不可达，此对象会进行一次筛选过程。</p><p><strong>筛选的条件</strong>是此对象是否有必要执行<code>finalize()</code>。当对象没有覆写<code>finalize()</code>或<code>finalize()</code>已被调用过，JVM会将此对象彻底宣判死亡。若筛选成功（对象覆写了<code>finalize()</code>，并且未被执行过），会将此对象放到F-Queue中</p><p>如果对象在finalize方法中成功自救（此对象与任意一个GC Roots建立联系），则对象在第二次标记时被移除回收集合，成功存活；若对象在finalize中仍然与GC Roots不可达，宣告死亡。</p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>方法区的回收主要回收两部分内容：废弃常量和无用的类</p><p><strong>判断常量是否被废弃的条件：</strong></p><p>常量未被引用</p><p><strong>判断一个类是无用类的条件：</strong></p><p>1、该类的所有实例都已经被回收，也就是在堆中不存在该类的任何实例。</p><p>2、加载该类的类加载器都被回收</p><p>3、该类的Class对象没有在任何其他地方被引用，也无法通过反射访问该类的所有内容</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虚拟机是通过软件模拟的具有完整硬件功能，运行在完全隔离环境中的计算机系统。&lt;/p&gt;
&lt;p&gt;使用最多的是VMWare和Virtual Box。&lt;/p&gt;
&lt;p&gt;JVM是通过软件&lt;strong&gt;模拟Java字节码指令集&lt;/strong&gt;，JVM只保留了PC寄存器，而普遍的虚拟机有很多寄存器。&lt;/p&gt;
&lt;p&gt;做JVM的公司有很多家，从&lt;strong&gt;JDK1.3&lt;/strong&gt;开始，HotSpot为默认JVM。&lt;/p&gt;
&lt;p&gt;JVM上&lt;strong&gt;不止可以运行Java的代码&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
      <category term="JVM" scheme="http://www.bingoxin.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深浅拷贝</title>
    <link href="http://www.bingoxin.top/2019/01/03/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://www.bingoxin.top/2019/01/03/深浅拷贝/</id>
    <published>2019-01-03T10:37:30.000Z</published>
    <updated>2019-01-03T14:13:59.364Z</updated>
    
    <content type="html"><![CDATA[<h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><p>拷贝的执行函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><p>并不是所有的类都可以被拷贝，需实现<code>Cloneable</code>接口，并且在类中自定义<code>clone()</code>调用Object类提供的继承权限<code>clone()</code></p><p>若不实现Cloneable接口，在调用<code>clone()</code>时，会抛出CloneNotSupportedException异常。</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>对于浅拷贝而言，拷贝出来的对象仍然保留原对象的所有引用。</p><p>只要拷贝对象和原对象中引用的属性发生改变，其所有的该引用属性都会发生改变</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>对于深拷贝而言，拷贝出来的对象会产生新的对象。</p><p>对于拷贝的原对象和拷贝出来的对象来说，改变一个引用的属性，互不影响</p><p>对象中包含的引用只是自定义引用</p><h3 id="如何实现深拷贝"><a href="#如何实现深拷贝" class="headerlink" title="如何实现深拷贝"></a>如何实现深拷贝</h3><p>1.包含的其他类继续实现Cloneable接口，并且调用<code>clone()</code></p><p>2*.实现序列化</p><h4 id="调用clone"><a href="#调用clone" class="headerlink" title="调用clone()"></a>调用<code>clone()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baby</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Baby&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Baby <span class="title">clone</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        Baby baby = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            baby =(Baby) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Baby</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line">    <span class="keyword">public</span> Baby baby;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Monkey</span><span class="params">(String name, Integer age, Baby baby)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.baby = baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Monkey&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", baby="</span> + baby +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Baby <span class="title">getBaby</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBaby</span><span class="params">(Baby baby)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baby = baby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Monkey <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Monkey monkey = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            monkey = (Monkey) <span class="keyword">super</span>.clone();</span><br><span class="line">            monkey.baby = <span class="keyword">this</span>.baby.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> monkey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Baby baby = <span class="keyword">new</span> Baby(<span class="string">"zxh"</span>,<span class="number">3</span>);</span><br><span class="line">        Monkey monkey = <span class="keyword">new</span> Monkey(<span class="string">"zh"</span>,<span class="number">88</span>,baby);</span><br><span class="line"></span><br><span class="line">        Monkey monkey1 = monkey.clone();</span><br><span class="line">        System.out.println(monkey1);</span><br><span class="line">System.out.println(monkey.baby == monkey1.baby);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><ul><li>概念</li></ul><p>将内存中保存的对象变为二进制流，进行输出或保存在文本中，即将对象变为二进制流。<br>若类要实现序列化，必须实现<code>Serializable</code>接口</p><p>Serializable接口为标识接口，只有实现了Serializable接口的类，才具备对象序列化的功能。</p><p>但要具体实现序列化和反序列化需要使用IO包中提供的两个处理类：ObjectOutputStream（序列化）、ObjectInputStream（反序列化）</p><ul><li>ObjectOutputStream（序列化）</li></ul><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectOutputStream</span><span class="params">(OutputStream out)</span></span>;</span><br></pre></td></tr></table></figure><p>将文件转化为二进制流输出到终端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writeObject(Object obj);</span><br></pre></td></tr></table></figure><p>例程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Monkey</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Monkey&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\pxx\\Desktop"</span> + <span class="string">"\\1.txt"</span>);</span><br><span class="line">        Monkey monkey = <span class="keyword">new</span> Monkey(<span class="string">"zh"</span>,<span class="number">99</span>);</span><br><span class="line">        OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(outputStream);</span><br><span class="line">        oos.writeObject(monkey);</span><br><span class="line">        oos.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>transient</code>关键字</p><p>若希望类中的若干属性不被序列化，可以在属性前添加该关键字</p></li><li><p>ObjectInputStream(反序列化)</p></li></ul><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectInputStream</span><span class="params">(InputStream in)</span></span>;</span><br></pre></td></tr></table></figure><p>将文件中的二进制流输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readObject(Object obj);</span><br></pre></td></tr></table></figure><h4 id="使用序列化实现深拷贝"><a href="#使用序列化实现深拷贝" class="headerlink" title="使用序列化实现深拷贝"></a>使用序列化实现深拷贝</h4><p>使用序列化进行深拷贝时，无须实现Cloneable接口，而需要实现Serializable接口</p><p>用序列化实现上一例程的拷贝Monkey对象的功能，代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public Monkey ObjectClone()&#123;</span><br><span class="line"></span><br><span class="line">        OutputStream outputStream = new ByteOutputStream();</span><br><span class="line">        Monkey monkey = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(outputStream);</span><br><span class="line"></span><br><span class="line">            oos.writeObject(this);</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            InputStream bis = new ByteInputStream(((ByteOutputStream) outputStream).getBytes(),((ByteOutputStream) outputStream).size());</span><br><span class="line">            ObjectInputStream ois = new ObjectInputStream(bis);</span><br><span class="line"></span><br><span class="line">            monkey = (Monkey) ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line">            bis.close();</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return monkey;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;深浅拷贝&quot;&gt;&lt;a href=&quot;#深浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;深浅拷贝&quot;&gt;&lt;/a&gt;深浅拷贝&lt;/h3&gt;&lt;p&gt;拷贝的执行函数&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>三范式</title>
    <link href="http://www.bingoxin.top/2019/01/03/%E4%B8%89%E8%8C%83%E5%BC%8F/"/>
    <id>http://www.bingoxin.top/2019/01/03/三范式/</id>
    <published>2019-01-03T05:28:47.000Z</published>
    <updated>2019-01-03T05:28:47.847Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络基础概念理解</title>
    <link href="http://www.bingoxin.top/2018/12/25/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
    <id>http://www.bingoxin.top/2018/12/25/网络基础概念理解/</id>
    <published>2018-12-25T09:20:25.000Z</published>
    <updated>2019-01-02T13:50:37.345Z</updated>
    
    <content type="html"><![CDATA[<p>总是听到身边的人说局域网，那么局域网到底是什么呢？</p><p>如何将一个数据发送到另一台主机呢？</p><p>操作系统是如何知道网卡中有数据发来呢？</p><p>请接下这篇博客<a id="more"></a></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="局域网与公网"><a href="#局域网与公网" class="headerlink" title="局域网与公网"></a>局域网与公网</h3><ul><li><p>局域网概念—LAN</p><p>局域网指在某一区域内由多台计算机互联成的计算机组，应用在局部范围内，例如我们家里或者学校使用的无线网</p></li></ul><p>我们使用的WIFI也叫WLAN，即无线局域网。</p><p>在同一局域网内，两台主机可以直接通信</p><ul><li><p>广域网—WAN</p><p>广域网是连接不同地区局域网或城域网计算机通信的远程网，通常跨接很大的物理范围，例如我们使用的阿里云服务器</p></li></ul><p>公网接入方式：上网的计算机得到的IP地址是Internet上的非保留地址，公网的计算机和Internet上的其他计算机可随意互相访问。</p><p>任何一台在局域网上的主机，在不欠费的情况下，是可以访问公网上的服务器的</p><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>协议就像是一种约定，而网络协议也可以被理解为是在网络上的一种约定</p><ul><li>协议分层</li></ul><p>例如，两个人在打电话，这个通信过程可以将其分为两部分：通信工具和人。</p><p>当中国人和中国人打电话时，两人均使用汉语进行沟通，当其中一人使用电话进行通话时，两人依然可以正常沟通。再或者，其中一个中国人给一个英国人打电话时，两人还是可以用英语进行交流。</p><p>这也可以说明了分层的<strong>好处</strong>：其中一层发生改变整体不受影响，即分层可以更好的解耦</p><p>在分层这里要注意：同层之间才可以通信</p><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总是听到身边的人说局域网，那么局域网到底是什么呢？&lt;/p&gt;
&lt;p&gt;如何将一个数据发送到另一台主机呢？&lt;/p&gt;
&lt;p&gt;操作系统是如何知道网卡中有数据发来呢？&lt;/p&gt;
&lt;p&gt;请接下这篇博客
    
    </summary>
    
    
      <category term="操作系统和网络" scheme="http://www.bingoxin.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java中的类集</title>
    <link href="http://www.bingoxin.top/2018/12/21/Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E9%9B%86/"/>
    <id>http://www.bingoxin.top/2018/12/21/Java中的类集/</id>
    <published>2018-12-21T14:44:51.000Z</published>
    <updated>2018-12-22T09:55:08.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java类集"><a href="#Java类集" class="headerlink" title="Java类集"></a>Java类集</h1><p>Java类集就是动态数组，类集的使用比较容易操作，但是类集的底层需要用到数据结构和多线程</p><p>所有的类集都在java.util包下<a id="more"></a></p><h3 id="Java类集的产生"><a href="#Java类集的产生" class="headerlink" title="Java类集的产生"></a>Java类集的产生</h3><p>Java类集是从JDK1.2开始应用的，用于解决数组定长问题</p><ul><li>Collection接口—<strong>单个对象</strong>保存的最顶层父接口</li></ul><p>Collection接口以及其子接口，在每次进行数据操作时只能对单个对象进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Iterable&lt;E&gt;</code>:迭代器接口（用于遍历集合）</p><p><code>Interface&lt;E&gt; iterator()</code>：取得集合的迭代器，JDK1.5之前没有泛型，则迭代器直接写在Collection接口中</p><ul><li>Collection接口中提供的核心方法</li></ul><p><strong>向类集中添加元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>取得接口的迭代器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Collection 接口只定义了存储数据的标准，但是无法区分存储类型。因此在实际中我们往往是由两个子接口List（允许数据重复）、Set（不允许数据重复）一般不直接使用Collection接口</p><h2 id="List接口—允许数据重复"><a href="#List接口—允许数据重复" class="headerlink" title="List接口—允许数据重复"></a>List接口—允许数据重复</h2><p>在进行单个集合处理时，优先考虑List接口</p><p>在List接口中，拓展了两个重要方法（List独有）</p><ul><li>根据索引取得下标数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>根据索引下标更改数据，返回原来的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br></pre></td></tr></table></figure><p>List接口有三个重要子类：ArrayList、Vector、LinkedList</p><p>List接口要想保存自定义类的对象，该类必须覆写<code>equals()</code>来使用<code>contains()</code>、<code>remove()</code></p><h3 id="ArrayList-Vector-LinkedList的区别"><a href="#ArrayList-Vector-LinkedList的区别" class="headerlink" title="ArrayList/Vector/LinkedList的区别"></a>ArrayList/Vector/LinkedList的区别</h3><ul><li>ArrayList与Vector的区别</li></ul><p>1、<strong>出现版本：</strong>ArrayList 在JDK1.2版本才出现，Vector在JDK1.0版本就已经出现</p><p>2、<strong>调用无参构造的区别：</strong>Vector在无参构造执行后将对象数组大小初始化为10，ArrayList采用懒加载策略，在构造方法阶段并不初始化数组，在第一次添加元素时才会初始化数组，大小为10</p><p>3、<strong>扩容策略：</strong>ArrayList在扩容时，会扩容到原来长度的1.5倍；Vector在扩容时，会扩容到原来的两倍</p><p>4、<strong>线程的安全性：</strong>ArrayList采用异步处理，线程不安全，效率较高；Vector采用在方法上加锁，线程安全，效率更低。（即便要使用线程安全的List也不使用Vector）</p><p>5、<strong>遍历：</strong>Vector支持较老的迭代器；ArrayList不支持</p><ul><li>ArrayList与Vector的共同点</li></ul><p>底层都使用数组实现，且都是List的子类</p><ul><li>ArrayList与LinkedList的区别</li></ul><p>LinkedList底层是双向链表，ArrayList的底层是数组</p><h2 id="Set接口—不允许数据重复"><a href="#Set接口—不允许数据重复" class="headerlink" title="Set接口—不允许数据重复"></a>Set接口—不允许数据重复</h2><p>Set接口没有扩充方法，常用子类有<code>HashSet</code>(无序存储)和<code>TreeSet</code>(有序存储)</p><p>Set接口本质上就是Map接口，Set就是value值都为PRESENT的Map</p><h3 id="Comparable接口与Comparator接口"><a href="#Comparable接口与Comparator接口" class="headerlink" title="Comparable接口与Comparator接口"></a>Comparable接口与Comparator接口</h3><ul><li>Comparable接口</li></ul><p>在Java中，若实现自定义类的比较，提供了一下两个接口：</p><p>java.lang.Comparable接口（内部比较器）:若一个类实现了Comparable接口，就表示该类可以进行比较并排序的。存放该类的Conllection或数组，可以直接通过<code>Collection.sort()</code>或Array.sort进行排序</p><p>实现了Comparable接口的类可以直接存放在TreeSet或TreeMap中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>返回值三种情况：</p><p>返回正数：当前对象大于目标对象</p><p>返回负数：当前对象小于目标对象</p><p>返回0：当前对象等于目标对象</p><ul><li>Comparator接口</li></ul><p>Comparator是外部排序接口</p><p>若要控制某个自定义类的顺序，而该类本身不支持排序—实现Comparator接口，覆写compareTo方法或实现一个比较器传入TreeSet或TreeMap中进行比较即可。</p><p>实现了Comparator接口的类作为比较器，通过该比较器来进行类排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1,T o2)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值与compareTo返回值完全一样</p><p>返回正数，o1&gt;o2</p><p>返回负数，o1&lt;o2</p><p>返回0，o1=o2</p><p>实现<code>Comparator</code>接口进行第三方排序—策略模式，此方法更加灵活，可以轻松改变策略进行第三方的排序方法</p><ul><li>Comparable接口与Comparator接口的关系</li></ul><p>Comparable是排序接口，若一个类实现了Comparable接口，意味着该类支持排序，是一个内部比较器（自己去和别人比）</p><p>Comparator接口是比较器接口，类本身不支持排序，专门有若干个第三方的比较器（实现了Comparator接口的类）来进行类排序，是一个外部比较器</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>底层是由哈希表和红黑树，允许存放null，无序储存</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>底层使用红黑树，不允许空值出现，允许储存</p><p>保存自定义类需实现Comparable接口或者传入比较器（compartor接口）</p><h3 id="HashSet和TreeSet的区别"><a href="#HashSet和TreeSet的区别" class="headerlink" title="HashSet和TreeSet的区别"></a>HashSet和TreeSet的区别</h3><p>1、<strong>底层实现不同：</strong>HashSet底层是由哈希表和红黑树，允许存放null，无序储存；TreeSet底层使用红黑树，不允许空值出现，允许储存</p><h3 id="重复元素比较"><a href="#重复元素比较" class="headerlink" title="重复元素比较"></a>重复元素比较</h3><p>TreeSet与TreeMap依靠Comparator或Comparable接口来区别重复元素</p><p>HashMap和HashSet不依赖比较接口，可以通过同时覆写其<code>equals()</code>和<code>HashCode()</code>方法来区分</p><p><strong>元素比较步骤：</strong></p><p>1、调用<code>hashCode()</code>计算出对象hash码决定存放的hash桶</p><p>2、使用<code>equals()</code>方法来判定两个元素内容是否相等，若相等，则不放置元素，若不相等，则在相同桶之后将元素链起来</p><p>object类内置的<code>hashCode()</code>是默认比较对象的地址转为hash码</p><p>两个对象<code>equals()</code>方法返回true，他们的hashCode必然保持相等，</p><p>两个对象的hashCode相等，不能保证他们的<code>equals()</code>一定相等，当且仅当hashCode和equals都返回true是，才说明两个对象都相等</p><ul><li>覆写<code>equals()</code>方法原则</li></ul><blockquote><p>自反性：对于任何非空引用值x，<code>x.equals(x)</code>都返回true</p><p>对称性：对于任何非空的x,y,当且仅当<code>x.equals(y)</code>返回true，<code>y.equals(x)</code>返回true</p><p>传递性：对于任何非空的x,y,z,当<code>x.equals(y)</code>返回true，<code>y.equals(z)</code>返回true,才有<code>x.equals(z)</code>返回true</p><p>一致性：对于任何非空的x,y,若x与y中属性没有变，则多次调用<code>equals()</code>方法，都返回true或false</p><p>非空性：对于任何非空引用值x，<code>x.equlas(null)</code>，返回false</p></blockquote><h3 id="集合输出—迭代器Iterator输出"><a href="#集合输出—迭代器Iterator输出" class="headerlink" title="集合输出—迭代器Iterator输出"></a>集合输出—迭代器Iterator输出</h3><ul><li>迭代输出—Collection接口支持</li></ul><p><strong>Iterator的两个核心方法</strong></p><p>判断是否还有元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>取得下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>单向迭代输出</strong></p><p>调用Collection集合子类的Iterator方法取得内置的迭代器，使用一下输出格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双向迭代输出</strong>–ListIterator</p><p>除了<code>hasNext</code>与<code>next</code>方法外还有：</p><p>判断是否有上一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasPrevious();</span><br></pre></td></tr></table></figure><p>取得上一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">previous();</span><br></pre></td></tr></table></figure><p>要想从后向前遍历，首先至少要从前向后遍历一次才可使用</p><ul><li>Enumeration枚举输出—Vector类支持</li></ul><p>判断是否有下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasMoreElements();</span><br></pre></td></tr></table></figure><p>取得下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextElement();</span><br></pre></td></tr></table></figure><ul><li>for-each输出</li></ul><p>能使用for-each的本质是各个集合类都内置了迭代器</p><ul><li>fail-fast机制</li></ul><p>ConcurrentModificationException发生在Collection集合使用迭代器遍历时，使用了集合类提供的修改集合内容方法报错。而如果使用Iterator迭代器的<code>remove()</code>不会出现此类错误</p><p>Collection集合中的modCount表示当前集合修改的次数</p><p>exceptedModCount是迭代器中记录当前集合的修改次数</p><p>当取得集合迭代器时，调用<code>new Itr()</code>会执行expectedModCount = ModCount，换言之，迭代器就是当前集合的一个副本</p><p>快速失败策略保证了所有用户在进行迭代遍历集合时，拿到的数据一定是最新的数据（避免脏读产生）</p><ul><li>fail-safe</li></ul><p>不产生ConcurrentModificationException异常，juc包下的所有线程安全集合（CopyOnWriteArrayList）</p><p><strong>以后再迭代器遍历时，不要修改集合的内容</strong></p><h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><p>Map接口是Java中保存二元偶对象的最顶层接口</p><p>Map中key值唯一，即通过可以值就可以找到对应的value值</p><ul><li>核心方法</li></ul><p>向Map中添加数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key,V value)</span></span>;</span><br></pre></td></tr></table></figure><p>根据指定的key值取得相应的value值，若没有key值，返回null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>;</span><br></pre></td></tr></table></figure><p>将Map集合变为Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure><p>返回所有key值集合，key不能重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>返回所有value值，value可以重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Map接口常用子类：HashMap、TreeMap、Hashtable、ConcurrentHashMap</p><ul><li>类比HashMap与Hashtable</li></ul><p>1、<strong>key和value的取值：</strong>HashMap的key值和value值可以取null，而Hashtable中key和value均不能取value值</p><p>2、<strong>出现的版本不同：</strong>JDK1.2产生了HashMap，JDK1.0就产生了Hashtable</p><p>3、<strong>线程安全问题：</strong>HashMap采用异步处理，线程不安全但是效率高，Hashtable采用同步处理，线程安全，效率低</p><p>4、<strong>底层实现：</strong>HashMap的底层是用哈希表和红黑树实现的，Hashtable的底层是用哈希表实现的</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java类集&quot;&gt;&lt;a href=&quot;#Java类集&quot; class=&quot;headerlink&quot; title=&quot;Java类集&quot;&gt;&lt;/a&gt;Java类集&lt;/h1&gt;&lt;p&gt;Java类集就是动态数组，类集的使用比较容易操作，但是类集的底层需要用到数据结构和多线程&lt;/p&gt;
&lt;p&gt;所有的类集都在java.util包下
    
    </summary>
    
    
      <category term="Java" scheme="http://www.bingoxin.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDBC</title>
    <link href="http://www.bingoxin.top/2018/12/20/JDBC/"/>
    <id>http://www.bingoxin.top/2018/12/20/JDBC/</id>
    <published>2018-12-20T06:20:21.000Z</published>
    <updated>2019-01-02T12:58:41.473Z</updated>
    
    <content type="html"><![CDATA[<p>现在的应用系统大多都离不开数据库，而Java程序访问数据库的基本方式是通过JDBC。</p><p>Java Database Connectivity，Java数据库连接。</p><p>用于执行SQL语句的Java API</p><p>JDBC使用流程如下：</p><p><img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JDBC/%E6%8D%95%E8%8E%B7.PNG"></p><a id="more"></a><h3 id="JDBC的使用"><a href="#JDBC的使用" class="headerlink" title="JDBC的使用"></a>JDBC的使用</h3><ul><li>加载JDBC驱动程序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br></pre></td></tr></table></figure><ul><li>建立数据库连接</li></ul><p>代码格式：jdbc:{数据库的名称}://host:port/databaseName?param1=value&amp;param2=value2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/memo? user=root&amp;password=root&amp;useUnicode=true&amp;characterEncoding=UTF-8"</span>);</span><br></pre></td></tr></table></figure><ul><li>创建操作命令（statement）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement statement = connection.createStatement();</span><br></pre></td></tr></table></figure><ul><li>执行SQL语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">            ResultSet resultSet = statement.executeQuery(sql);</span><br></pre></td></tr></table></figure><ul><li>处理结果集</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">                String title = resultSet.getString(<span class="string">"ename"</span>);</span><br><span class="line">                System.out.println(id == resultSet.getInt(<span class="string">"empno"</span>));</span><br><span class="line">                System.out.println(String.format(<span class="string">"id = %d,title = %s"</span>, id, title));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ul><li>释放资源（关闭结果集，命令，连接）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭结果集</span></span><br><span class="line"><span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        resultSet.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; &#125; </span><br><span class="line"><span class="comment">//关闭命令</span></span><br><span class="line"><span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        statement.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; &#125;</span><br><span class="line"><span class="comment">//关闭连接命令</span></span><br><span class="line"><span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();    </span><br><span class="line"> &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="Statement对象"><a href="#Statement对象" class="headerlink" title="Statement对象"></a>Statement对象</h3><p>用于将SQL语句发送到数据库中，JDBC API中主要提供了三种Statement对象</p><ul><li>Statement</li></ul><p>用于执行不带参数的简单SQL语句</p><p>SQL语句通过拼接字符串来实现，该方式效率比较低，系统会自动将该字符串定义为StringBuilder，拼接时调用<code>append()</code>方法</p><ul><li>PreparedStatement</li></ul><p>用于执行带或者不带参数的SQL语句</p><p>SQL语句会预编译在数据库系统</p><p>执行速度快于Statement对象</p><ul><li>CallableStatement</li></ul><p>用于执行数据库存储过程的调用</p><p>实际开发中最常用的是PreparedStatement，其具有以下优点：</p><blockquote><p>1、性能比Statement高（拼接字符串效率较低）</p><p>2、参数化SQL查询</p><p>3、占位符不能使用多值，占位符下标从1开始</p><p>4、SQL预编译</p><p>5、阻止常用SQL注入攻击</p></blockquote><p><strong>SQL两种执行方法：</strong></p><p>方法执行后返回单个结果集的，通常用于select语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executeQuery()</span><br></pre></td></tr></table></figure><p>方法返回值是一个整数，指示受影响的行数，通常用于update、insert、delete</p><h3 id="ResultSet对象"><a href="#ResultSet对象" class="headerlink" title="ResultSet对象"></a>ResultSet对象</h3><p>ResultSet对象被称为结果集，表示符合SQL语句执行结果的所有行，并且提供了一套<code>getXXX()</code>方法提供了对这些行中数据的访问。ResultSet就像一个迭代器，其所指的数据行叫做当前数据行。</p><p>取得某一条记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet.next()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在的应用系统大多都离不开数据库，而Java程序访问数据库的基本方式是通过JDBC。&lt;/p&gt;
&lt;p&gt;Java Database Connectivity，Java数据库连接。&lt;/p&gt;
&lt;p&gt;用于执行SQL语句的Java API&lt;/p&gt;
&lt;p&gt;JDBC使用流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/JDBC/%E6%8D%95%E8%8E%B7.PNG&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://www.bingoxin.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>STL的底层与应用</title>
    <link href="http://www.bingoxin.top/2018/08/28/STL%E7%9A%84%E5%BA%95%E5%B1%82%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>http://www.bingoxin.top/2018/08/28/STL的底层与应用/</id>
    <published>2018-08-28T11:06:53.000Z</published>
    <updated>2018-12-26T11:10:46.364Z</updated>
    
    <content type="html"><![CDATA[<p>STL是惠普实现的，其有多个版本，但都是在HP版本的基础上完成的</p><p>STL是C++的标准模板库，包括数据结构和算法的软件框架<a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>STL将常用的数据结构封装起来，在封装过程中使用了算法，使用方便</p><p>其具有通用、高效的特点 </p><h3 id="STL的六大组件"><a href="#STL的六大组件" class="headerlink" title="STL的六大组件"></a>STL的六大组件</h3><p>容器、适配器、迭代器、空间配置器、仿函数、算法</p><p>接下来我会从组件功能、组件实例和实例的底层实现等方面来对各组件进行讲解</p><h3 id="容器-vector、slist、array、deque等"><a href="#容器-vector、slist、array、deque等" class="headerlink" title="容器(vector、slist、array、deque等)"></a>容器(vector、slist、array、deque等)</h3><p>容器中数据的区间都是左闭右开的</p><p>容器分两种：线性和特殊线性结构</p><p>线性结构有：array、vector、slist、deque、string等</p><font color="red" size="3">vector</font><p>vector的底层是动态顺序表，底层结构：</p><div align="center"><br>    <img src="/images/posts/STL/vector.png" height="300" width="500"><br></div><p>由于vector是一段连续的空间，其迭代器被设计成一个原生态指针</p><p>在使用vector时要注意：包含其头文件<vector>并引入标准命名空间std</vector></p><p>其具体功能如下：</p><div align="center"><br>    <img src="/images/posts/STL/vector功能.png" height="500" width="500"><br></div><font color="red" size="3">list</font><p>list的底层是一个带头结点的双向单链表，底层结构：</p><div align="center"><br>    <img src="/images/posts/STL/单链表底层.png" height="300" width="500"><br></div><p>当集合需要大量的插入和删除时，考虑用list</p><p>list的迭代器需要其实现者自己提供</p><p>其具体功能如下：</p><div align="center"><br>    <img src="/images/posts/STL/list功能.png" height="500" width="500"><br></div><font color="red" size="3">deque</font><p>deque是一段假想的连续空间，是一个双端序列，可以实现动态的二维数组</p><p>deque的两端都可以进行插入和删除，其结构如下：</p><div align="center"><br>    <img src="/images/posts/STL/deque.png" height="400" width="600"><br></div><p>deque是分段连续空间，维护其连续的假象的是迭代器</p><p>若迭代器中的cur到了last的位置，即表示已到当前队列的边缘</p><p>在deque的底层，有中控器(map)记录每个队列的迭代器地址(node)，迭代器中有队列的初始位置(first)、末尾位置(last)以及当前指向位置(pur)</p><p>若创建的队列过多，中控器空间不足，则扩容中控器，新的中控器从中间开始存储迭代器(node)的地址</p><p>则deque底层实现如下：</p><div align="center"><br>    <img src="/images/posts/STL/deque底层实现.png" height="300" width="500"><br></div><p>deque的操作如下：</p><div align="center"><br>    <img src="/images/posts/STL/deque功能.png" height="300" width="500"><br></div><p>array的底层实现是静态顺序表</p><p>string也是静态顺序表，他是用来存放字符串的，而array是用来存放各种数据的</p><p>slist是带头结点的单链表</p><p>这些就不做详细讲解了</p><h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><p>仿函数是一个函数对象，即将一个类像函数一样使用</p><pre><code>class people{   public:      返回值类型 operator()(参数列表);   成员变量}；</code></pre><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>适配器是设计模式的一种，该模式的作用是将一个类的接口转换成用户希望的另一个接口</p><p>STL中适配器有三种：应用于容器的适配器、应用于迭代器的适配器、应用于仿函数的适配器</p><h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h4><p>stack和queue都是一种特殊的线性数据结构，其只能在固定端插入和删除</p><p>stack无法遍历，无begin(),end()</p><p>由于deque是双开口序列，则将其稍作改装就可以实现stack和queue</p><p>在使用priority_queue时，用户可以以任意次序将数据放进去，但是取出时，会以优先级高低取出</p><p>其以vector为底层结构，加上堆算法重新封装</p><h4 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h4><p>关联式容器是用键值对(&lt;key,value&gt;)来实现的</p><font color="red" size="3">键值对</font><p>键值对实际是一个结构体，该结构体具有两个字段，两个字段有着一一对应的关系</p><p>在其应用时</p><pre><code>pair&lt;key,value&gt;(key,value);make_pair(key,value);</code></pre><p>这两种形式都可以创建键值对，第一种是对模板类的实例化，第二种返回键值对</p><h5 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h5><p>序列式容器在查找数据时，时间复杂度为O(n)</p><p>而关联式容器map/multimap底层是由红黑树构成的</p><p>这就使得其在查找数据时时间复杂度变成了O(1)，提高了查找效率</p><font color="red" size="3">数据存储方式：</font><p>由于其底层是由红黑树构成的，则在插入变量时，会与key进行比较，则对红黑树进行中序遍历，会得到一个有序序列</p><h4 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h4><p>其底层实现也是红黑树</p><p>其与map的相同之处在于：底层结构都是红黑树</p><p>不同之处是：map中存放的是一个真正的键值对，而set中key与value相同</p><p>map与multimap,set与multiset之间的区别是map/set不可以存储重复的变量，可以去重，而multimap/multiset可以存放相同变量，只是单纯的排序</p><h4 id="unordered-map-unordered-multimap-unordered-set-unordered-multiset"><a href="#unordered-map-unordered-multimap-unordered-set-unordered-multiset" class="headerlink" title="unordered_map/unordered_multimap  unordered_set/unordered_multiset"></a>unordered_map/unordered_multimap  unordered_set/unordered_multiset</h4><p>unordered_map/unordered_multimap放置的内容是一个正常的键值对</p><p>而unordered_set/unordered_multiset放置的内容是key与value相同的键值对</p><p>其底层是由哈希桶实现的，则其的数据存放方式是无序的</p><font color="blue" size="3">map与unordered_map的区别：</font><blockquote><p>1.底层：map的底层是红黑树，unordered_map的底层是哈希桶</p></blockquote><blockquote><p>2.查找方式：map的查找效率高，为O(log2n)，而unordered_map的查找效率为O(n)</p></blockquote><blockquote><p>3.map是有序存放的，而unordered_map是无序放的</p></blockquote><blockquote><p>4.两者的应用场景不同</p></blockquote><blockquote><p>5.迭代器方式不同：map可以正向和反向遍历，而unordered_map只可以正向遍历</p></blockquote><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法有两种：与数据结构有关的算法(绑定在容器上的算法)和与数据结构无关的算法(通用算法)</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是一种设计模式，其实际上是一种行为类似于指针的对象，因此指针的功能迭代器都有</p><p>迭代器的实现只要在类中将指针的功能重载即可</p><p>迭代器的提供者就是容器的实现者</p><h3 id="空间管理"><a href="#空间管理" class="headerlink" title="空间管理"></a>空间管理</h3><h4 id="普通存放数据的原理"><a href="#普通存放数据的原理" class="headerlink" title="普通存放数据的原理"></a>普通存放数据的原理</h4><p>需要空间–&gt;new/new[]–&gt;申请空间、构造对象</p><p>new是将malloc重新封装的，使用一次malloc，在内存中除了会开辟所需空间外，还会额外开辟36个字节</p><p>结构如下图：</p><div align="center"><br>    <img src="/images/posts/STL/malloc.png" height="300" width="500"><br></div><p>通过这种形式管理空间可以防止越界访问</p><h4 id="普通方式存放数据的缺陷"><a href="#普通方式存放数据的缺陷" class="headerlink" title="普通方式存放数据的缺陷"></a>普通方式存放数据的缺陷</h4><blockquote><p>1.频繁的向系统索要小的内存块，会产生内存碎片</p></blockquote><blockquote><p>2.频繁的向系统索要小的内存块，产生额外开销，效率低</p></blockquote><blockquote><p>3.没有及时的释放空间，造成内存泄漏</p></blockquote><blockquote><p>4.空间不足时，无法获取空间</p></blockquote><h4 id="标准空间配置器"><a href="#标准空间配置器" class="headerlink" title="标准空间配置器"></a>标准空间配置器</h4><p>标准空间配置器只是将new,delete进行简单的封装，与我们平常使用的new和delete没太大区别</p><h4 id="重新设计空间配置器"><a href="#重新设计空间配置器" class="headerlink" title="重新设计空间配置器"></a>重新设计空间配置器</h4><p>重新设计空间配置器有一级空间配置器和二级空间配置器两种</p><p>重新设计空间配置器会根据用户索要空间的大小来选择空间配置器</p><font color="blue" size="3">一级空间配置器</font><p>当用户索要空间大于128个字节时，会使用一级空间配置器</p><p>一级空间配置器将malloc和free进行简单的封装</p><pre><code>void* allocate(字节数):malloc若空间充足，开辟空间成功，直接返回若空间不充足，开辟空间失败，启动空间不足应对措施(函数指针)allocate_OOM (字节数){   检测空间不足应对措施是否设置   是：malloc  //重新开辟空间   否:throw bad_alloc  //抛异常}//将空间归还系统void deallocate(void* p,size_t size){   free(p);}</code></pre><font color="blue" size="3">二级空间配置器</font><p>当用户索取空间小于128个字节时，会使用二级空间配置器</p><p>为了减少多次开辟空间造成的额外消耗，二级空间配置器会开辟一个很大空间作为内存池</p><p>同时会构造一个哈希表，其中会有128/8=16个结点，每个结点下面会挂(n+1)*8字节的内存块，构成哈希桶，以此来管理小的内存块</p><p>结构如下：</p><div align="center"><br>    <img src="/images/posts/STL/空间配置器.png" height="300" width="500"><br></div><p>空间管理如下：</p><pre><code>void* allocate(size_t size){   if(size&gt;128)       一级空间配置器   else   {       1.找size对应的哈希桶       2.检测该哈希桶有没有结点        有：将第一块内存给用户        没有：refill(size向上取整到8的整数倍，向当前链表中补充空间)   }}void* refill(size_t size){   1.通过chunk_alloc(objs,size)索要nobjs(20)个size个字节的内存块   2.nobjs = 1---&gt;返回----&gt;将一块内存返回给用户     20 &gt;= objs &gt; 1 ---&gt;将剩余的内存块挂在链表中}void* chunk_alloc(size_t&amp; nobjs,size_t size){   从内存池中索要空间     &gt;1.计算总共需要的字节数  totalBytes = nobjs*size     &gt;2.计算内存池中剩余的字节数  leftBytes =_endFree-_startFree;   if(leftByte&gt;=totalBytes)   {       提供20个内存块   }   else if (leftBytes&gt;=size)   {       nobjs=leftBytes/size;   }   else   {       0.把内存池剩余的元素处理掉(挂到对应的哈希桶中)       1.向系统索要空间补充内存池---&gt;成功---&gt;_startFree接受malloc的返回值---&gt;递归chunk_alloc()       2.如果1失败，从当前链表往后去找是否还有更大的内存块---&gt;找到了---&gt;补充到内存池---&gt;递归chunk_alloc()       3.使用一级空间配置器(内存不足应对措施)---&gt;递归chunk_alloc()   }}</code></pre><p>这种处理内存碎片的方式虽然解决了外部存在大量的内存碎片的问题，但是还是会有在哈希桶上挂的小碎片<br>​<br>可能有的地方叙述的不是很清楚，欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;STL是惠普实现的，其有多个版本，但都是在HP版本的基础上完成的&lt;/p&gt;
&lt;p&gt;STL是C++的标准模板库，包括数据结构和算法的软件框架
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.bingoxin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Python基础小知识</title>
    <link href="http://www.bingoxin.top/2018/08/01/Python%E5%9F%BA%E7%A1%80%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <id>http://www.bingoxin.top/2018/08/01/Python基础小知识/</id>
    <published>2018-08-01T11:07:17.000Z</published>
    <updated>2018-12-26T11:16:56.856Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始学习Python，以前只是听说过Python是一种脚本语言，没有进行过多的了解 </p><p>Python拥有强大的类库，支持面向过程、面向对象、函数式编程多种编程风格</p><p>通过今天的学习了解到，Python是一种脚本解释语言，像C、C++都属于编译语言</p><p>我们都了解，C/C++在编译过程中，会生成中间产物—.obj文件等，而Python不会</p><p>Python程序的执行时读一行执行一行，所以程序执行的比较慢</p><p>这也就使得Python不可以做开发底层、移动端开发和游戏</p><p>Python的脚本文件是.py，为了提高其执行效率，执行过的程序会生成.pyc文件</p><p>在执行程序时，若检测到有.pyc文件，会优先选择.pyc文件执行<a id="more"></a></p><h3 id="编程须知"><a href="#编程须知" class="headerlink" title="编程须知"></a>编程须知</h3><p>一般写程序，用Linux系统自带的编辑器</p><p>输入命令 Python 即可知道当前系统下Python的版本，这也就进入了Python的解释器</p><p>我们可以把解释器当做是一个基本的计算器，其也可以执行符合Python语法的语句</p><pre><code>例如：输入：1+2输出：3输入：print &apos;hello world&apos;输出：hello world</code></pre><p>按ctrl+d，即可退出解释器</p><p>wim test.py  创建test.py文件，进行编辑</p><p>编辑完成后，按Esc切换到命令模式，然后输入  :wq   回车就自动保存完成了</p><p>输入命令 python test.py 执行代码</p><font color="blue" size="3">两条重要指令</font><pre><code>#!/usr/bin/python有了这条指令，若要执行.py文件，就可以使用 ./test.py 命令#coding:utf-8该指令是一条声明指令，使得文件中可以编辑汉字</code></pre><p>在C/C++中，注释有2种形式：// 和 /**/</p><p>Python中的注释方法是在语句前加一个#</p><h3 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h3><p>根据对变量的赋值确定变量类型，若改变类型，需要强转</p><p>因此在定义变量时，不需要写变量类型</p><h3 id="赋值方式"><a href="#赋值方式" class="headerlink" title="赋值方式"></a>赋值方式</h3><p>赋值方式有三种：</p><p>a.链式赋值：</p><pre><code>a=b=c=1</code></pre><p>b.增量赋值</p><pre><code>a=20*b</code></pre><p>c.多元赋值</p><pre><code>x,y=1,2</code></pre><p>若同一变量多次赋值，以最后一次赋值为准</p><h3 id="变量名规范"><a href="#变量名规范" class="headerlink" title="变量名规范"></a>变量名规范</h3><p>变量名规范和C/C++相同，变量名首字可以是字母下划线不可以是数字</p><p>由多个单词组成的变量名，比较美观的命名形式：</p><p>a.两个单词之间用下划线相连   person_name</p><p>b.小驼峰—除第一个单词，其他单词首字母用大写形式   personName</p><p>c.大驼峰—每个单词的首字母用大写形式   PersonName</p><h3 id="打印变量类型"><a href="#打印变量类型" class="headerlink" title="打印变量类型"></a>打印变量类型</h3><p>type(变量名)</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Python中有整型、浮点型和字符串类型，没有字符类型。</p><p>Python中对数字大小没有限制，内存有多大，数字就可以有多大</p><p>还多了一种复数类型  比如打印一个复数： print 10+2j</p><font color="blue" size="3">字符串：</font><p>声明字符串可以用，‘’、””、”‘’”</p><p>打印一个含有引号的字符串，在C/C++中，需要使用到转义字符，而在Python中不需要</p><p>字符串的操作：</p><p>a.+代表字符串拼接</p><pre><code>print &quot;abc&quot;+&quot;def&quot;运行结果：abcdef</code></pre><p>b.*代表字符串重复</p><pre><code>print &quot;abc&quot;*3运行结果：abcabcabc</code></pre><font color="blue" size="3">下标取值法</font><p>取指定位置的元素，即一个字符串的单独元素</p><p>字符串无法改变一个位置的变量，只能重新定义一个字符串</p><p>在Python中没有字符类型，只有字符串类型</p><font color="blue" size="3">切片操作法</font><p>用str[:]==&gt;构成前闭后开区间</p><p>默认从0开始，在字符串长度结束</p><p>填写负数时，代表len-n</p><p>字符串格式化：</p><p>举个栗子：</p><pre><code>str2=&quot;num is %d&quot; % 10运行结果：num is 10</code></pre><p>%d代表要初始化的类型以及标注了初始化的位置</p><p>把要输出的内容和初始化的数值用%隔开<br>​     </p><h3 id="len"><a href="#len" class="headerlink" title="len()"></a>len()</h3><p>判断字符串长度</p><h3 id="布尔类型-bool"><a href="#布尔类型-bool" class="headerlink" title="布尔类型(bool)"></a>布尔类型(bool)</h3><p>这和我们接触到的c++里的相同，true代表真的，在运行时被当做1，false代表假的，在运行时被当做0</p><h3 id="获取用户输入的函数"><a href="#获取用户输入的函数" class="headerlink" title="获取用户输入的函数"></a>获取用户输入的函数</h3><p>获取用户输入的函数名raw_input()，返回值为str类型</p><p>例如：</p><pre><code>str1=raw_input(&quot;请输入：&quot;)</code></pre><p>当该语句运行时，屏幕会打印括号里的字符串，并等待用户输入</p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>在我们之前学过的+、-、*、/、%的基础上，没有++和–</p><p>**代表乘方：</p><pre><code>print 2**3</code></pre><p>运行结果为：8</p><p>除法有三种：</p><p>a.传统除法   即2/1</p><p>b.精确除法</p><p>输入from <strong>future</strong> import division指令</p><p>此后所有的除法都按照精确除法求值</p><p>c.地板除(//)   即将结果向下取整</p><p>例如：</p><pre><code>a=1b=2print 1//2</code></pre><p>运行结果为：0</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>有&gt;、&lt;、&gt;=、&lt;=、==、!=</p><p>与之前我们接触过的比较运算符不同的是</p><p>与或非：与是and  或是or  非是not</p><h3 id="列表、元组、字典"><a href="#列表、元组、字典" class="headerlink" title="列表、元组、字典"></a>列表、元组、字典</h3><font color="blue" size="3">列表</font><br>list[]<br><br>列表可以下标取值、对象可变、可切片操作，为前闭后开区间<br><br>定义一个列表：list=[1,0.5,”123”,[1,2]]<br><br>从这个列表中，我们可以知道，列表中放的数据可以是不同类型的<br><br>使用 type(list)  可以得到其类型 list<br><br><font color="blue" size="3">元组</font><br>tuple()<br><br>元组对象不可变，可下标访问<br><br>定义方式为：tuple=(1,2,3,4)<br><br><font color="blue" size="3">字典</font><br>dict{}<br><br>字典是以键值对的方式保存数据，可改变对象<br><br>可以通过key得到或赋值value<br><br>若赋值一个新的key，会自动添加新的键值对<br><br>### 引用<br><br>定义几个变量为相同值，可以<br><br>     a=b=c=1<br><br>这在C/C++中也是可以这样赋值，但会开辟三个空间存放数字1<br><br>而在Python中，对象有三要素：id、type、value<br><br>id是一个对象的唯一标识符，type是对象的类型，value是对象的值<br><br>所以在Python中，该语句执行后，a、b、c三个变量会引用这同一个对象，即在同一对象贴上标签<br><br>可通过 id(对象) 来判断其唯一标识符<br><br>### 代码块及缩进<br><br>在C/C++中，我们是以{}来划分代码块的，在Python中我们是以缩进相同来区分代码<br><br>例如：<br><br>     if 1&lt;2:<br><br>         print ‘yes’<br><br>     print ‘no’<br><br>由此我们可知print ‘yes’与if 1&lt;2：是一个代码块<br><br>### range(start,stop,step)<br><br>该函数的功能是：从start到stop间隔是step构成的前闭后开的区间，start的默认值为0，step默认为1<br><br>### 语句折行<br><br>在编写代码时，我们会遇到语句过长的情况，这时我们要注意，代码一定要怎么简洁怎么写<br><br> a.若该语句被小括号、中括号或大括号包起来，可直接换行书写<br><br> b.若没有括号，则需使用\来换行<br><br> c.双引号和单引号字符串都不可换行，但三引号字符串可以直接换行<br><br> d.可以把多个语句写在一行，但是最好不要这样做<br><br>### 变量交换<br><br>在C/C++中，若要交换两个变量的内容，需要借助一个中间变量<br><br>而在python中，可以直接进行交换<br><br>例如：<br><br>     x=1<br><br>     y=2<br><br>     x,y=y,x<br><br>即可交换两个变量，是不是很方便呢？<br><br>bool类型中的true和false的值也可以交换，那么真就是假，假就是真了，但不建议交换<br>​<br>### 作用域和生命周期<br><br>在python中，def、class、lamda会改变变量作用域<br><br>用 globals() 查看当前环境内的全局变量<br><br>用 locals() 查看当前代码块的局部变量<br><br>### 方法私有化<br><br>在python中，在方法名前加下划线表示私有化<br><br>但这只是程序员约定俗成的一种方式，并不是真正意义上的私有化<br><br>因此在python中没有真正的私有化<br><br>### 我们在定义方法时需要注意：<br><br>a.方法名前加下划线表示私有，无法使用from 模块名 improt *导入<br><br>b.方法名前后各加一个下划线表示系统变量<br><br>c.方法名前后各加两个下划线表示系统变量<br><br>### 文档字符串<br><br>#可以用来注释一行内容<br><br>如果我们需要注释多行内容，可以在类或函数之前加上’’’注释内容’’’来表示，这被成为文档字符串<br><br><font color="blue" size="3">doc属性：</font><p>每个对象都有doc属性，用 函数名.<strong>doc</strong> 即可看到使用’’’  ‘’’标注的帮助文档的内容</p><p>使用 help() 也有该作用</p><p>不只是函数或类可以添加帮助文档，模块也可以</p><font color="red" size="3">注意：</font>自己添加的帮助文档，必须放在函数或类的前面，否则无法访问<br><br>### None<br><br>在python中有一种特殊的对象，叫做None，类型为NoneType<br><br>### 对象比较<br><br>对象之间进行比较有三种：对象值的比较、对象身份的比较和对象类型的比较<br><br><font color="blue" size="3">对象值的比较</font><p>所有内建对象都可以用比较操作符进行比较，比较对象的类型必须是相同的</p><p>比较运算符的结果是true和false</p><p>比较运算符有==、!=、&lt;=、&gt;=、&lt;、&gt;</p><font color="blue" size="3">对象身份的比较</font><p>变量名只是对象的一个引用，那么多个变量名就可以引用同一个对象</p><p>可以通过 id() 获得变量引用的对象的id，同时也就可以对多个对象的身份进行比较</p><p>若得到的id值相同，则说明两个变量指向同一个对象</p><p>python还提供了 is、is not 两个关键字，用于比较两个变量名是否指向同一个对象</p><font color="blue" size="3">对象类型的比较</font><p>对于比较两个变量的类型是否相同，可以使用内建函数 type()</p><p>当然啦~类型比较也有比较两个变量的内建函数—isinstance()</p><h3 id="整数的位运算"><a href="#整数的位运算" class="headerlink" title="整数的位运算"></a>整数的位运算</h3><p>整数的位运算有&lt;&lt;、&gt;&gt;、&amp;、^、~</p><p>这些运算符看起来比较陌生的应该是~</p><p>~的功能是按位取反</p><h3 id="内置函数与内置模块"><a href="#内置函数与内置模块" class="headerlink" title="内置函数与内置模块"></a>内置函数与内置模块</h3><font color="blue" size="3">内置函数</font><p>只是一些基本内置函数的功能介绍</p><p> a.abs:求一个整型的绝对值</p><p> b.divmod：同时计算一个表达式的商和余数，返回值是一个元组</p><p> c.str：将数字转换成字符串</p><p> d.round：对浮点数进行四舍五入，共有两个参数，操作数和要保留的小数点后的位数</p><font color="blue" size="3">内置模块</font><p>内置模块主要介绍三种：</p><p> a.整型进制转换：oct()、hex()，参数为整型，返回值是对应字面值得字符串，将十进制转换成八进制和十六进制</p><p> b.math、cmath模块：提供一些方便的数学运算函数，math是常规数学，cmath是复数数学</p><p> c.随机数random模块：参数有两个，确定生成数的范围</p><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>在python中，没有 ：？这样的三目表达式</p><p>取而代之的是</p><pre><code>a = b if a &lt; b else a</code></pre><p>该语句的功能是：判断a是否小于b，若a小于b，则将b指向a的对象，否则a不变</p><h3 id="和循环搭配使用的else"><a href="#和循环搭配使用的else" class="headerlink" title="和循环搭配使用的else"></a>和循环搭配使用的else</h3><p>else不止可以和if一起使用，还可以和for循环、while循环搭配使用</p><p>在与循环搭配时，else语句的功能是：在循环条件不满足时会执行else语句，若break跳出循环，则不执行else的内容</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p> a.函数的参数列表不需要写参数类型</p><p> b.函数1中还可以定义函数2，但函数2的作用域只是函数2中</p><p> c.定义函数时，可以给函数指定默认参数，在调用函数时，若不显式的指定参数，就会使用默认参数</p><p> d.对于多个默认参数的函数，可以按照顺序给函数的某几个参数进行传参</p><p>对于d，若只是给指定位置的参数传参我们又该怎么解决呢？</p><font color="blue" size="3">关键字传参</font><p>对于几个默认参数传参，我们可以通过指定关键字来说明给哪个参数传参</p><font color="blue" size="3">参数组</font><p>若将元组或字典当做参数，就可以实现“可变长参数”</p><p>在参数名前加一个*，之后的内容是一个元组</p><p>在参数名前加两个*,之后的内容表示一个字典</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开始学习Python，以前只是听说过Python是一种脚本语言，没有进行过多的了解 &lt;/p&gt;
&lt;p&gt;Python拥有强大的类库，支持面向过程、面向对象、函数式编程多种编程风格&lt;/p&gt;
&lt;p&gt;通过今天的学习了解到，Python是一种脚本解释语言，像C、C++都属于编译语言&lt;/p&gt;
&lt;p&gt;我们都了解，C/C++在编译过程中，会生成中间产物—.obj文件等，而Python不会&lt;/p&gt;
&lt;p&gt;Python程序的执行时读一行执行一行，所以程序执行的比较慢&lt;/p&gt;
&lt;p&gt;这也就使得Python不可以做开发底层、移动端开发和游戏&lt;/p&gt;
&lt;p&gt;Python的脚本文件是.py，为了提高其执行效率，执行过的程序会生成.pyc文件&lt;/p&gt;
&lt;p&gt;在执行程序时，若检测到有.pyc文件，会优先选择.pyc文件执行
    
    </summary>
    
    
      <category term="Python" scheme="http://www.bingoxin.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>禅道的安装</title>
    <link href="http://www.bingoxin.top/2018/07/26/%E7%A6%85%E9%81%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>http://www.bingoxin.top/2018/07/26/禅道的安装/</id>
    <published>2018-07-26T11:06:34.000Z</published>
    <updated>2018-12-26T11:09:31.822Z</updated>
    
    <content type="html"><![CDATA[<p>测试工具有很多，接下来我将介绍几款比较经典的测试工具<a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先来了解一下测试工具的功能吧~</p><h3 id="测试工具的基本功能"><a href="#测试工具的基本功能" class="headerlink" title="测试工具的基本功能"></a>测试工具的基本功能</h3><blockquote><p>1.测试需求管理</p></blockquote><blockquote><p>2.测试用例管理 </p></blockquote><blockquote><p>3.测试过程管理</p></blockquote><blockquote><p>4.缺陷管理</p></blockquote><blockquote><p>5.报表统计</p></blockquote><blockquote><p>6.权限管理</p></blockquote><h3 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h3><font color="blue" size="3">QC</font><p>具有指定测试需求、测试计划，执行测试和跟踪缺陷的功能</p><font color="blue" size="3">CQ</font><p>配置管理工作中的变更管理工具，用于任务分配、Bug跟踪、变更管理、流程制定</p><font color="blue" size="3">JIRA</font><p>项目与事物跟踪工具，用于缺陷跟踪、客户服务、需求收集、流程审批、任务跟踪、项目跟踪和敏捷管理</p><font color="blue" size="3">Test Link</font><p>测试用例管理，用于管理测试用例和测试过程</p><font color="blue" size="3">禅道</font><p>专注研发项目管理，内置需求管理、任务管理、bug管理、缺陷管理、用例管理、计划发布</p><h3 id="禅道的安装与配置"><a href="#禅道的安装与配置" class="headerlink" title="禅道的安装与配置"></a>禅道的安装与配置</h3><p>我把我的禅道放在了百度网盘上，可随时下载</p><p><a href="https://pan.baidu.com/s/1sUtOglOv0O3UMowf3SQFaw" target="_blank" rel="noopener">下载链接</a>密码：mv00</p><p>1.双击ZenTaoPMS.9.8.3.win64.exe文件，解压文件</p><div align="center"><br>    <img src="/images/posts/测试工具/1.png" height="300" width="500"><br></div><p>2.选择安装目录</p><div align="center"><br>    <img src="/images/posts/测试工具/2.png" height="300" width="500"><br></div><p>3.在解压的文件中，找到start.exe，双击</p><div align="center"><br>    <img src="/images/posts/测试工具/3.png" height="300" width="500"><br></div><p>4.跳转到该界面，不选中下方图标，点击启动禅道</p><div align="center"><br>    <img src="/images/posts/测试工具/4.png" height="300" width="500"><br></div><p>5.当界面显示这些内容时，表示启动成功，点击访问禅道</p><div align="center"><br>    <img src="/images/posts/测试工具/5.png" height="300" width="500"><br></div><p>6.页面会自动跳转到默认浏览器，并在选择版本界面，一般我们选择的都是开源的版本，接下来的讲述也是以开源为例</p><div align="center"><br>    <img src="/images/posts/测试工具/6.png" height="300" width="500"><br></div><p>7.在登录界面，用户名为admin，默认密码为123456</p><div align="center"><br>    <img src="/images/posts/测试工具/7.png" height="300" width="500"><br></div><p>8.登陆成功后，会跳转至应用界面，第一次登陆会显示密码等级过低，这时需要改密码</p><div align="center"><br>    <img src="/images/posts/测试工具/8.png" height="300" width="500"><br></div><h3 id="安装过程遇到的问题"><a href="#安装过程遇到的问题" class="headerlink" title="安装过程遇到的问题"></a>安装过程遇到的问题</h3><p>在启动禅道时(步骤4)，若无法启动，需检查数据库端口与apachezt…端口是否不同</p><p>可以去xampp\mysql\my.ini中修改，也可以在xampp\zentao\config\my.php中修改，在此文件中还可以查看数据库密码</p><p>禅道服务启动后，会提示数据库密码太弱，建议修改密码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;测试工具有很多，接下来我将介绍几款比较经典的测试工具
    
    </summary>
    
    
      <category term="软件安装" scheme="http://www.bingoxin.top/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>C++中的强制类型转换</title>
    <link href="http://www.bingoxin.top/2018/07/26/C-%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://www.bingoxin.top/2018/07/26/C-中的强制类型转换/</id>
    <published>2018-07-26T11:03:31.000Z</published>
    <updated>2018-12-26T11:05:00.511Z</updated>
    
    <content type="html"><![CDATA[<p>在学习C语言的过程中，我们会遇到不同类型变量的转换 </p><p>在C++中，同在也存在，C++中类型转换与C语言的有什么区别呢？<a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>强制类型转换有两种：显式类型转换和隐式类型转换</p><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><p>一般应用在不同类型变量的赋值中</p><pre><code>int a = 10;char b = &apos;0&apos;;b = a;</code></pre><p>不需要加关键字</p><h4 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h4><p>可以应用在不同类型指针的转换中</p><p>比如：</p><pre><code>int a = 10;char* p = (char*)&amp;a;</code></pre><p>通过(转换后的类型)这种格式来完成转换</p><p>C++中的强制类型转换有四种：static_cast、reinterepret_cast、const_cast、dynamic_cast</p><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>static_cast类似于隐式类型转换</p><p>例：<br>    int a = 10;</p><pre><code>char b = &apos;0&apos;;b = static_cast&lt;char&gt;(a);</code></pre><h3 id="reinterepret-cast"><a href="#reinterepret-cast" class="headerlink" title="reinterepret_cast"></a>reinterepret_cast</h3><p>reinterepret_cast就类似与显式类型转换</p><p>例：</p><pre><code>int a = 10;char* p;p = reinterpret_cast&lt;char*&gt;(&amp;a);</code></pre><p>​<br>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习C语言的过程中，我们会遇到不同类型变量的转换 &lt;/p&gt;
&lt;p&gt;在C++中，同在也存在，C++中类型转换与C语言的有什么区别呢？
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.bingoxin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>类与结构体</title>
    <link href="http://www.bingoxin.top/2018/07/25/%E7%B1%BB%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://www.bingoxin.top/2018/07/25/类与结构体/</id>
    <published>2018-07-25T11:06:21.000Z</published>
    <updated>2018-12-26T11:08:18.342Z</updated>
    
    <content type="html"><![CDATA[<p>在学习C语言的时候，我们就已经接触到了结构体，接触到C++我们有学习到了有关于类的知识 </p><p>接下来，让我们来搞懂这些吧~<a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="C语言和C-中的结构体有什么区别"><a href="#C语言和C-中的结构体有什么区别" class="headerlink" title="C语言和C++中的结构体有什么区别"></a>C语言和C++中的结构体有什么区别</h3><p>1.C语言中的结构体不能定义函数，而C++中的结构体不只可以有函数，还可以有虚函数</p><p>2.C语言中的内部成员的访问权限只有public，而C++中的内部成员变量的访问权限有public、protected、private三种</p><p>3.C语言的结构体是不可以继承的，而C++中的结构体可以继承自结构体或类</p><h3 id="C-中类与结构体有什么区别"><a href="#C-中类与结构体有什么区别" class="headerlink" title="C++中类与结构体有什么区别"></a>C++中类与结构体有什么区别</h3><p>1.为了兼容C，结构体内部成员变量的默认访问权限是public，而类的默认访问权限是private</p><p>2.结构体的默认继承权限是public，类的默认继承权限是private</p><p>理论上结构体可以做到的类都可以做到，类能做到的结构体不一定能做到</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习C语言的时候，我们就已经接触到了结构体，接触到C++我们有学习到了有关于类的知识 &lt;/p&gt;
&lt;p&gt;接下来，让我们来搞懂这些吧~
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.bingoxin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>测试用例的撰写</title>
    <link href="http://www.bingoxin.top/2018/07/10/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%9A%84%E6%92%B0%E5%86%99/"/>
    <id>http://www.bingoxin.top/2018/07/10/测试用例的撰写/</id>
    <published>2018-07-10T11:02:59.000Z</published>
    <updated>2018-12-26T11:17:32.345Z</updated>
    
    <content type="html"><![CDATA[<p>欲了解如何描述有效bug、bug的级别与生命周期和测试用例的设计方法，请看正文 </p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>很多初学者都认为，测试工程师就是用来找bug的，这样说只能答对一半</p><p>想知道另一半请戳<a href="http://www.bingoxin.top/2018/07/%E5%85%B3%E4%BA%8E%E6%B5%8B%E8%AF%95/">关于测试–概念篇</a></p><h3 id="那究竟如何描述有效的bug呢？"><a href="#那究竟如何描述有效的bug呢？" class="headerlink" title="那究竟如何描述有效的bug呢？"></a>那究竟如何描述有效的bug呢？</h3><p>当且仅当规格说明书存在并且正确，程序与需求规格说明书之间的不匹配才是bug。</p><h3 id="什么是有效的bug呢？"><a href="#什么是有效的bug呢？" class="headerlink" title="什么是有效的bug呢？"></a>什么是有效的bug呢？</h3><p>作为一个测试工程师，我们不能把任何一个bug都看成是有效的</p><p>而在我们发现有效的bug时，应该从以下几个方面进行描述</p><blockquote><p>发现问题的版本<br>问题触发的环境<br>错误重现的步骤<br>预期执行的描述<br>错误行为的描述<br>不把多个bug放在一起<br>其他</p></blockquote><p>一个好的测试，是可以检查出来bug，并可以告诉开发应该如何改正的</p><p>这就需要经验的积累啦！！！</p><p>bug的种类不同，这也就出现了</p><h3 id="bug的级别划分"><a href="#bug的级别划分" class="headerlink" title="bug的级别划分"></a>bug的级别划分</h3><p>根据公司的要求，对bug级别的认定也就不同，不过bug大概分为以下几类：</p><blockquote><p>1.崩溃：像电脑崩溃、死机、死循环、数据丢失等</p></blockquote><blockquote><p>2.严重：功能部分丢失等</p></blockquote><blockquote><p>3.一般：功能没有完全实现等</p></blockquote><blockquote><p>4.次要：错别字、界面格式不规范等</p></blockquote><p>在与开发沟通bug时，一定要注意言辞</p><p>对待一些bug，我们更多地是要站在用户的角度上去想</p><h3 id="bug的生命周期"><a href="#bug的生命周期" class="headerlink" title="bug的生命周期"></a>bug的生命周期</h3><div align="center"><br>    <img src="\images\posts\测试用例\bug的生命周期.PNG" height="300" width="500"><br></div><p>敲重点啦！！！</p><h3 id="测试用例设计方法"><a href="#测试用例设计方法" class="headerlink" title="测试用例设计方法"></a>测试用例设计方法</h3><p>先来说一下什么是测试用例吧~</p><p>测试用例就是对需求进行验证，所以这就说明需求也不一定是对的。</p><p> 1.等价类</p><p>例：设置密码必须为6~8为数字或字母<br>​<br>那么在测试输入设定密码位数时，6~8位为一类(有效类)，其他位数的密码为一类(无效类)。<br>​<br> 2.边界值</p><p>例：还是第一种设计方法的题目，6位和8位是符合需求规格说明书(有效类)的边界值，5位和9位位不符合(无效类)的边界值。<br>​<br>输入5位密码、6位密码、8位密码、9位密码都为测试密码是否符合的边界值，输入5位密码、6位密码、8位密码、9位密码都为测试密码是否符合的边界值<br>​<br>用于测试输入和输出的关系，是等价类的一种补充方法</p><p> 3.基于需求</p><p>任何测试用例都是依据需求规格说明书而设计的<br>​<br> 4.因果图</p><p>依据需求规格说明书确定输入与输出的关系，能直观地表明程序输入条件和输出动作之间的相互关系。<br>​<br><strong>因果图的使用：</strong><br>​<br>（1）分析所有可能的输入和输出<br>​<br>（2）找出输入和输出的关系  </p><p>（3）画出因果图<br>​<br>（4）画出判定表<br>​<br>（5）把判定表对应一个测试用例<br> 5.正交列表</p><p>在输入输出太多的情况下，因果图无法满足，正交列表不失为一种好的解决方法<br>​<br>在正交列表中，每一列中各数字出现的次数一样多，且任何两列所构成的各有序数对出现的次数都一样多<br>​<br>因果：变量                        水平：变量的取值<br>​<br>行数：试证次数，用N表示           因素数：正交表中列的个数，用C表示<br>​<br>水平数：任何单个因素能够取得的值得最大个数，正交表中的包含的值为从0到“水平数-1”或1到水平数<br>​<br>正交表的设计步骤如下：<br>​<br>(1)确定因素<br>​<br>(2)每个因素都有哪几个水平，即变量有哪几个取值<br>​<br>(3)选择一个合适的正交表<br>​<br>(4)把变量的值映射到表中<br>​<br>(5)把每一行的各因素水平的组合作为一个测试用例<br>​<br>(6)加上你认为可疑且没有在表中出现的用例组合<br>​<br> 6.场景设计法</p><p>用业务流把各个孤立的功能点串起来，事件触发时的情景便形成了场景而同一事件不同的触发顺序和处理结果形成时间流。<br>​<br> 7.错误推测法</p><p>一般经验丰富的测试工程师善用此方式<br>​<br>每个公司都会对测试进行评价，分为同行评审、用户检查和项目组评审三种。</p><p>在讲述各测试用例的设计方法时，并未举太多的例子<br>​<br>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欲了解如何描述有效bug、bug的级别与生命周期和测试用例的设计方法，请看正文 &lt;/p&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://www.bingoxin.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>关于测试</title>
    <link href="http://www.bingoxin.top/2018/07/05/%E5%85%B3%E4%BA%8E%E6%B5%8B%E8%AF%95/"/>
    <id>http://www.bingoxin.top/2018/07/05/关于测试/</id>
    <published>2018-07-05T04:13:46.000Z</published>
    <updated>2018-12-26T11:17:45.597Z</updated>
    
    <content type="html"><![CDATA[<p>软件开发，包括分析、计划、设计、编码、测试、维护六个过程。 </p><p>软件测试，即验证软件功能是否满足用户的需求（包括检测功能是否完好以及是否存在bug两方面）</p><p>接下来，请收下这篇————测试概念篇</p><a id="more"></a><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><h3 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h3><blockquote><p>目的：验证软件有或没有问题</p></blockquote><blockquote><p>原则：以客户为中心，遵循软件测试的规范、流程、标准和要求。</p></blockquote><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><blockquote><p>需求，即满足用户期望或正式规定的文档的条件或权能。</p></blockquote><blockquote><p>其包括软件需求和用户需求两种。</p></blockquote><h3 id="测试与调试的问题"><a href="#测试与调试的问题" class="headerlink" title="测试与调试的问题"></a>测试与调试的问题</h3><blockquote><p><strong>目的不同：</strong>测试的目的是发现问题，调试的目的是发现并解决问题</p><p><strong>参与角色不同：</strong>测试由开发人员和测试人员来完成，调试由开发人员来完成</p><p><strong>执行的阶段不同：</strong>测试贯穿整个软件开发生命周期，测试一般在开发阶段</p></blockquote><h3 id="总是碰到的bug"><a href="#总是碰到的bug" class="headerlink" title="总是碰到的bug"></a>总是碰到的bug</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当且仅当规格说明是存在的并且正确，程序与规格说明之间的不匹配是bug。</span><br></pre></td></tr></table></figure><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>为了实施测试而向被测试的系统提供的一组集合。（包括<font color="red" size="3">测试环境、操作步骤、测试数据、预期结果等</font>）</p><h4 id="在写测试用例的时候，一个功能点可能对应n条测试用例。"><a href="#在写测试用例的时候，一个功能点可能对应n条测试用例。" class="headerlink" title="在写测试用例的时候，一个功能点可能对应n条测试用例。"></a>在写测试用例的时候，一个功能点可能对应n条测试用例。</h4><font color="red" size="3">关于测试用例要注意以下问题：</font><blockquote><p>1.不知道是否较全面的测试了所有功能</p></blockquote><blockquote><p>2.测试的覆盖率，无法衡量</p></blockquote><blockquote><p>3.对新版本的重复测试很难实施</p></blockquote><blockquote><p>4.存在大量冗余测试影响测试效率</p></blockquote><h4 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h4><p>假设一个功能点写一条测试用例，1.0版本需要测试100个功能点，请问需要写多少条测试用例？</p><p>若软件升级为1.1版本，在原有的基础上增加了2个功能点，请问需要写多少条测试用例？</p><p>答案：100条、2条</p><h3 id="开发模型"><a href="#开发模型" class="headerlink" title="开发模型"></a>开发模型</h3><p>开发模型大概包括四种：</p><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5%E7%AF%87/开发类型.PNG" height="300" width="500"><br></div><blockquote><p>瀑布类型适用于需求稳定的项目，主要用于开发过的项目</p></blockquote><blockquote><p>螺旋项目强调风险，但是比较耗费时间</p></blockquote><blockquote><p>增量迭代其实是两种，增量是将代码逐步叠加到完整，而迭代是写出一个大概轮廓，然后将轮廓细化。</p></blockquote><p>  我们通常将这两种看作一类</p><blockquote><p>敏捷具有注重人与人的沟通、对文档要求低、客户参与度高等特点。</p></blockquote><p>  敏捷是软件公司最受欢迎的开发模型</p><p>所以接下来，我来为大家更加详细的介绍一下<font color="black" size="3">敏捷</font></p><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5%E7%AF%87/敏捷.PNG" height="300" width="500"><br></div><p>product owner<br>是类似于产品经理的一个职务（简称PO）</p><p>主要工作职责是整理用户故事，定义其商业价值并对其进行排序</p><p>scrum master<br>敏捷教练（简称sm）</p><p>主要工作职责是召开会议，协调项目，为研发团队服务</p><p>team<br>研发团队</p><p>PO，sm都属于team，但是两个有比较特殊一点</p><p>而在敏捷开发模式中，对于测试而言，会有两个挑战：</p><p>轻文档和快速迭代</p><h3 id="软件测试模型（V型和W型）"><a href="#软件测试模型（V型和W型）" class="headerlink" title="软件测试模型（V型和W型）"></a>软件测试模型（V型和W型）</h3><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5%E7%AF%87/V型测试模型.PNG" height="300" width="500"><br></div><p>我们可以发现V型测试模型忽略了软件测试的重要性</p><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/%E6%B5%8B%E8%AF%95%E6%A6%82%E5%BF%B5%E7%AF%87/W型测试模型.PNG" height="300" width="500"><br></div><p>W型测试模型与V型模型相比，虽然有所改进，但整体仍为串行结构，不能满足需求的变更</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;软件开发，包括分析、计划、设计、编码、测试、维护六个过程。 &lt;/p&gt;
&lt;p&gt;软件测试，即验证软件功能是否满足用户的需求（包括检测功能是否完好以及是否存在bug两方面）&lt;/p&gt;
&lt;p&gt;接下来，请收下这篇————测试概念篇&lt;/p&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://www.bingoxin.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>C++的三大特性之多态</title>
    <link href="http://www.bingoxin.top/2018/07/01/C-%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E5%A4%9A%E6%80%81/"/>
    <id>http://www.bingoxin.top/2018/07/01/C-的三大特性之多态/</id>
    <published>2018-07-01T04:12:26.000Z</published>
    <updated>2018-12-26T11:17:54.202Z</updated>
    
    <content type="html"><![CDATA[<p>若简历中提到了你对C++有所了解，那么面试官会有80%的可能性问关于多态的内容</p><p>接下来就来看一下，我总结的关于面试如何向面试官讲述关于多态的内容吧！ </p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><font color="blue" size="3">首先你可以讲述一下多态的概念</font><p>多态，即事物表现出的多种形态</p><p>然后你可以举个栗子~</p><p>就像是一个演员，他可以演好人，也可以演坏人。</p><p>接下来，可以说一下<font color="blue" size="3">多态的种类</font></p><p>多态分为静态多态和动态多态两种</p><h3 id="静态多态（函数重载、泛型编程）"><a href="#静态多态（函数重载、泛型编程）" class="headerlink" title="静态多态（函数重载、泛型编程）"></a>静态多态（函数重载、泛型编程）</h3><p>静态多态是编译器在编译期间完成的，根据实参类型调用函数，若实参类型与形参都不同，则系统会报错</p><p>关于函数重载的实现，可戳</p><h3 id="动态多态：（虚函数）"><a href="#动态多态：（虚函数）" class="headerlink" title="动态多态：（虚函数）"></a>动态多态：（虚函数）</h3><p>动态多态是在程序运行时完成的</p><p>讲到这里你可以讲一下<font color="blue" size="3">动态多态的实现条件</font></p><p>其需要满足两个条件：</p><blockquote><p>1.基类中必须包含虚函数，并且派生类中要对基类中的该虚函数进行重写</p></blockquote><blockquote><p>2.通过基类对象的指针或引用来调用虚函数</p></blockquote><p>关于动态多态的实现，可戳<a href="https://github.com/luckypxx/C-plus-plus/blob/master/%E5%A4%9A%E6%80%81.cpp" target="_blank" rel="noopener">动态多态例程</a></p><p>在上面讲述动态多态的实现条件时，提到了<font color="blue" size="3">重写</font>的概念</p><h3 id="重写的实现条件"><a href="#重写的实现条件" class="headerlink" title="重写的实现条件"></a>重写的实现条件</h3><blockquote><p>1.基类中被重写的函数必须为虚函数</p></blockquote><blockquote><p>2.基类和派生类中虚函数的原型必须保持一致（即函数名，函数返回类型，函数参数列表完全相同）</p></blockquote><p>基类中将被重写的虚函数和派生类中与其对应的虚函数的访问限定符可以不同</p><font color="red" size="3">两个例外：</font><p>a.析构函数</p><p>b.协变：基类（派生类）虚函数返回基类（派生类）指针或引用</p><p>关于多态实现的原理，请戳</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;若简历中提到了你对C++有所了解，那么面试官会有80%的可能性问关于多态的内容&lt;/p&gt;
&lt;p&gt;接下来就来看一下，我总结的关于面试如何向面试官讲述关于多态的内容吧！ &lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.bingoxin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++的三大特性之继承</title>
    <link href="http://www.bingoxin.top/2018/06/27/C-%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E7%BB%A7%E6%89%BF/"/>
    <id>http://www.bingoxin.top/2018/06/27/C-的三大特性之继承/</id>
    <published>2018-06-27T04:09:48.000Z</published>
    <updated>2018-12-26T11:18:00.702Z</updated>
    
    <content type="html"><![CDATA[<p>今天来为大家介绍一下继承~</p><p>继承使代码可以复用，他是为多态做铺垫的 </p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 派生类名称：继承权限 基类名称</span><br></pre></td></tr></table></figure><h3 id="继承的权限"><a href="#继承的权限" class="headerlink" title="继承的权限"></a>继承的权限</h3><p>继承的权限有public、protected、private</p><p>在这里还要提一下访问权限，有public、protected、private三种</p><p>由于基类中成员访问权限不同，以及派生类派生方式不同，会使派生类的访问权限发生变化</p><p>关系如下表所示：</p><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/%E7%BB%A7%E6%89%BF/%E7%BB%A7%E6%89%BF%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%85%B3%E7%B3%BB.PNG" height="300" width="500"><br></div><p>在派生类派生的过程中，需要注意一下几点：</p><blockquote><p>基类private成员不能在派生类中被访问</p></blockquote><blockquote><p>基类protected成员在类外不能被访问，但在派生类中可以</p></blockquote><blockquote><p>父类对象对子类对象也适用</p></blockquote><h3 id="派生类对象模型的构建与销毁"><a href="#派生类对象模型的构建与销毁" class="headerlink" title="派生类对象模型的构建与销毁"></a>派生类对象模型的构建与销毁</h3><p>派生类对象构建时，会先调用派生类成员，再调用基类对象成员</p><p>派生类对象销毁时，会先销毁派生类成员，再销毁基类对象成员</p><p>关于继承体系，要注意：基类对象和派生类对象不在同一作用域</p><p>若基类和派生类中有相同名称的成员，优先访问派生类中的该名称成员</p><p>继承分为普通继承和虚拟继承</p><font color="blue" size="3">首先你可以讲述一下多态的概念</font><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来为大家介绍一下继承~&lt;/p&gt;
&lt;p&gt;继承使代码可以复用，他是为多态做铺垫的 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.bingoxin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>动态内存开辟</title>
    <link href="http://www.bingoxin.top/2018/06/17/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F/"/>
    <id>http://www.bingoxin.top/2018/06/17/动态内存开辟/</id>
    <published>2018-06-17T04:03:54.000Z</published>
    <updated>2018-12-26T11:18:23.259Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C语言中实现方式"><a href="#C语言中实现方式" class="headerlink" title="C语言中实现方式"></a>C语言中实现方式</h3><p>使用malloc、alloc、realloc在堆上开辟空间，free将申请的空间释放掉 </p><h3 id="比较malloc-calloc-realloc"><a href="#比较malloc-calloc-realloc" class="headerlink" title="比较malloc/calloc/realloc"></a>比较malloc/calloc/realloc</h3><p><strong>相同点</strong></p><p>三者都是在堆上申请空间：</p><blockquote><p>若申请成功-&gt;返回申请的空间的首地址</p></blockquote><blockquote><p>若申请失败-&gt;返回空指针</p></blockquote><p>三者的申请空间的释放都是使用free()进行操作</p><a id="more"></a><p><strong>不同点</strong></p><blockquote><p>malloc:在堆上开辟指定字节数的空间</p></blockquote><blockquote><p>calloc:开辟空间会被0初始化</p></blockquote><blockquote><p>realloc:把原来开辟的空间缩小或扩大</p></blockquote><blockquote><p>——–&gt;缩小空间—&gt;返回原空间的地址，但空间变小<br>​<br>——–&gt;扩大空间—&gt;比较原空间连续的可用空间大小与原空间空间大小之和与申请空间的大小</p><p>——————-&gt;大于—&gt;返回空间首地址</p><p>——————-&gt;小于—&gt;重新开辟空间</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void* malloc(字节数)</span><br><span class="line">void* calloc(元素个数，元素大小)</span><br><span class="line">void* realloc(void* p,字节数)</span><br></pre></td></tr></table></figure><h3 id="malloc实现原理"><a href="#malloc实现原理" class="headerlink" title="malloc实现原理"></a>malloc实现原理</h3><p>在开辟空间时，除了所需的空间之外，还会在所需空间前开辟一个结构体，后面又追加了4个字节，防止越界</p><p><strong>结构体</strong>—共32个字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define nNoManLandSize 4</span><br><span class="line">typedef struct _CrtMemBlockHeader</span><br><span class="line">&#123;</span><br><span class="line">struct _CrtMMemBlockHeader * pBlockHeaderNext;</span><br><span class="line">struct _CrtMMemBlockHeader * pBlockHeaderPrev;//双向链表</span><br><span class="line">char * szFileName;</span><br><span class="line">int nLine;</span><br><span class="line">size_t nDataSize;</span><br><span class="line">int nBlockUse;</span><br><span class="line">long lRequest;</span><br><span class="line">unsigned char gap[nNoManLandSize];</span><br><span class="line">&#125;_CrtMenBlockHeader;</span><br></pre></td></tr></table></figure><h3 id="alloca"><a href="#alloca" class="headerlink" title="_alloca"></a>_alloca</h3><p>_alloca是在栈上申请空间的，用户不需要管理，由编译器自动维护。一旦出了使用_alloca的函数，所申请的空间会自动被收回去，不需要显式释放。</p><h3 id="常见的内存泄漏"><a href="#常见的内存泄漏" class="headerlink" title="常见的内存泄漏"></a>常见的内存泄漏</h3><ul><li>内存申请了忘记释放</li><li>指向新空间的两个指针p1、p2，若p1 = p2，这时p1、p2指向同一块空间，若free(p1);free(p2),会使同一块空间被释放两次。原来p2指向的内存块，会丢失，导致内存泄漏。</li><li>使用的空间大于开辟的空间，会将防止越界的四个字节占用，在释放内存时，会出问题</li><li>释放时传入的地址与申请时的地方不同</li></ul><h1 id="C-中申请空间"><a href="#C-中申请空间" class="headerlink" title="C++中申请空间"></a>C++中申请空间</h1><h3 id="关键字new和delete"><a href="#关键字new和delete" class="headerlink" title="关键字new和delete"></a>关键字new和delete</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int* p = new int;</span><br><span class="line">int* p1 = new int(5);</span><br><span class="line">int* p2 = new int[10];</span><br><span class="line"></span><br><span class="line">delete p;</span><br><span class="line">delete p1;</span><br><span class="line">delete[] p2;//释放连续空间</span><br></pre></td></tr></table></figure><ul><li>用new申请出的空间，不需要判空，p2申请的空间时连续的(数组的形式)</li><li>用delete删除连续空间时，需使用释放p2的形式</li><li>delete和new可以进行重载</li><li>new申请的空间，是一个完整的对象</li></ul><p><strong>delete[]和new[]要成对使用，delete和new要成对使用</strong></p><p>接下来看一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Test()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Test():&quot; &lt;&lt; this &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Test()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;~Test():&quot; &lt;&lt; this &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Test* p1 = (Test*)malloc(sizeof(Test));</span><br><span class="line">Test* p2 = new Test;</span><br><span class="line">Test* p3 = new Test[10];</span><br><span class="line"></span><br><span class="line">free(p1);</span><br><span class="line">delete p2;</span><br><span class="line">delete[] p3;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><div align="center"><br>    <img src="https://wonderhengblog.oss-cn-beijing.aliyuncs.com/pxx/post/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F/%E6%8D%95%E8%8E%B7.PNG" height="400" width="350"><br></div><p>由此我们可以看出:</p><ul><li>new出一个对象会调用类的构造函数，delete一个对象会调用类的析构函数</li><li>malloc不会调用类的构造函数，free不会调用类的析构函数</li><li>对于p3空间的申请与销毁，p3申请并开辟了10个Test对象的空间，则调用了十次构造函数，销毁时也就调用了10次析构函数</li></ul><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;C语言中实现方式&quot;&gt;&lt;a href=&quot;#C语言中实现方式&quot; class=&quot;headerlink&quot; title=&quot;C语言中实现方式&quot;&gt;&lt;/a&gt;C语言中实现方式&lt;/h3&gt;&lt;p&gt;使用malloc、alloc、realloc在堆上开辟空间，free将申请的空间释放掉 &lt;/p&gt;
&lt;h3 id=&quot;比较malloc-calloc-realloc&quot;&gt;&lt;a href=&quot;#比较malloc-calloc-realloc&quot; class=&quot;headerlink&quot; title=&quot;比较malloc/calloc/realloc&quot;&gt;&lt;/a&gt;比较malloc/calloc/realloc&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;相同点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;三者都是在堆上申请空间：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;若申请成功-&amp;gt;返回申请的空间的首地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;若申请失败-&amp;gt;返回空指针&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;三者的申请空间的释放都是使用free()进行操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.bingoxin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++中类的实例化对象</title>
    <link href="http://www.bingoxin.top/2018/06/10/C-%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.bingoxin.top/2018/06/10/C-中类的实例化对象/</id>
    <published>2018-06-10T04:02:19.000Z</published>
    <updated>2018-12-26T11:18:34.501Z</updated>
    
    <content type="html"><![CDATA[<p>C语言使用函数对内容进行封装的，而C++是用类进行封装的</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>类的关键字是class，而类的作用域也不同 </p><h3 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h3><p> 1.全局域</p><p> 2.局部域</p><p> 3.类域</p><p> 4.名字空间域</p><a id="more"></a><h3 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h3><p>类的实例化就是用类类型创建对象的过程 </p><p>类在创建实例化对象时，类本身并不被分配空间</p><p>类对象包括类里的成员变量</p><p>若计算类的大小，只需计算成员变量大小之和，但要注意内存对齐</p><p>空类大小为一个字节，为区分不同对象</p><h3 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h3><p>对象模型指的是对象中各个成员在内存中的布局方式 </p><p>注意：对象大小只包括成员变量，不包括方法</p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C语言使用函数对内容进行封装的，而C++是用类进行封装的&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;p&gt;类的关键字是class，而类的作用域也不同 &lt;/p&gt;
&lt;h3 id=&quot;类作用域&quot;&gt;&lt;a href=&quot;#类作用域&quot; class=&quot;headerlink&quot; title=&quot;类作用域&quot;&gt;&lt;/a&gt;类作用域&lt;/h3&gt;&lt;p&gt; 1.全局域&lt;/p&gt;
&lt;p&gt; 2.局部域&lt;/p&gt;
&lt;p&gt; 3.类域&lt;/p&gt;
&lt;p&gt; 4.名字空间域&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.bingoxin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++的三大特性之封装</title>
    <link href="http://www.bingoxin.top/2018/06/06/C-%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E5%B0%81%E8%A3%85/"/>
    <id>http://www.bingoxin.top/2018/06/06/C-的三大特性之封装/</id>
    <published>2018-06-06T04:00:28.000Z</published>
    <updated>2018-12-26T11:18:44.703Z</updated>
    
    <content type="html"><![CDATA[<p>面试中，在问到有关C++的内容时，通常会问到C++的三大特性是什么？</p><p>C++的三大特性是封装、继承和多态</p><p>接下来我将分三次来讲解关于这三大特性的知识</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="封装的概念"><a href="#封装的概念" class="headerlink" title="封装的概念"></a>封装的概念</h4><p>隐藏对象的属性和实现细节，仅对公开接口和对象进行交互，将数据和操作数据的方法进行有机结合。</p><p>函数是一种封装方式，在C++中更多地是用类进行封装。 </p><h4 id="访问限定符"><a href="#访问限定符" class="headerlink" title="访问限定符"></a>访问限定符</h4><p>提到封装，不得不说一下访问限定符</p><p>从该访问限定符开始，到下一个访问限定符的位置，为该访问限定符的限定范围。</p><p>访问限定符有三种：public(公有)、protected(保护)、private(私有)</p><p>公有即在类外可以访问变量</p><p>保护和私有不可以在类外访问变量，若只是单纯的限定变量访问权限，二者没什么区别，</p><p>但在继承中，作用会有所不同，欲了解可戳<a href="http://www.bingoxin.top/2018/06/%E7%BB%A7%E6%89%BF/">C++的三大特性之继承</a></p><p>访问限定符只是在编译阶段有用，当数据映射到内存后，没有任何访问限定符的区别</p><p>类的默认访问权限为私有，而结构体的默认访问权限为公有(因为结构体兼容C)。</p><h4 id="在类外如何访问私有成员变量"><a href="#在类外如何访问私有成员变量" class="headerlink" title="在类外如何访问私有成员变量"></a>在类外如何访问私有成员变量</h4><p>在类外可以通过函数、指针、引用访问私有成员变量，也可以通过共有函数给私有成员变量赋值。</p><p>请戳链接，可直接看代码<a href="https://github.com/luckypxx/C-plus-plus/blob/master/%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F.cpp" target="_blank" rel="noopener">在类外如何访问私有成员变量</a></p><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试中，在问到有关C++的内容时，通常会问到C++的三大特性是什么？&lt;/p&gt;
&lt;p&gt;C++的三大特性是封装、继承和多态&lt;/p&gt;
&lt;p&gt;接下来我将分三次来讲解关于这三大特性的知识&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.bingoxin.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>面向对象or面向过程</title>
    <link href="http://www.bingoxin.top/2018/06/05/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1or%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"/>
    <id>http://www.bingoxin.top/2018/06/05/面向对象or面向过程/</id>
    <published>2018-06-05T03:58:54.000Z</published>
    <updated>2018-12-26T11:18:53.672Z</updated>
    
    <content type="html"><![CDATA[<p>刚刚接触C++，了解到了一些基础概念，在之前学C语言时也没有接触过。</p><p>也算是感受到了C++的一点点魅力~</p><a id="more"></a><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><h3 id="面向过程？面向对象？"><a href="#面向过程？面向对象？" class="headerlink" title="面向过程？面向对象？"></a>面向过程？面向对象？</h3><p>C语言是面向过程的，而JAVA和C++是面向对象的。</p><blockquote><p>艾兰·库伯在《软件创新之路》中提到：</p></blockquote><blockquote><p>“面向过程和面向对象的区别并不像人们想象得那么大，面向对象的大部分思想在面向过程中也能体现,</p></blockquote><blockquote><p>但面向过程最大的问题在于系统的膨胀，面向对象将无法应付，最终导致系统的崩溃。”</p></blockquote><h3 id="面向过程和面向对象的区别大概有如下几个方面："><a href="#面向过程和面向对象的区别大概有如下几个方面：" class="headerlink" title="面向过程和面向对象的区别大概有如下几个方面："></a>面向过程和面向对象的区别大概有如下几个方面：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.面向过程重用的是函数，而面对对象重用的是类（即将数据和处理数据的过程及函数封装在一起的实体）。</span><br><span class="line"> </span><br><span class="line">2.面向过程程序设计方法的实质上是从计算机处理问题的观点来进行程序设计工作：输入--运算--输出；</span><br><span class="line"> </span><br><span class="line">面向对象程序设计方法需要使用结构化的程序来设计。</span><br><span class="line"></span><br><span class="line">3. 面向过程程序设计是一种自上而下的程序设计方法，从程序的一部分入手，一点一点地构建出整个程序；</span><br><span class="line"> </span><br><span class="line">面向对象程序设计是以一数据为中心，类作为表现数据的工具，成为划分程序的基本单位。</span><br></pre></td></tr></table></figure><p>欢迎交流~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚刚接触C++，了解到了一些基础概念，在之前学C语言时也没有接触过。&lt;/p&gt;
&lt;p&gt;也算是感受到了C++的一点点魅力~&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.bingoxin.top/tags/C-C/"/>
    
  </entry>
  
</feed>
